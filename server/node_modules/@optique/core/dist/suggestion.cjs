const require_message = require('./message.cjs');
const require_usage = require('./usage.cjs');

//#region src/suggestion.ts
/**
* Calculates the Levenshtein distance between two strings.
*
* The Levenshtein distance is the minimum number of single-character edits
* (insertions, deletions, or substitutions) required to transform one string
* into another.
*
* @param source The source string
* @param target The target string
* @returns The edit distance (number of insertions, deletions, substitutions)
*
* @example
* ```typescript
* levenshteinDistance("kitten", "sitting"); // returns 3
* levenshteinDistance("--verbos", "--verbose"); // returns 1
* levenshteinDistance("hello", "hello"); // returns 0
* ```
*/
function levenshteinDistance(source, target) {
	if (source.length === 0) return target.length;
	if (target.length === 0) return source.length;
	if (source.length > target.length) [source, target] = [target, source];
	let previousRow = new Array(source.length + 1);
	let currentRow = new Array(source.length + 1);
	for (let i = 0; i <= source.length; i++) previousRow[i] = i;
	for (let j = 1; j <= target.length; j++) {
		currentRow[0] = j;
		for (let i = 1; i <= source.length; i++) {
			const cost = source[i - 1] === target[j - 1] ? 0 : 1;
			currentRow[i] = Math.min(currentRow[i - 1] + 1, previousRow[i] + 1, previousRow[i - 1] + cost);
		}
		[previousRow, currentRow] = [currentRow, previousRow];
	}
	return previousRow[source.length];
}
/**
* Default options for finding similar strings.
* These values are optimized for command-line option/command name suggestions.
*
* @since 0.7.0
*/
const DEFAULT_FIND_SIMILAR_OPTIONS = {
	maxDistance: 3,
	maxDistanceRatio: .5,
	maxSuggestions: 3,
	caseSensitive: false
};
/**
* Finds similar strings from a list of candidates.
*
* This function uses Levenshtein distance to find strings that are similar
* to the input string. Results are sorted by similarity (most similar first).
*
* @param input The input string to find matches for
* @param candidates List of candidate strings to compare against
* @param options Configuration options
* @returns Array of similar strings, sorted by similarity (most similar first)
*
* @example
* ```typescript
* const candidates = ["--verbose", "--version", "--verify", "--help"];
* findSimilar("--verbos", candidates);
* // returns ["--verbose"]
*
* findSimilar("--ver", candidates, { maxDistance: 5 });
* // returns ["--verify", "--version", "--verbose"]
*
* findSimilar("--xyz", candidates);
* // returns [] (no similar matches)
* ```
*/
function findSimilar(input, candidates, options = {}) {
	const maxDistance = options.maxDistance ?? DEFAULT_FIND_SIMILAR_OPTIONS.maxDistance;
	const maxDistanceRatio = options.maxDistanceRatio ?? DEFAULT_FIND_SIMILAR_OPTIONS.maxDistanceRatio;
	const maxSuggestions = options.maxSuggestions ?? DEFAULT_FIND_SIMILAR_OPTIONS.maxSuggestions;
	const caseSensitive = options.caseSensitive ?? DEFAULT_FIND_SIMILAR_OPTIONS.caseSensitive;
	if (input.length === 0) return [];
	const normalizedInput = caseSensitive ? input : input.toLowerCase();
	const matches = [];
	for (const candidate of candidates) {
		const normalizedCandidate = caseSensitive ? candidate : candidate.toLowerCase();
		const distance = levenshteinDistance(normalizedInput, normalizedCandidate);
		if (distance === 0) return [candidate];
		const distanceRatio = distance / input.length;
		if (distance <= maxDistance && distanceRatio <= maxDistanceRatio) matches.push({
			candidate,
			distance
		});
	}
	matches.sort((a, b) => {
		if (a.distance !== b.distance) return a.distance - b.distance;
		const lengthDiffA = Math.abs(a.candidate.length - input.length);
		const lengthDiffB = Math.abs(b.candidate.length - input.length);
		if (lengthDiffA !== lengthDiffB) return lengthDiffA - lengthDiffB;
		return a.candidate.localeCompare(b.candidate);
	});
	return matches.slice(0, maxSuggestions).map((m) => m.candidate);
}
/**
* Creates a suggestion message for a mismatched option/command.
*
* This function formats suggestions in a user-friendly way:
* - No suggestions: returns empty message
* - One suggestion: "Did you mean `option`?"
* - Multiple suggestions: "Did you mean one of these?\n  option1\n  option2"
*
* @param suggestions List of similar valid options/commands
* @returns A Message array with suggestion text
*
* @example
* ```typescript
* createSuggestionMessage(["--verbose", "--version"]);
* // returns message parts for:
* // "Did you mean one of these?
* //   --verbose
* //   --version"
*
* createSuggestionMessage(["--verbose"]);
* // returns message parts for:
* // "Did you mean `--verbose`?"
*
* createSuggestionMessage([]);
* // returns []
* ```
*/
function createSuggestionMessage(suggestions) {
	if (suggestions.length === 0) return [];
	if (suggestions.length === 1) return require_message.message`Did you mean ${require_message.optionName(suggestions[0])}?`;
	const messageParts = [require_message.text("Did you mean one of these?")];
	for (const suggestion of suggestions) {
		messageParts.push(require_message.text("\n  "));
		messageParts.push(require_message.optionName(suggestion));
	}
	return messageParts;
}
/**
* Creates an error message with suggestions for similar options or commands.
*
* This is a convenience function that combines the functionality of
* `findSimilar()` and `createSuggestionMessage()` to generate user-friendly
* error messages with "Did you mean?" suggestions.
*
* @param baseError The base error message to display
* @param invalidInput The invalid option or command name that the user typed
* @param usage The usage information to extract available options/commands from
* @param type What type of names to suggest ("option", "command", or "both")
* @param customFormatter Optional custom function to format suggestions instead
*                        of using the default "Did you mean?" formatting
* @returns A message combining the base error with suggestions, or just the
*          base error if no similar names are found
*
* @example
* ```typescript
* const baseError = message`No matched option for ${optionName("--verbos")}.`;
* const error = createErrorWithSuggestions(
*   baseError,
*   "--verbos",
*   context.usage,
*   "option"
* );
* // Returns: "No matched option for `--verbos`.\nDid you mean `--verbose`?"
* ```
*
* @since 0.7.0
*/
function createErrorWithSuggestions(baseError, invalidInput, usage, type = "both", customFormatter) {
	const candidates = /* @__PURE__ */ new Set();
	if (type === "option" || type === "both") for (const name of require_usage.extractOptionNames(usage)) candidates.add(name);
	if (type === "command" || type === "both") for (const name of require_usage.extractCommandNames(usage)) candidates.add(name);
	const suggestions = findSimilar(invalidInput, candidates, DEFAULT_FIND_SIMILAR_OPTIONS);
	const suggestionMsg = customFormatter ? customFormatter(suggestions) : createSuggestionMessage(suggestions);
	return suggestionMsg.length > 0 ? [
		...baseError,
		require_message.text("\n\n"),
		...suggestionMsg
	] : baseError;
}
/**
* Creates a unique key for a suggestion to enable deduplication.
*
* For literal suggestions, the text itself is used as the key.
* For file suggestions, a composite key is created from the type,
* extensions, and pattern.
*
* @param suggestion The suggestion to create a key for
* @returns A string key that uniquely identifies this suggestion
* @internal
*/
function getSuggestionKey(suggestion) {
	if (suggestion.kind === "literal") return suggestion.text;
	return `__FILE__:${suggestion.type}:${suggestion.extensions?.join(",") ?? ""}:${suggestion.pattern ?? ""}`;
}
/**
* Removes duplicate suggestions from an array while preserving order.
*
* Suggestions are considered duplicates if they have the same key:
* - Literal suggestions: same text
* - File suggestions: same type, extensions, and pattern
*
* The first occurrence of each unique suggestion is kept.
*
* @param suggestions Array of suggestions that may contain duplicates
* @returns A new array with duplicates removed, preserving order of first occurrences
*
* @example
* ```typescript
* const suggestions = [
*   { kind: "literal", text: "--verbose" },
*   { kind: "literal", text: "--help" },
*   { kind: "literal", text: "--verbose" }, // duplicate
* ];
* deduplicateSuggestions(suggestions);
* // returns [{ kind: "literal", text: "--verbose" }, { kind: "literal", text: "--help" }]
* ```
*
* @since 0.9.0
*/
function deduplicateSuggestions(suggestions) {
	const seen = /* @__PURE__ */ new Set();
	return suggestions.filter((suggestion) => {
		const key = getSuggestionKey(suggestion);
		if (seen.has(key)) return false;
		seen.add(key);
		return true;
	});
}

//#endregion
exports.DEFAULT_FIND_SIMILAR_OPTIONS = DEFAULT_FIND_SIMILAR_OPTIONS;
exports.createErrorWithSuggestions = createErrorWithSuggestions;
exports.deduplicateSuggestions = deduplicateSuggestions;
exports.findSimilar = findSimilar;