const require_message = require('./message.cjs');
const require_usage = require('./usage.cjs');
const require_constructs = require('./constructs.cjs');
const require_modifiers = require('./modifiers.cjs');
const require_primitives = require('./primitives.cjs');

//#region src/parser.ts
/**
* Parses an array of command-line arguments using the provided combined parser.
* This function processes the input arguments, applying the parser to each
* argument until all arguments are consumed or an error occurs.
*
* This function only accepts synchronous parsers. For asynchronous parsers,
* use {@link parseAsync}.
*
* @template T The type of the value produced by the parser.
* @param parser The combined {@link Parser} to use for parsing the input
*               arguments.  Must be a synchronous parser.
* @param args The array of command-line arguments to parse.  Usually this is
*             `process.argv.slice(2)` in Node.js or `Deno.args` in Deno.
* @returns A {@link Result} object indicating whether the parsing was
*          successful or not.  If successful, it contains the parsed value of
*          type `T`.  If not, it contains an error message describing the
*          failure.
* @since 0.9.0 Renamed from the original `parse` function which now delegates
*              to this for sync parsers.
*/
function parseSync(parser, args) {
	let context = {
		buffer: args,
		optionsTerminated: false,
		state: parser.initialState,
		usage: parser.usage
	};
	do {
		const result = parser.parse(context);
		if (!result.success) return {
			success: false,
			error: result.error
		};
		const previousBuffer = context.buffer;
		context = result.next;
		if (context.buffer.length > 0 && context.buffer.length === previousBuffer.length && context.buffer.every((item, i) => item === previousBuffer[i])) return {
			success: false,
			error: require_message.message`Unexpected option or argument: ${context.buffer[0]}.`
		};
	} while (context.buffer.length > 0);
	const endResult = parser.complete(context.state);
	return endResult.success ? {
		success: true,
		value: endResult.value
	} : {
		success: false,
		error: endResult.error
	};
}
/**
* Parses an array of command-line arguments using the provided combined parser.
* This function processes the input arguments, applying the parser to each
* argument until all arguments are consumed or an error occurs.
*
* This function accepts any parser (sync or async) and always returns a Promise.
* For synchronous parsing with sync parsers, use {@link parseSync} instead.
*
* @template T The type of the value produced by the parser.
* @param parser The combined {@link Parser} to use for parsing the input
*               arguments.
* @param args The array of command-line arguments to parse.  Usually this is
*             `process.argv.slice(2)` in Node.js or `Deno.args` in Deno.
* @returns A Promise that resolves to a {@link Result} object indicating
*          whether the parsing was successful or not.
* @since 0.9.0
*/
async function parseAsync(parser, args) {
	let context = {
		buffer: args,
		optionsTerminated: false,
		state: parser.initialState,
		usage: parser.usage
	};
	do {
		const result = await parser.parse(context);
		if (!result.success) return {
			success: false,
			error: result.error
		};
		const previousBuffer = context.buffer;
		context = result.next;
		if (context.buffer.length > 0 && context.buffer.length === previousBuffer.length && context.buffer.every((item, i) => item === previousBuffer[i])) return {
			success: false,
			error: require_message.message`Unexpected option or argument: ${context.buffer[0]}.`
		};
	} while (context.buffer.length > 0);
	const endResult = await parser.complete(context.state);
	return endResult.success ? {
		success: true,
		value: endResult.value
	} : {
		success: false,
		error: endResult.error
	};
}
/**
* Parses an array of command-line arguments using the provided combined parser.
* This function processes the input arguments, applying the parser to each
* argument until all arguments are consumed or an error occurs.
*
* The return type depends on the parser's mode:
* - Sync parsers return `Result<T>` directly.
* - Async parsers return `Promise<Result<T>>`.
*
* For explicit control, use {@link parseSync} or {@link parseAsync}.
*
* @template M The execution mode of the parser.
* @template T The type of the value produced by the parser.
* @param parser The combined {@link Parser} to use for parsing the input
*               arguments.
* @param args The array of command-line arguments to parse.  Usually this is
*             `process.argv.slice(2)` in Node.js or `Deno.args` in Deno.
* @returns A {@link Result} object (for sync) or Promise thereof (for async)
*          indicating whether the parsing was successful or not.
*/
function parse(parser, args) {
	if (parser.$mode === "async") return parseAsync(parser, args);
	return parseSync(parser, args);
}
/**
* Generates command-line suggestions based on current parsing state.
* This function processes the input arguments up to the last argument,
* then calls the parser's suggest method with the remaining prefix.
*
* This function only accepts synchronous parsers. For asynchronous parsers,
* use {@link suggestAsync}.
*
* @template T The type of the value produced by the parser.
* @param parser The {@link Parser} to use for generating suggestions.
*               Must be a synchronous parser.
* @param args The array of command-line arguments including the partial
*             argument to complete.  The last element is treated as
*             the prefix for suggestions.
* @returns An array of {@link Suggestion} objects containing completion
*          candidates.
* @example
* ```typescript
* const parser = object({
*   verbose: option("-v", "--verbose"),
*   format: option("-f", "--format", choice(["json", "yaml"]))
* });
*
* // Get suggestions for options starting with "--"
* const suggestions = suggestSync(parser, ["--"]);
* // Returns: [{ text: "--verbose" }, { text: "--format" }]
*
* // Get suggestions after parsing some arguments
* const suggestions2 = suggestSync(parser, ["-v", "--format="]);
* // Returns: [{ text: "--format=json" }, { text: "--format=yaml" }]
* ```
* @since 0.6.0
* @since 0.9.0 Renamed from the original `suggest` function.
*/
function suggestSync(parser, args) {
	const allButLast = args.slice(0, -1);
	const prefix = args[args.length - 1];
	let context = {
		buffer: allButLast,
		optionsTerminated: false,
		state: parser.initialState,
		usage: parser.usage
	};
	while (context.buffer.length > 0) {
		const result = parser.parse(context);
		if (!result.success) return Array.from(parser.suggest(context, prefix));
		const previousBuffer = context.buffer;
		context = result.next;
		if (context.buffer.length > 0 && context.buffer.length === previousBuffer.length && context.buffer.every((item, i) => item === previousBuffer[i])) return [];
	}
	return Array.from(parser.suggest(context, prefix));
}
/**
* Generates command-line suggestions based on current parsing state.
* This function processes the input arguments up to the last argument,
* then calls the parser's suggest method with the remaining prefix.
*
* This function accepts any parser (sync or async) and always returns a Promise.
* For synchronous suggestion generation with sync parsers, use
* {@link suggestSync} instead.
*
* @template T The type of the value produced by the parser.
* @param parser The {@link Parser} to use for generating suggestions.
* @param args The array of command-line arguments including the partial
*             argument to complete.  The last element is treated as
*             the prefix for suggestions.
* @returns A Promise that resolves to an array of {@link Suggestion} objects
*          containing completion candidates.
* @since 0.9.0
*/
async function suggestAsync(parser, args) {
	const allButLast = args.slice(0, -1);
	const prefix = args[args.length - 1];
	let context = {
		buffer: allButLast,
		optionsTerminated: false,
		state: parser.initialState,
		usage: parser.usage
	};
	while (context.buffer.length > 0) {
		const result = await parser.parse(context);
		if (!result.success) {
			const suggestions$1 = [];
			for await (const suggestion of parser.suggest(context, prefix)) suggestions$1.push(suggestion);
			return suggestions$1;
		}
		const previousBuffer = context.buffer;
		context = result.next;
		if (context.buffer.length > 0 && context.buffer.length === previousBuffer.length && context.buffer.every((item, i) => item === previousBuffer[i])) return [];
	}
	const suggestions = [];
	for await (const suggestion of parser.suggest(context, prefix)) suggestions.push(suggestion);
	return suggestions;
}
/**
* Generates command-line suggestions based on current parsing state.
* This function processes the input arguments up to the last argument,
* then calls the parser's suggest method with the remaining prefix.
*
* The return type depends on the parser's mode:
* - Sync parsers return `readonly Suggestion[]` directly.
* - Async parsers return `Promise<readonly Suggestion[]>`.
*
* For explicit control, use {@link suggestSync} or {@link suggestAsync}.
*
* @template M The execution mode of the parser.
* @template T The type of the value produced by the parser.
* @param parser The {@link Parser} to use for generating suggestions.
* @param args The array of command-line arguments including the partial
*             argument to complete.  The last element is treated as
*             the prefix for suggestions.
* @returns An array of {@link Suggestion} objects (for sync) or Promise thereof
*          (for async) containing completion candidates.
* @since 0.6.0
*/
function suggest(parser, args) {
	if (parser.$mode === "async") return suggestAsync(parser, args);
	return suggestSync(parser, args);
}
/**
* Recursively searches for a command within nested exclusive usage terms.
* When the command is found, returns the expanded usage terms for that command.
*
* @param term The usage term to search in
* @param commandName The command name to find
* @returns The expanded usage terms if found, null otherwise
*/
function findCommandInExclusive(term, commandName) {
	if (term.type !== "exclusive") return null;
	for (const termGroup of term.terms) {
		const firstTerm = termGroup[0];
		if (firstTerm?.type === "command" && firstTerm.name === commandName) return termGroup;
		if (firstTerm?.type === "exclusive") {
			const found = findCommandInExclusive(firstTerm, commandName);
			if (found) return [...found, ...termGroup.slice(1)];
		}
	}
	return null;
}
/**
* Generates a documentation page for a synchronous parser.
*
* This is the sync-specific version of {@link getDocPage}. It only accepts
* sync parsers and returns the documentation page directly (not wrapped
* in a Promise).
*
* @param parser The sync parser to generate documentation for.
* @param args Optional array of command-line arguments for context.
* @returns A {@link DocPage} or `undefined`.
* @since 0.9.0
*/
function getDocPageSync(parser, args = []) {
	return getDocPageSyncImpl(parser, args);
}
/**
* Generates a documentation page for any parser, returning a Promise.
*
* This function accepts parsers of any mode (sync or async) and always
* returns a Promise. Use this when working with parsers that may contain
* async value parsers.
*
* @param parser The parser to generate documentation for.
* @param args Optional array of command-line arguments for context.
* @returns A Promise of {@link DocPage} or `undefined`.
* @since 0.9.0
*/
function getDocPageAsync(parser, args = []) {
	if (parser.$mode === "sync") return Promise.resolve(getDocPageSyncImpl(parser, args));
	return getDocPageAsyncImpl(parser, args);
}
function getDocPage(parser, args = []) {
	if (parser.$mode === "sync") return getDocPageSyncImpl(parser, args);
	return getDocPageAsyncImpl(parser, args);
}
/**
* Internal sync implementation of getDocPage.
*/
function getDocPageSyncImpl(parser, args) {
	let context = {
		buffer: args,
		optionsTerminated: false,
		state: parser.initialState,
		usage: parser.usage
	};
	do {
		const result = parser.parse(context);
		if (!result.success) break;
		context = result.next;
	} while (context.buffer.length > 0);
	return buildDocPage(parser, context, args);
}
/**
* Internal async implementation of getDocPage.
*/
async function getDocPageAsyncImpl(parser, args) {
	let context = {
		buffer: args,
		optionsTerminated: false,
		state: parser.initialState,
		usage: parser.usage
	};
	do {
		const result = await parser.parse(context);
		if (!result.success) break;
		context = result.next;
	} while (context.buffer.length > 0);
	return buildDocPage(parser, context, args);
}
/**
* Builds a DocPage from the parser and context.
* Shared by both sync and async implementations.
*/
function buildDocPage(parser, context, args) {
	const { description, fragments, footer } = parser.getDocFragments({
		kind: "available",
		state: context.state
	}, void 0);
	const entries = fragments.filter((f) => f.type === "entry");
	const sections = [];
	for (const fragment of fragments) {
		if (fragment.type !== "section") continue;
		if (fragment.title == null) entries.push(...fragment.entries);
		else sections.push(fragment);
	}
	if (entries.length > 0) sections.push({ entries });
	const usage = [...require_usage.normalizeUsage(parser.usage)];
	let i = 0;
	for (const arg of args) {
		if (i >= usage.length) break;
		const term = usage[i];
		if (term.type === "exclusive") {
			const found = findCommandInExclusive(term, arg);
			if (found) {
				usage.splice(i, 1, ...found);
				i += found.length;
			} else i++;
		} else i++;
	}
	return {
		usage,
		sections,
		...description != null && { description },
		...footer != null && { footer }
	};
}

//#endregion
exports.DuplicateOptionError = require_constructs.DuplicateOptionError;
exports.WithDefaultError = require_modifiers.WithDefaultError;
exports.argument = require_primitives.argument;
exports.command = require_primitives.command;
exports.concat = require_constructs.concat;
exports.conditional = require_constructs.conditional;
exports.constant = require_primitives.constant;
exports.flag = require_primitives.flag;
exports.getDocPage = getDocPage;
exports.getDocPageAsync = getDocPageAsync;
exports.getDocPageSync = getDocPageSync;
exports.group = require_constructs.group;
exports.longestMatch = require_constructs.longestMatch;
exports.map = require_modifiers.map;
exports.merge = require_constructs.merge;
exports.multiple = require_modifiers.multiple;
exports.object = require_constructs.object;
exports.option = require_primitives.option;
exports.optional = require_modifiers.optional;
exports.or = require_constructs.or;
exports.parse = parse;
exports.parseAsync = parseAsync;
exports.parseSync = parseSync;
exports.passThrough = require_primitives.passThrough;
exports.suggest = suggest;
exports.suggestAsync = suggestAsync;
exports.suggestSync = suggestSync;
exports.tuple = require_constructs.tuple;
exports.withDefault = require_modifiers.withDefault;