import { message, optionName, values } from "./message.js";
import { extractArgumentMetavars, extractCommandNames, extractOptionNames } from "./usage.js";
import { createErrorWithSuggestions, deduplicateSuggestions } from "./suggestion.js";

//#region src/constructs.ts
/**
* Checks if the given token is an option name that requires a value
* (i.e., has a metavar) within the given usage terms.
* @param usage The usage terms to search through.
* @param token The token to check.
* @returns `true` if the token is an option that requires a value, `false` otherwise.
*/
function isOptionRequiringValue(usage, token) {
	function traverse(terms) {
		if (!terms || !Array.isArray(terms)) return false;
		for (const term of terms) if (term.type === "option") {
			if (term.metavar && term.names.includes(token)) return true;
		} else if (term.type === "optional" || term.type === "multiple") {
			if (traverse(term.terms)) return true;
		} else if (term.type === "exclusive") {
			for (const exclusiveUsage of term.terms) if (traverse(exclusiveUsage)) return true;
		}
		return false;
	}
	return traverse(usage);
}
/**
* Extracts required (non-optional) usage terms from a usage array.
* @param usage The usage to extract required terms from
* @returns Usage containing only required (non-optional) terms
*/
function extractRequiredUsage(usage) {
	const required = [];
	for (const term of usage) if (term.type === "optional") continue;
	else if (term.type === "exclusive") {
		const requiredBranches = term.terms.map((branch) => extractRequiredUsage(branch)).filter((branch) => branch.length > 0);
		if (requiredBranches.length > 0) required.push({
			type: "exclusive",
			terms: requiredBranches
		});
	} else if (term.type === "multiple") {
		if (term.min > 0) {
			const requiredTerms = extractRequiredUsage(term.terms);
			if (requiredTerms.length > 0) required.push({
				type: "multiple",
				terms: requiredTerms,
				min: term.min
			});
		}
	} else required.push(term);
	return required;
}
/**
* Analyzes parsers to determine what types of inputs are expected.
* @param parsers The parsers being combined
* @returns Context about what types of inputs are expected
*/
function analyzeNoMatchContext(parsers) {
	const combinedUsage = [{
		type: "exclusive",
		terms: parsers.map((p) => p.usage)
	}];
	const requiredUsage = extractRequiredUsage(combinedUsage);
	return {
		hasOptions: extractOptionNames(requiredUsage).size > 0,
		hasCommands: extractCommandNames(requiredUsage).size > 0,
		hasArguments: extractArgumentMetavars(requiredUsage).size > 0
	};
}
/**
* Error class thrown when duplicate option names are detected during parser
* construction. This is a programmer error, not a user error.
*/
var DuplicateOptionError = class extends Error {
	constructor(optionName$1, sources) {
		const sourceNames = sources.map((s) => typeof s === "symbol" ? s.description ?? s.toString() : s);
		super(`Duplicate option name "${optionName$1}" found in fields: ${sourceNames.join(", ")}. Each option name must be unique within a parser combinator.`);
		this.optionName = optionName$1;
		this.sources = sources;
		this.name = "DuplicateOptionError";
	}
};
/**
* Checks for duplicate option names across parser sources and throws an error
* if duplicates are found. This should be called at construction time.
* @param parserSources Array of [source, usage] tuples
* @throws DuplicateOptionError if duplicate option names are found
*/
function checkDuplicateOptionNames(parserSources) {
	const optionNameSources = /* @__PURE__ */ new Map();
	for (const [source, usage] of parserSources) {
		const names = extractOptionNames(usage);
		for (const name of names) {
			if (!optionNameSources.has(name)) optionNameSources.set(name, []);
			optionNameSources.get(name).push(source);
		}
	}
	for (const [name, sources] of optionNameSources) if (sources.length > 1) throw new DuplicateOptionError(name, sources);
}
/**
* Generates a contextual error message based on what types of inputs
* the parsers expect (options, commands, or arguments).
* @param context Context about what types of inputs are expected
* @returns An appropriate error message
*/
function generateNoMatchError(context) {
	const { hasOptions, hasCommands, hasArguments } = context;
	if (hasArguments && !hasOptions && !hasCommands) return message`Missing required argument.`;
	else if (hasCommands && !hasOptions && !hasArguments) return message`No matching command found.`;
	else if (hasOptions && !hasCommands && !hasArguments) return message`No matching option found.`;
	else if (hasCommands && hasOptions && !hasArguments) return message`No matching option or command found.`;
	else if (hasArguments && hasOptions && !hasCommands) return message`No matching option or argument found.`;
	else if (hasArguments && hasCommands && !hasOptions) return message`No matching command or argument found.`;
	else return message`No matching option, command, or argument found.`;
}
/**
* Creates a complete() method shared by or() and longestMatch().
* @internal
*/
function createExclusiveComplete(parsers, options, noMatchContext, isAsync) {
	const syncParsers = parsers;
	return (state) => {
		if (state == null) return {
			success: false,
			error: getNoMatchError(options, noMatchContext)
		};
		const [i, result] = state;
		if (!result.success) return {
			success: false,
			error: result.error
		};
		if (isAsync) return (async () => {
			const completeResult = await parsers[i].complete(result.next.state);
			return completeResult;
		})();
		return syncParsers[i].complete(result.next.state);
	};
}
/**
* Creates a suggest() method shared by or() and longestMatch().
* @internal
*/
function createExclusiveSuggest(parsers, isAsync) {
	const syncParsers = parsers;
	if (isAsync) return (context, prefix) => {
		return async function* () {
			const suggestions = [];
			if (context.state == null) for (const parser of parsers) {
				const parserSuggestions = parser.suggest({
					...context,
					state: parser.initialState
				}, prefix);
				if (parser.$mode === "async") for await (const s of parserSuggestions) suggestions.push(s);
				else suggestions.push(...parserSuggestions);
			}
			else {
				const [index, parserResult] = context.state;
				if (parserResult.success) {
					const parser = parsers[index];
					const parserSuggestions = parser.suggest({
						...context,
						state: parserResult.next.state
					}, prefix);
					if (parser.$mode === "async") for await (const s of parserSuggestions) suggestions.push(s);
					else suggestions.push(...parserSuggestions);
				}
			}
			yield* deduplicateSuggestions(suggestions);
		}();
	};
	return (context, prefix) => {
		return function* () {
			const suggestions = [];
			if (context.state == null) for (const parser of syncParsers) {
				const parserSuggestions = parser.suggest({
					...context,
					state: parser.initialState
				}, prefix);
				suggestions.push(...parserSuggestions);
			}
			else {
				const [index, parserResult] = context.state;
				if (parserResult.success) {
					const parserSuggestions = syncParsers[index].suggest({
						...context,
						state: parserResult.next.state
					}, prefix);
					suggestions.push(...parserSuggestions);
				}
			}
			yield* deduplicateSuggestions(suggestions);
		}();
	};
}
/**
* Gets the no-match error, either from custom options or default.
* Shared by or() and longestMatch().
* @internal
*/
function getNoMatchError(options, noMatchContext) {
	const customNoMatch = options?.errors?.noMatch;
	return customNoMatch ? typeof customNoMatch === "function" ? customNoMatch(noMatchContext) : customNoMatch : generateNoMatchError(noMatchContext);
}
/**
* Creates default error for parse() method when buffer is not empty.
* Shared by or() and longestMatch().
* @internal
*/
function createUnexpectedInputError(token, usage, options) {
	const defaultMsg = message`Unexpected option or subcommand: ${optionName(token)}.`;
	if (options?.errors?.unexpectedInput != null) return typeof options.errors.unexpectedInput === "function" ? options.errors.unexpectedInput(token) : options.errors.unexpectedInput;
	return createErrorWithSuggestions(defaultMsg, token, usage, "both", options?.errors?.suggestions);
}
/**
* @since 0.5.0
*/
function or(...args) {
	let parsers;
	let options;
	if (args.length > 0 && args[args.length - 1] && typeof args[args.length - 1] === "object" && !("$valueType" in args[args.length - 1])) {
		options = args[args.length - 1];
		parsers = args.slice(0, -1);
	} else {
		parsers = args;
		options = void 0;
	}
	const noMatchContext = analyzeNoMatchContext(parsers);
	const combinedMode = parsers.some((p) => p.$mode === "async") ? "async" : "sync";
	const isAsync = combinedMode === "async";
	const syncParsers = parsers;
	const getInitialError = (context) => ({
		consumed: 0,
		error: context.buffer.length < 1 ? getNoMatchError(options, noMatchContext) : createUnexpectedInputError(context.buffer[0], context.usage, options)
	});
	const parseSync = (context) => {
		let error = getInitialError(context);
		const orderedParsers = syncParsers.map((p, i) => [p, i]);
		orderedParsers.sort(([_, a], [__, b]) => context.state?.[0] === a ? -1 : context.state?.[0] === b ? 1 : a - b);
		for (const [parser, i] of orderedParsers) {
			const result = parser.parse({
				...context,
				state: context.state == null || context.state[0] !== i || !context.state[1].success ? parser.initialState : context.state[1].next.state
			});
			if (result.success && result.consumed.length > 0) {
				if (context.state?.[0] !== i && context.state?.[1].success) return {
					success: false,
					consumed: context.buffer.length - result.next.buffer.length,
					error: message`${values(context.state[1].consumed)} and ${values(result.consumed)} cannot be used together.`
				};
				return {
					success: true,
					next: {
						...context,
						buffer: result.next.buffer,
						optionsTerminated: result.next.optionsTerminated,
						state: [i, result]
					},
					consumed: result.consumed
				};
			} else if (!result.success && error.consumed < result.consumed) error = result;
		}
		return {
			...error,
			success: false
		};
	};
	const parseAsync = async (context) => {
		let error = getInitialError(context);
		const orderedParsers = parsers.map((p, i) => [p, i]);
		orderedParsers.sort(([_, a], [__, b]) => context.state?.[0] === a ? -1 : context.state?.[0] === b ? 1 : a - b);
		for (const [parser, i] of orderedParsers) {
			const resultOrPromise = parser.parse({
				...context,
				state: context.state == null || context.state[0] !== i || !context.state[1].success ? parser.initialState : context.state[1].next.state
			});
			const result = await resultOrPromise;
			if (result.success && result.consumed.length > 0) {
				if (context.state?.[0] !== i && context.state?.[1].success) return {
					success: false,
					consumed: context.buffer.length - result.next.buffer.length,
					error: message`${values(context.state[1].consumed)} and ${values(result.consumed)} cannot be used together.`
				};
				return {
					success: true,
					next: {
						...context,
						buffer: result.next.buffer,
						optionsTerminated: result.next.optionsTerminated,
						state: [i, result]
					},
					consumed: result.consumed
				};
			} else if (!result.success && error.consumed < result.consumed) error = result;
		}
		return {
			...error,
			success: false
		};
	};
	return {
		$mode: combinedMode,
		$valueType: [],
		$stateType: [],
		priority: Math.max(...parsers.map((p) => p.priority)),
		usage: [{
			type: "exclusive",
			terms: parsers.map((p) => p.usage)
		}],
		initialState: void 0,
		complete: createExclusiveComplete(parsers, options, noMatchContext, isAsync),
		parse(context) {
			if (isAsync) return parseAsync(context);
			return parseSync(context);
		},
		suggest: createExclusiveSuggest(parsers, isAsync),
		getDocFragments(state, _defaultValue) {
			let description;
			let fragments;
			if (state.kind === "unavailable" || state.state == null) fragments = parsers.flatMap((p) => p.getDocFragments({ kind: "unavailable" }, void 0).fragments);
			else {
				const [index, parserResult] = state.state;
				const innerState = parserResult.success ? {
					kind: "available",
					state: parserResult.next.state
				} : { kind: "unavailable" };
				const docFragments = parsers[index].getDocFragments(innerState, void 0);
				description = docFragments.description;
				fragments = docFragments.fragments;
			}
			const entries = fragments.filter((f) => f.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			return {
				description,
				fragments: [...sections.map((s) => ({
					...s,
					type: "section"
				})), {
					type: "section",
					entries
				}]
			};
		}
	};
}
/**
* @since 0.5.0
*/
function longestMatch(...args) {
	let parsers;
	let options;
	if (args.length > 0 && args[args.length - 1] && typeof args[args.length - 1] === "object" && !("$valueType" in args[args.length - 1])) {
		options = args[args.length - 1];
		parsers = args.slice(0, -1);
	} else {
		parsers = args;
		options = void 0;
	}
	const noMatchContext = analyzeNoMatchContext(parsers);
	const combinedMode = parsers.some((p) => p.$mode === "async") ? "async" : "sync";
	const isAsync = combinedMode === "async";
	const syncParsers = parsers;
	const getInitialError = (context) => ({
		consumed: 0,
		error: context.buffer.length < 1 ? getNoMatchError(options, noMatchContext) : createUnexpectedInputError(context.buffer[0], context.usage, options)
	});
	const parseSync = (context) => {
		let bestMatch = null;
		let error = getInitialError(context);
		for (let i = 0; i < syncParsers.length; i++) {
			const parser = syncParsers[i];
			const result = parser.parse({
				...context,
				state: context.state == null || context.state[0] !== i || !context.state[1].success ? parser.initialState : context.state[1].next.state
			});
			if (result.success) {
				const consumed = context.buffer.length - result.next.buffer.length;
				if (bestMatch === null || consumed > bestMatch.consumed) bestMatch = {
					index: i,
					result,
					consumed
				};
			} else if (error.consumed < result.consumed) error = result;
		}
		if (bestMatch && bestMatch.result.success) return {
			success: true,
			next: {
				...context,
				buffer: bestMatch.result.next.buffer,
				optionsTerminated: bestMatch.result.next.optionsTerminated,
				state: [bestMatch.index, bestMatch.result]
			},
			consumed: bestMatch.result.consumed
		};
		return {
			...error,
			success: false
		};
	};
	const parseAsync = async (context) => {
		let bestMatch = null;
		let error = getInitialError(context);
		for (let i = 0; i < parsers.length; i++) {
			const parser = parsers[i];
			const resultOrPromise = parser.parse({
				...context,
				state: context.state == null || context.state[0] !== i || !context.state[1].success ? parser.initialState : context.state[1].next.state
			});
			const result = await resultOrPromise;
			if (result.success) {
				const consumed = context.buffer.length - result.next.buffer.length;
				if (bestMatch === null || consumed > bestMatch.consumed) bestMatch = {
					index: i,
					result,
					consumed
				};
			} else if (error.consumed < result.consumed) error = result;
		}
		if (bestMatch && bestMatch.result.success) return {
			success: true,
			next: {
				...context,
				buffer: bestMatch.result.next.buffer,
				optionsTerminated: bestMatch.result.next.optionsTerminated,
				state: [bestMatch.index, bestMatch.result]
			},
			consumed: bestMatch.result.consumed
		};
		return {
			...error,
			success: false
		};
	};
	return {
		$mode: combinedMode,
		$valueType: [],
		$stateType: [],
		priority: Math.max(...parsers.map((p) => p.priority)),
		usage: [{
			type: "exclusive",
			terms: parsers.map((p) => p.usage)
		}],
		initialState: void 0,
		complete: createExclusiveComplete(parsers, options, noMatchContext, isAsync),
		parse(context) {
			if (isAsync) return parseAsync(context);
			return parseSync(context);
		},
		suggest: createExclusiveSuggest(parsers, isAsync),
		getDocFragments(state, _defaultValue) {
			let description;
			let footer;
			let fragments;
			if (state.kind === "unavailable" || state.state == null) fragments = parsers.flatMap((p) => p.getDocFragments({ kind: "unavailable" }).fragments);
			else {
				const [i, result] = state.state;
				if (result.success) {
					const docResult = parsers[i].getDocFragments({
						kind: "available",
						state: result.next.state
					});
					description = docResult.description;
					footer = docResult.footer;
					fragments = docResult.fragments;
				} else fragments = parsers.flatMap((p) => p.getDocFragments({ kind: "unavailable" }).fragments);
			}
			return {
				description,
				fragments,
				footer
			};
		}
	};
}
/**
* Internal sync helper for object suggest functionality.
* @internal
*/
function* suggestObjectSync(context, prefix, parserPairs) {
	if (context.buffer.length > 0) {
		const lastToken = context.buffer[context.buffer.length - 1];
		for (const [field, parser] of parserPairs) if (isOptionRequiringValue(parser.usage, lastToken)) {
			const fieldState = context.state && typeof context.state === "object" && field in context.state ? context.state[field] : parser.initialState;
			yield* parser.suggest({
				...context,
				state: fieldState
			}, prefix);
			return;
		}
	}
	const suggestions = [];
	for (const [field, parser] of parserPairs) {
		const fieldState = context.state && typeof context.state === "object" && field in context.state ? context.state[field] : parser.initialState;
		const fieldSuggestions = parser.suggest({
			...context,
			state: fieldState
		}, prefix);
		suggestions.push(...fieldSuggestions);
	}
	yield* deduplicateSuggestions(suggestions);
}
/**
* Internal async helper for object suggest functionality.
* @internal
*/
async function* suggestObjectAsync(context, prefix, parserPairs) {
	if (context.buffer.length > 0) {
		const lastToken = context.buffer[context.buffer.length - 1];
		for (const [field, parser] of parserPairs) if (isOptionRequiringValue(parser.usage, lastToken)) {
			const fieldState = context.state && typeof context.state === "object" && field in context.state ? context.state[field] : parser.initialState;
			const suggestions$1 = parser.suggest({
				...context,
				state: fieldState
			}, prefix);
			for await (const s of suggestions$1) yield s;
			return;
		}
	}
	const suggestions = [];
	for (const [field, parser] of parserPairs) {
		const fieldState = context.state && typeof context.state === "object" && field in context.state ? context.state[field] : parser.initialState;
		const fieldSuggestions = parser.suggest({
			...context,
			state: fieldState
		}, prefix);
		for await (const s of fieldSuggestions) suggestions.push(s);
	}
	yield* deduplicateSuggestions(suggestions);
}
function object(labelOrParsers, maybeParsersOrOptions, maybeOptions) {
	const label = typeof labelOrParsers === "string" ? labelOrParsers : void 0;
	let parsers;
	let options = {};
	if (typeof labelOrParsers === "string") {
		parsers = maybeParsersOrOptions;
		options = maybeOptions ?? {};
	} else {
		parsers = labelOrParsers;
		options = maybeParsersOrOptions ?? {};
	}
	const parserKeys = Reflect.ownKeys(parsers);
	const parserPairs = parserKeys.map((k) => [k, parsers[k]]);
	parserPairs.sort(([_, parserA], [__, parserB]) => parserB.priority - parserA.priority);
	const initialState = {};
	for (const key of parserKeys) initialState[key] = parsers[key].initialState;
	if (!options.allowDuplicates) checkDuplicateOptionNames(parserPairs.map(([field, parser]) => [field, parser.usage]));
	const noMatchContext = analyzeNoMatchContext(parserKeys.map((k) => parsers[k]));
	const combinedMode = parserKeys.some((k) => parsers[k].$mode === "async") ? "async" : "sync";
	const isAsync = combinedMode === "async";
	const getInitialError = (context) => ({
		consumed: 0,
		error: context.buffer.length > 0 ? (() => {
			const token = context.buffer[0];
			const customMessage = options.errors?.unexpectedInput;
			if (customMessage) return typeof customMessage === "function" ? customMessage(token) : customMessage;
			const baseError = message`Unexpected option or argument: ${token}.`;
			return createErrorWithSuggestions(baseError, token, context.usage, "both", options.errors?.suggestions);
		})() : (() => {
			const customEndOfInput = options.errors?.endOfInput;
			return customEndOfInput ? typeof customEndOfInput === "function" ? customEndOfInput(noMatchContext) : customEndOfInput : generateNoMatchError(noMatchContext);
		})()
	});
	const parseSync = (context) => {
		let error = getInitialError(context);
		let currentContext = context;
		let anySuccess = false;
		const allConsumed = [];
		let madeProgress = true;
		while (madeProgress && currentContext.buffer.length > 0) {
			madeProgress = false;
			for (const [field, parser] of parserPairs) {
				const result = parser.parse({
					...currentContext,
					state: currentContext.state && typeof currentContext.state === "object" && field in currentContext.state ? currentContext.state[field] : parser.initialState
				});
				if (result.success && result.consumed.length > 0) {
					currentContext = {
						...currentContext,
						buffer: result.next.buffer,
						optionsTerminated: result.next.optionsTerminated,
						state: {
							...currentContext.state,
							[field]: result.next.state
						}
					};
					allConsumed.push(...result.consumed);
					anySuccess = true;
					madeProgress = true;
					break;
				} else if (!result.success && error.consumed < result.consumed) error = result;
			}
		}
		if (anySuccess) return {
			success: true,
			next: currentContext,
			consumed: allConsumed
		};
		if (context.buffer.length === 0) {
			let allCanComplete = true;
			for (const [field, parser] of parserPairs) {
				const fieldState = context.state && typeof context.state === "object" && field in context.state ? context.state[field] : parser.initialState;
				const completeResult = parser.complete(fieldState);
				if (!completeResult.success) {
					allCanComplete = false;
					break;
				}
			}
			if (allCanComplete) return {
				success: true,
				next: context,
				consumed: []
			};
		}
		return {
			...error,
			success: false
		};
	};
	const parseAsync = async (context) => {
		let error = getInitialError(context);
		let currentContext = context;
		let anySuccess = false;
		const allConsumed = [];
		let madeProgress = true;
		while (madeProgress && currentContext.buffer.length > 0) {
			madeProgress = false;
			for (const [field, parser] of parserPairs) {
				const resultOrPromise = parser.parse({
					...currentContext,
					state: currentContext.state && typeof currentContext.state === "object" && field in currentContext.state ? currentContext.state[field] : parser.initialState
				});
				const result = await resultOrPromise;
				if (result.success && result.consumed.length > 0) {
					currentContext = {
						...currentContext,
						buffer: result.next.buffer,
						optionsTerminated: result.next.optionsTerminated,
						state: {
							...currentContext.state,
							[field]: result.next.state
						}
					};
					allConsumed.push(...result.consumed);
					anySuccess = true;
					madeProgress = true;
					break;
				} else if (!result.success && error.consumed < result.consumed) error = result;
			}
		}
		if (anySuccess) return {
			success: true,
			next: currentContext,
			consumed: allConsumed
		};
		if (context.buffer.length === 0) {
			let allCanComplete = true;
			for (const [field, parser] of parserPairs) {
				const fieldState = context.state && typeof context.state === "object" && field in context.state ? context.state[field] : parser.initialState;
				const completeResult = await parser.complete(fieldState);
				if (!completeResult.success) {
					allCanComplete = false;
					break;
				}
			}
			if (allCanComplete) return {
				success: true,
				next: context,
				consumed: []
			};
		}
		return {
			...error,
			success: false
		};
	};
	return {
		$mode: combinedMode,
		$valueType: [],
		$stateType: [],
		priority: Math.max(...parserKeys.map((k) => parsers[k].priority)),
		usage: parserPairs.flatMap(([_, p]) => p.usage),
		initialState,
		parse(context) {
			if (isAsync) return parseAsync(context);
			return parseSync(context);
		},
		complete(state) {
			if (!isAsync) {
				const result = {};
				for (const field of parserKeys) {
					const valueResult = parsers[field].complete(state[field]);
					if (valueResult.success) result[field] = valueResult.value;
					else return {
						success: false,
						error: valueResult.error
					};
				}
				return {
					success: true,
					value: result
				};
			}
			return (async () => {
				const result = {};
				for (const field of parserKeys) {
					const valueResult = await parsers[field].complete(state[field]);
					if (valueResult.success) result[field] = valueResult.value;
					else return {
						success: false,
						error: valueResult.error
					};
				}
				return {
					success: true,
					value: result
				};
			})();
		},
		suggest(context, prefix) {
			if (isAsync) return suggestObjectAsync(context, prefix, parserPairs);
			const syncParserPairs = parserPairs;
			return suggestObjectSync(context, prefix, syncParserPairs);
		},
		getDocFragments(state, defaultValue) {
			const fragments = parserPairs.flatMap(([field, p]) => {
				const fieldState = state.kind === "unavailable" ? { kind: "unavailable" } : {
					kind: "available",
					state: state.state[field]
				};
				return p.getDocFragments(fieldState, defaultValue?.[field]).fragments;
			});
			const entries = fragments.filter((d) => d.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			const section = {
				title: label,
				entries
			};
			sections.push(section);
			return { fragments: sections.map((s) => ({
				...s,
				type: "section"
			})) };
		}
	};
}
function suggestTupleSync(context, prefix, parsers) {
	const suggestions = [];
	const stateArray = context.state;
	for (let i = 0; i < parsers.length; i++) {
		const parser = parsers[i];
		const parserState = stateArray && Array.isArray(stateArray) ? stateArray[i] : parser.initialState;
		const parserSuggestions = parser.suggest({
			...context,
			state: parserState
		}, prefix);
		suggestions.push(...parserSuggestions);
	}
	return deduplicateSuggestions(suggestions);
}
async function* suggestTupleAsync(context, prefix, parsers) {
	const suggestions = [];
	const stateArray = context.state;
	for (let i = 0; i < parsers.length; i++) {
		const parser = parsers[i];
		const parserState = stateArray && Array.isArray(stateArray) ? stateArray[i] : parser.initialState;
		const parserSuggestions = parser.suggest({
			...context,
			state: parserState
		}, prefix);
		if (parser.$mode === "async") for await (const s of parserSuggestions) suggestions.push(s);
		else suggestions.push(...parserSuggestions);
	}
	yield* deduplicateSuggestions(suggestions);
}
function tuple(labelOrParsers, maybeParsersOrOptions, maybeOptions) {
	const label = typeof labelOrParsers === "string" ? labelOrParsers : void 0;
	let parsers;
	let options = {};
	if (typeof labelOrParsers === "string") {
		parsers = maybeParsersOrOptions;
		options = maybeOptions ?? {};
	} else {
		parsers = labelOrParsers;
		options = maybeParsersOrOptions ?? {};
	}
	const combinedMode = parsers.some((p) => p.$mode === "async") ? "async" : "sync";
	const isAsync = combinedMode === "async";
	const syncParsers = parsers;
	if (!options.allowDuplicates) checkDuplicateOptionNames(parsers.map((parser, index) => [String(index), parser.usage]));
	const parseSync = (context) => {
		let currentContext = context;
		const allConsumed = [];
		const matchedParsers = /* @__PURE__ */ new Set();
		while (matchedParsers.size < syncParsers.length) {
			let foundMatch = false;
			let error = {
				consumed: 0,
				error: message`No remaining parsers could match the input.`
			};
			const stateArray = currentContext.state;
			const remainingParsers = syncParsers.map((parser, index) => [parser, index]).filter(([_, index]) => !matchedParsers.has(index)).sort(([parserA], [parserB]) => parserB.priority - parserA.priority);
			for (const [parser, index] of remainingParsers) {
				const result = parser.parse({
					...currentContext,
					state: stateArray[index]
				});
				if (result.success && result.consumed.length > 0) {
					const newStateArray = stateArray.map((s, idx) => idx === index ? result.next.state : s);
					currentContext = {
						...currentContext,
						buffer: result.next.buffer,
						optionsTerminated: result.next.optionsTerminated,
						state: newStateArray
					};
					allConsumed.push(...result.consumed);
					matchedParsers.add(index);
					foundMatch = true;
					break;
				} else if (!result.success && error.consumed < result.consumed) error = result;
			}
			if (!foundMatch) for (const [parser, index] of remainingParsers) {
				const result = parser.parse({
					...currentContext,
					state: stateArray[index]
				});
				if (result.success && result.consumed.length < 1) {
					const newStateArray = stateArray.map((s, idx) => idx === index ? result.next.state : s);
					currentContext = {
						...currentContext,
						state: newStateArray
					};
					matchedParsers.add(index);
					foundMatch = true;
					break;
				} else if (!result.success && result.consumed < 1) {
					matchedParsers.add(index);
					foundMatch = true;
					break;
				}
			}
			if (!foundMatch) return {
				...error,
				success: false
			};
		}
		return {
			success: true,
			next: currentContext,
			consumed: allConsumed
		};
	};
	const parseAsync = async (context) => {
		let currentContext = context;
		const allConsumed = [];
		const matchedParsers = /* @__PURE__ */ new Set();
		while (matchedParsers.size < parsers.length) {
			let foundMatch = false;
			let error = {
				consumed: 0,
				error: message`No remaining parsers could match the input.`
			};
			const stateArray = currentContext.state;
			const remainingParsers = parsers.map((parser, index) => [parser, index]).filter(([_, index]) => !matchedParsers.has(index)).sort(([parserA], [parserB]) => parserB.priority - parserA.priority);
			for (const [parser, index] of remainingParsers) {
				const resultOrPromise = parser.parse({
					...currentContext,
					state: stateArray[index]
				});
				const result = await resultOrPromise;
				if (result.success && result.consumed.length > 0) {
					const newStateArray = stateArray.map((s, idx) => idx === index ? result.next.state : s);
					currentContext = {
						...currentContext,
						buffer: result.next.buffer,
						optionsTerminated: result.next.optionsTerminated,
						state: newStateArray
					};
					allConsumed.push(...result.consumed);
					matchedParsers.add(index);
					foundMatch = true;
					break;
				} else if (!result.success && error.consumed < result.consumed) error = result;
			}
			if (!foundMatch) for (const [parser, index] of remainingParsers) {
				const resultOrPromise = parser.parse({
					...currentContext,
					state: stateArray[index]
				});
				const result = await resultOrPromise;
				if (result.success && result.consumed.length < 1) {
					const newStateArray = stateArray.map((s, idx) => idx === index ? result.next.state : s);
					currentContext = {
						...currentContext,
						state: newStateArray
					};
					matchedParsers.add(index);
					foundMatch = true;
					break;
				} else if (!result.success && result.consumed < 1) {
					matchedParsers.add(index);
					foundMatch = true;
					break;
				}
			}
			if (!foundMatch) return {
				...error,
				success: false
			};
		}
		return {
			success: true,
			next: currentContext,
			consumed: allConsumed
		};
	};
	return {
		$mode: combinedMode,
		$valueType: [],
		$stateType: [],
		usage: parsers.toSorted((a, b) => b.priority - a.priority).flatMap((p) => p.usage),
		priority: parsers.length > 0 ? Math.max(...parsers.map((p) => p.priority)) : 0,
		initialState: parsers.map((parser) => parser.initialState),
		parse(context) {
			if (isAsync) return parseAsync(context);
			return parseSync(context);
		},
		complete(state) {
			if (!isAsync) {
				const result = [];
				const stateArray = state;
				for (let i = 0; i < syncParsers.length; i++) {
					const valueResult = syncParsers[i].complete(stateArray[i]);
					if (valueResult.success) result[i] = valueResult.value;
					else return {
						success: false,
						error: valueResult.error
					};
				}
				return {
					success: true,
					value: result
				};
			}
			return (async () => {
				const result = [];
				const stateArray = state;
				for (let i = 0; i < parsers.length; i++) {
					const valueResult = await parsers[i].complete(stateArray[i]);
					if (valueResult.success) result[i] = valueResult.value;
					else return {
						success: false,
						error: valueResult.error
					};
				}
				return {
					success: true,
					value: result
				};
			})();
		},
		suggest(context, prefix) {
			if (isAsync) return suggestTupleAsync(context, prefix, parsers);
			return suggestTupleSync(context, prefix, syncParsers);
		},
		getDocFragments(state, defaultValue) {
			const fragments = syncParsers.flatMap((p, i) => {
				const indexState = state.kind === "unavailable" ? { kind: "unavailable" } : {
					kind: "available",
					state: state.state[i]
				};
				return p.getDocFragments(indexState, defaultValue?.[i]).fragments;
			});
			const entries = fragments.filter((d) => d.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			const section = {
				title: label,
				entries
			};
			sections.push(section);
			return { fragments: sections.map((s) => ({
				...s,
				type: "section"
			})) };
		},
		[Symbol.for("Deno.customInspect")]() {
			const parsersStr = parsers.length === 1 ? `[1 parser]` : `[${parsers.length} parsers]`;
			return label ? `tuple(${JSON.stringify(label)}, ${parsersStr})` : `tuple(${parsersStr})`;
		}
	};
}
function merge(...args) {
	const label = typeof args[0] === "string" ? args[0] : void 0;
	const lastArg = args[args.length - 1];
	const options = lastArg && typeof lastArg === "object" && !("parse" in lastArg) && !("complete" in lastArg) ? lastArg : {};
	const startIndex = typeof args[0] === "string" ? 1 : 0;
	const endIndex = lastArg && typeof lastArg === "object" && !("parse" in lastArg) && !("complete" in lastArg) ? args.length - 1 : args.length;
	const rawParsers = args.slice(startIndex, endIndex);
	const combinedMode = rawParsers.some((p) => p.$mode === "async") ? "async" : "sync";
	const isAsync = combinedMode === "async";
	const syncRawParsers = rawParsers;
	const withIndex = rawParsers.map((p, i) => [p, i]);
	const sorted = withIndex.toSorted(([a], [b]) => b.priority - a.priority);
	const parsers = sorted.map(([p]) => p);
	const syncWithIndex = syncRawParsers.map((p, i) => [p, i]);
	const syncSorted = syncWithIndex.toSorted(([a], [b]) => b.priority - a.priority);
	const syncParsers = syncSorted.map(([p]) => p);
	if (!options.allowDuplicates) checkDuplicateOptionNames(sorted.map(([parser, originalIndex]) => [String(originalIndex), parser.usage]));
	const initialState = {};
	for (const parser of parsers) if (parser.initialState && typeof parser.initialState === "object") for (const field in parser.initialState) initialState[field] = parser.initialState[field];
	const extractParserState = (parser, context, index) => {
		if (parser.initialState === void 0) {
			const key = `__parser_${index}`;
			if (context.state && typeof context.state === "object" && key in context.state) return context.state[key];
			return void 0;
		} else if (parser.initialState && typeof parser.initialState === "object") {
			if (context.state && typeof context.state === "object") {
				const extractedState = {};
				for (const field in parser.initialState) extractedState[field] = field in context.state ? context.state[field] : parser.initialState[field];
				return extractedState;
			}
			return parser.initialState;
		}
		return parser.initialState;
	};
	const mergeResultState = (parser, context, result, index) => {
		if (parser.initialState === void 0) {
			const key = `__parser_${index}`;
			if (result.success) {
				if (result.consumed.length > 0 || result.next.state !== void 0) return {
					...context.state,
					[key]: result.next.state
				};
			}
			return { ...context.state };
		}
		return result.success ? {
			...context.state,
			...result.next.state
		} : { ...context.state };
	};
	const parseSync = (context) => {
		let currentContext = context;
		let zeroConsumedSuccess = null;
		for (let i = 0; i < syncParsers.length; i++) {
			const parser = syncParsers[i];
			const parserState = extractParserState(parser, currentContext, i);
			const result = parser.parse({
				...currentContext,
				state: parserState
			});
			if (result.success) {
				const newState = mergeResultState(parser, currentContext, result, i);
				const newContext = {
					...currentContext,
					buffer: result.next.buffer,
					optionsTerminated: result.next.optionsTerminated,
					state: newState
				};
				if (result.consumed.length > 0) return {
					success: true,
					next: newContext,
					consumed: result.consumed
				};
				currentContext = newContext;
				if (zeroConsumedSuccess === null) zeroConsumedSuccess = {
					context: newContext,
					consumed: []
				};
				else zeroConsumedSuccess.context = newContext;
			} else if (result.consumed < 1) continue;
			else return result;
		}
		if (zeroConsumedSuccess !== null) return {
			success: true,
			next: zeroConsumedSuccess.context,
			consumed: zeroConsumedSuccess.consumed
		};
		return {
			success: false,
			consumed: 0,
			error: message`No matching option or argument found.`
		};
	};
	const parseAsync = async (context) => {
		let currentContext = context;
		let zeroConsumedSuccess = null;
		for (let i = 0; i < parsers.length; i++) {
			const parser = parsers[i];
			const parserState = extractParserState(parser, currentContext, i);
			const resultOrPromise = parser.parse({
				...currentContext,
				state: parserState
			});
			const result = await resultOrPromise;
			if (result.success) {
				const newState = mergeResultState(parser, currentContext, result, i);
				const newContext = {
					...currentContext,
					buffer: result.next.buffer,
					optionsTerminated: result.next.optionsTerminated,
					state: newState
				};
				if (result.consumed.length > 0) return {
					success: true,
					next: newContext,
					consumed: result.consumed
				};
				currentContext = newContext;
				if (zeroConsumedSuccess === null) zeroConsumedSuccess = {
					context: newContext,
					consumed: []
				};
				else zeroConsumedSuccess.context = newContext;
			} else if (result.consumed < 1) continue;
			else return result;
		}
		if (zeroConsumedSuccess !== null) return {
			success: true,
			next: zeroConsumedSuccess.context,
			consumed: zeroConsumedSuccess.consumed
		};
		return {
			success: false,
			consumed: 0,
			error: message`No matching option or argument found.`
		};
	};
	return {
		$mode: combinedMode,
		$valueType: [],
		$stateType: [],
		priority: Math.max(...parsers.map((p) => p.priority)),
		usage: parsers.flatMap((p) => p.usage),
		initialState,
		parse(context) {
			if (isAsync) return parseAsync(context);
			return parseSync(context);
		},
		complete(state) {
			const extractCompleteState = (parser, index) => {
				if (parser.initialState === void 0) {
					const key = `__parser_${index}`;
					if (state && typeof state === "object" && key in state) return state[key];
					return void 0;
				} else if (parser.initialState && typeof parser.initialState === "object") {
					if (state && typeof state === "object") {
						const extractedState = {};
						for (const field in parser.initialState) extractedState[field] = field in state ? state[field] : parser.initialState[field];
						return extractedState;
					}
					return parser.initialState;
				}
				return parser.initialState;
			};
			if (!isAsync) {
				const object$1 = {};
				for (let i = 0; i < syncParsers.length; i++) {
					const parser = syncParsers[i];
					const parserState = extractCompleteState(parser, i);
					const result = parser.complete(parserState);
					if (!result.success) return result;
					for (const field in result.value) object$1[field] = result.value[field];
				}
				return {
					success: true,
					value: object$1
				};
			}
			return (async () => {
				const object$1 = {};
				for (let i = 0; i < parsers.length; i++) {
					const parser = parsers[i];
					const parserState = extractCompleteState(parser, i);
					const result = await parser.complete(parserState);
					if (!result.success) return result;
					for (const field in result.value) object$1[field] = result.value[field];
				}
				return {
					success: true,
					value: object$1
				};
			})();
		},
		suggest(context, prefix) {
			const extractState = (p, i) => {
				if (p.initialState === void 0) {
					const key = `__parser_${i}`;
					if (context.state && typeof context.state === "object" && key in context.state) return context.state[key];
					return void 0;
				} else if (p.initialState && typeof p.initialState === "object") {
					if (context.state && typeof context.state === "object") {
						const extractedState = {};
						for (const field in p.initialState) extractedState[field] = field in context.state ? context.state[field] : p.initialState[field];
						return extractedState;
					}
					return p.initialState;
				}
				return p.initialState;
			};
			if (isAsync) return async function* () {
				const suggestions = [];
				for (let i = 0; i < parsers.length; i++) {
					const parser = parsers[i];
					const parserState = extractState(parser, i);
					const parserSuggestions = parser.suggest({
						...context,
						state: parserState
					}, prefix);
					if (parser.$mode === "async") for await (const s of parserSuggestions) suggestions.push(s);
					else suggestions.push(...parserSuggestions);
				}
				yield* deduplicateSuggestions(suggestions);
			}();
			return function* () {
				const suggestions = [];
				for (let i = 0; i < syncParsers.length; i++) {
					const parser = syncParsers[i];
					const parserState = extractState(parser, i);
					const parserSuggestions = parser.suggest({
						...context,
						state: parserState
					}, prefix);
					suggestions.push(...parserSuggestions);
				}
				yield* deduplicateSuggestions(suggestions);
			}();
		},
		getDocFragments(state, _defaultValue) {
			const fragments = parsers.flatMap((p, i) => {
				let parserState;
				if (p.initialState === void 0) {
					const key = `__parser_${i}`;
					if (state.kind === "available" && state.state && typeof state.state === "object" && key in state.state) parserState = {
						kind: "available",
						state: state.state[key]
					};
					else parserState = { kind: "unavailable" };
				} else parserState = state.kind === "unavailable" ? { kind: "unavailable" } : {
					kind: "available",
					state: state.state
				};
				return p.getDocFragments(parserState, void 0).fragments;
			});
			const entries = fragments.filter((f) => f.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			if (label) {
				const labeledSection = {
					title: label,
					entries
				};
				sections.push(labeledSection);
				return { fragments: sections.map((s) => ({
					...s,
					type: "section"
				})) };
			}
			return { fragments: [...sections.map((s) => ({
				...s,
				type: "section"
			})), {
				type: "section",
				entries
			}] };
		}
	};
}
function concat(...parsers) {
	const combinedMode = parsers.some((p) => p.$mode === "async") ? "async" : "sync";
	const isAsync = combinedMode === "async";
	const syncParsers = parsers;
	const initialState = parsers.map((parser) => parser.initialState);
	const parseSync = (context) => {
		let currentContext = context;
		const allConsumed = [];
		const matchedParsers = /* @__PURE__ */ new Set();
		while (matchedParsers.size < syncParsers.length) {
			let foundMatch = false;
			let error = {
				consumed: 0,
				error: message`No remaining parsers could match the input.`
			};
			const stateArray = currentContext.state;
			const remainingParsers = syncParsers.map((parser, index) => [parser, index]).filter(([_, index]) => !matchedParsers.has(index)).sort(([parserA], [parserB]) => parserB.priority - parserA.priority);
			for (const [parser, index] of remainingParsers) {
				const result = parser.parse({
					...currentContext,
					state: stateArray[index]
				});
				if (result.success && result.consumed.length > 0) {
					const newStateArray = stateArray.map((s, idx) => idx === index ? result.next.state : s);
					currentContext = {
						...currentContext,
						buffer: result.next.buffer,
						optionsTerminated: result.next.optionsTerminated,
						state: newStateArray
					};
					allConsumed.push(...result.consumed);
					matchedParsers.add(index);
					foundMatch = true;
					break;
				} else if (!result.success && error.consumed < result.consumed) error = result;
			}
			if (!foundMatch) for (const [parser, index] of remainingParsers) {
				const result = parser.parse({
					...currentContext,
					state: stateArray[index]
				});
				if (result.success && result.consumed.length < 1) {
					const newStateArray = stateArray.map((s, idx) => idx === index ? result.next.state : s);
					currentContext = {
						...currentContext,
						state: newStateArray
					};
					matchedParsers.add(index);
					foundMatch = true;
					break;
				} else if (!result.success && result.consumed < 1) {
					matchedParsers.add(index);
					foundMatch = true;
					break;
				}
			}
			if (!foundMatch) return {
				...error,
				success: false
			};
		}
		return {
			success: true,
			next: currentContext,
			consumed: allConsumed
		};
	};
	const parseAsync = async (context) => {
		let currentContext = context;
		const allConsumed = [];
		const matchedParsers = /* @__PURE__ */ new Set();
		while (matchedParsers.size < parsers.length) {
			let foundMatch = false;
			let error = {
				consumed: 0,
				error: message`No remaining parsers could match the input.`
			};
			const stateArray = currentContext.state;
			const remainingParsers = parsers.map((parser, index) => [parser, index]).filter(([_, index]) => !matchedParsers.has(index)).sort(([parserA], [parserB]) => parserB.priority - parserA.priority);
			for (const [parser, index] of remainingParsers) {
				const result = await parser.parse({
					...currentContext,
					state: stateArray[index]
				});
				if (result.success && result.consumed.length > 0) {
					const newStateArray = stateArray.map((s, idx) => idx === index ? result.next.state : s);
					currentContext = {
						...currentContext,
						buffer: result.next.buffer,
						optionsTerminated: result.next.optionsTerminated,
						state: newStateArray
					};
					allConsumed.push(...result.consumed);
					matchedParsers.add(index);
					foundMatch = true;
					break;
				} else if (!result.success && error.consumed < result.consumed) error = result;
			}
			if (!foundMatch) for (const [parser, index] of remainingParsers) {
				const result = await parser.parse({
					...currentContext,
					state: stateArray[index]
				});
				if (result.success && result.consumed.length < 1) {
					const newStateArray = stateArray.map((s, idx) => idx === index ? result.next.state : s);
					currentContext = {
						...currentContext,
						state: newStateArray
					};
					matchedParsers.add(index);
					foundMatch = true;
					break;
				} else if (!result.success && result.consumed < 1) {
					matchedParsers.add(index);
					foundMatch = true;
					break;
				}
			}
			if (!foundMatch) return {
				...error,
				success: false
			};
		}
		return {
			success: true,
			next: currentContext,
			consumed: allConsumed
		};
	};
	const completeSync = (state) => {
		const results = [];
		const stateArray = state;
		for (let i = 0; i < syncParsers.length; i++) {
			const parser = syncParsers[i];
			const parserState = stateArray[i];
			const result = parser.complete(parserState);
			if (!result.success) return result;
			if (Array.isArray(result.value)) results.push(...result.value);
			else results.push(result.value);
		}
		return {
			success: true,
			value: results
		};
	};
	const completeAsync = async (state) => {
		const results = [];
		const stateArray = state;
		for (let i = 0; i < parsers.length; i++) {
			const parser = parsers[i];
			const parserState = stateArray[i];
			const result = await parser.complete(parserState);
			if (!result.success) return result;
			if (Array.isArray(result.value)) results.push(...result.value);
			else results.push(result.value);
		}
		return {
			success: true,
			value: results
		};
	};
	return {
		$mode: combinedMode,
		$valueType: [],
		$stateType: [],
		priority: parsers.length > 0 ? Math.max(...parsers.map((p) => p.priority)) : 0,
		usage: parsers.flatMap((p) => p.usage),
		initialState,
		parse(context) {
			if (isAsync) return parseAsync(context);
			return parseSync(context);
		},
		complete(state) {
			if (isAsync) return completeAsync(state);
			return completeSync(state);
		},
		suggest(context, prefix) {
			const stateArray = context.state;
			if (isAsync) return async function* () {
				const suggestions = [];
				for (let i = 0; i < parsers.length; i++) {
					const parser = parsers[i];
					const parserState = stateArray && Array.isArray(stateArray) ? stateArray[i] : parser.initialState;
					const parserSuggestions = parser.suggest({
						...context,
						state: parserState
					}, prefix);
					if (parser.$mode === "async") for await (const s of parserSuggestions) suggestions.push(s);
					else suggestions.push(...parserSuggestions);
				}
				yield* deduplicateSuggestions(suggestions);
			}();
			return function* () {
				const suggestions = [];
				for (let i = 0; i < syncParsers.length; i++) {
					const parser = syncParsers[i];
					const parserState = stateArray && Array.isArray(stateArray) ? stateArray[i] : parser.initialState;
					const parserSuggestions = parser.suggest({
						...context,
						state: parserState
					}, prefix);
					suggestions.push(...parserSuggestions);
				}
				yield* deduplicateSuggestions(suggestions);
			}();
		},
		getDocFragments(state, _defaultValue) {
			const fragments = syncParsers.flatMap((p, index) => {
				const indexState = state.kind === "unavailable" ? { kind: "unavailable" } : {
					kind: "available",
					state: state.state[index]
				};
				return p.getDocFragments(indexState, void 0).fragments;
			});
			const entries = fragments.filter((f) => f.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			const result = [...sections.map((s) => ({
				...s,
				type: "section"
			}))];
			if (entries.length > 0) result.push({
				type: "section",
				entries
			});
			return { fragments: result };
		}
	};
}
/**
* Wraps a parser with a group label for documentation purposes.
*
* The `group()` function is a documentation-only wrapper that applies a label
* to any parser for help text organization. This allows you to use clean code
* structure with combinators like {@link merge} while maintaining well-organized
* help text through group labeling.
*
* The wrapped parser has identical parsing behavior but generates documentation
* fragments wrapped in a labeled section. This is particularly useful when
* combining parsers using {@link merge}you can wrap the merged result with
* `group()` to add a section header in help output.
*
* @example
* ```typescript
* const apiOptions = merge(
*   object({ endpoint: option("--endpoint", string()) }),
*   object({ timeout: option("--timeout", integer()) })
* );
*
* const groupedApiOptions = group("API Options", apiOptions);
* // Now produces a labeled "API Options" section in help text
* ```
*
* @example
* ```typescript
* // Can be used with any parser, not just merge()
* const verboseGroup = group("Verbosity", object({
*   verbose: option("-v", "--verbose"),
*   quiet: option("-q", "--quiet")
* }));
* ```
*
* @template TValue The value type of the wrapped parser.
* @template TState The state type of the wrapped parser.
* @param label A descriptive label for this parser group, used for
*              documentation and help text organization.
* @param parser The parser to wrap with a group label.
* @returns A new parser that behaves identically to the input parser
*          but generates documentation within a labeled section.
* @since 0.4.0
*/
function group(label, parser) {
	return {
		$mode: parser.$mode,
		$valueType: parser.$valueType,
		$stateType: parser.$stateType,
		priority: parser.priority,
		usage: parser.usage,
		initialState: parser.initialState,
		parse: (context) => parser.parse(context),
		complete: (state) => parser.complete(state),
		suggest: (context, prefix) => parser.suggest(context, prefix),
		getDocFragments: (state, defaultValue) => {
			const { description, fragments } = parser.getDocFragments(state, defaultValue);
			const allEntries = [];
			const titledSections = [];
			for (const fragment of fragments) if (fragment.type === "entry") allEntries.push(fragment);
			else if (fragment.type === "section") if (fragment.title) titledSections.push(fragment);
			else allEntries.push(...fragment.entries);
			const labeledSection = {
				title: label,
				entries: allEntries
			};
			return {
				description,
				fragments: [...titledSections.map((s) => ({
					...s,
					type: "section"
				})), {
					type: "section",
					...labeledSection
				}]
			};
		}
	};
}
/**
* Creates a conditional parser that selects different branch parsers based on
* a discriminator option value. This enables discriminated union patterns where
* certain options are only required or available when a specific discriminator
* value is selected.
*
* The result type is a tuple: `[discriminatorValue, branchResult]`
*
* @example
* ```typescript
* // Basic conditional parsing
* const parser = conditional(
*   option("--reporter", choice(["console", "junit"])),
*   {
*     console: object({}),
*     junit: object({ outputFile: option("--output-file", string()) }),
*   },
*   object({}) // default when --reporter is not provided
* );
*
* const result = parse(parser, ["--reporter", "junit", "--output-file", "out.xml"]);
* // result.value = ["junit", { outputFile: "out.xml" }]
*
* // Without --reporter, uses default branch:
* const defaultResult = parse(parser, []);
* // defaultResult.value = [undefined, {}]
* ```
*
* @since 0.8.0
*/
function conditional(discriminator, branches, defaultBranch, options) {
	const branchParsers = Object.entries(branches);
	const allBranchParsers = defaultBranch ? [...branchParsers.map(([_, p]) => p), defaultBranch] : branchParsers.map(([_, p]) => p);
	const combinedMode = discriminator.$mode === "async" || allBranchParsers.some((p) => p.$mode === "async") ? "async" : "sync";
	const isAsync = combinedMode === "async";
	const maxPriority = Math.max(discriminator.priority, ...allBranchParsers.map((p) => p.priority));
	function appendLiteralToUsage(usage$1, literalValue) {
		const result = [];
		for (const term of usage$1) if (term.type === "option" && term.metavar !== void 0) {
			const { metavar: _,...optionWithoutMetavar } = term;
			result.push(optionWithoutMetavar);
			result.push({
				type: "literal",
				value: literalValue
			});
		} else if (term.type === "optional") result.push({
			...term,
			terms: appendLiteralToUsage(term.terms, literalValue)
		});
		else if (term.type === "multiple") result.push({
			...term,
			terms: appendLiteralToUsage(term.terms, literalValue)
		});
		else if (term.type === "exclusive") result.push({
			...term,
			terms: term.terms.map((t) => appendLiteralToUsage(t, literalValue))
		});
		else result.push(term);
		return result;
	}
	const branchUsages = branchParsers.map(([key, p]) => [...appendLiteralToUsage(discriminator.usage, key), ...p.usage]);
	if (defaultBranch) branchUsages.push(defaultBranch.usage);
	const usage = branchUsages.length > 1 ? [{
		type: "exclusive",
		terms: branchUsages
	}] : branchUsages[0] ?? [];
	const initialState = {
		discriminatorState: discriminator.initialState,
		discriminatorValue: void 0,
		selectedBranch: void 0,
		branchState: void 0
	};
	const getNoMatchError$1 = () => {
		const noMatchContext = analyzeNoMatchContext([discriminator, ...allBranchParsers]);
		return options?.errors?.noMatch ? typeof options.errors.noMatch === "function" ? options.errors.noMatch(noMatchContext) : options.errors.noMatch : generateNoMatchError(noMatchContext);
	};
	const parseSync = (context) => {
		const state = context.state ?? initialState;
		const syncDiscriminator = discriminator;
		const syncBranches = branches;
		const syncDefaultBranch = defaultBranch;
		if (state.selectedBranch !== void 0) {
			const branchParser = state.selectedBranch.kind === "default" ? syncDefaultBranch : syncBranches[state.selectedBranch.key];
			const branchResult = branchParser.parse({
				...context,
				state: state.branchState,
				usage: branchParser.usage
			});
			if (branchResult.success) return {
				success: true,
				next: {
					...branchResult.next,
					state: {
						...state,
						branchState: branchResult.next.state
					}
				},
				consumed: branchResult.consumed
			};
			return branchResult;
		}
		const discriminatorResult = syncDiscriminator.parse({
			...context,
			state: state.discriminatorState
		});
		if (discriminatorResult.success && discriminatorResult.consumed.length > 0) {
			const completionResult = syncDiscriminator.complete(discriminatorResult.next.state);
			if (completionResult.success) {
				const value = completionResult.value;
				const branchParser = syncBranches[value];
				if (branchParser) {
					const branchParseResult = branchParser.parse({
						...context,
						buffer: discriminatorResult.next.buffer,
						optionsTerminated: discriminatorResult.next.optionsTerminated,
						state: branchParser.initialState,
						usage: branchParser.usage
					});
					if (branchParseResult.success) return {
						success: true,
						next: {
							...branchParseResult.next,
							state: {
								discriminatorState: discriminatorResult.next.state,
								discriminatorValue: value,
								selectedBranch: {
									kind: "branch",
									key: value
								},
								branchState: branchParseResult.next.state
							}
						},
						consumed: [...discriminatorResult.consumed, ...branchParseResult.consumed]
					};
					return {
						success: true,
						next: {
							...discriminatorResult.next,
							state: {
								discriminatorState: discriminatorResult.next.state,
								discriminatorValue: value,
								selectedBranch: {
									kind: "branch",
									key: value
								},
								branchState: branchParser.initialState
							}
						},
						consumed: discriminatorResult.consumed
					};
				}
			}
		}
		if (syncDefaultBranch !== void 0) {
			const defaultResult = syncDefaultBranch.parse({
				...context,
				state: state.branchState ?? syncDefaultBranch.initialState,
				usage: syncDefaultBranch.usage
			});
			if (defaultResult.success && defaultResult.consumed.length > 0) return {
				success: true,
				next: {
					...defaultResult.next,
					state: {
						...state,
						selectedBranch: { kind: "default" },
						branchState: defaultResult.next.state
					}
				},
				consumed: defaultResult.consumed
			};
		}
		return {
			success: false,
			consumed: 0,
			error: getNoMatchError$1()
		};
	};
	const parseAsync = async (context) => {
		const state = context.state ?? initialState;
		if (state.selectedBranch !== void 0) {
			const branchParser = state.selectedBranch.kind === "default" ? defaultBranch : branches[state.selectedBranch.key];
			const branchResult = await branchParser.parse({
				...context,
				state: state.branchState,
				usage: branchParser.usage
			});
			if (branchResult.success) return {
				success: true,
				next: {
					...branchResult.next,
					state: {
						...state,
						branchState: branchResult.next.state
					}
				},
				consumed: branchResult.consumed
			};
			return branchResult;
		}
		const discriminatorResult = await discriminator.parse({
			...context,
			state: state.discriminatorState
		});
		if (discriminatorResult.success && discriminatorResult.consumed.length > 0) {
			const completionResult = await discriminator.complete(discriminatorResult.next.state);
			if (completionResult.success) {
				const value = completionResult.value;
				const branchParser = branches[value];
				if (branchParser) {
					const branchParseResult = await branchParser.parse({
						...context,
						buffer: discriminatorResult.next.buffer,
						optionsTerminated: discriminatorResult.next.optionsTerminated,
						state: branchParser.initialState,
						usage: branchParser.usage
					});
					if (branchParseResult.success) return {
						success: true,
						next: {
							...branchParseResult.next,
							state: {
								discriminatorState: discriminatorResult.next.state,
								discriminatorValue: value,
								selectedBranch: {
									kind: "branch",
									key: value
								},
								branchState: branchParseResult.next.state
							}
						},
						consumed: [...discriminatorResult.consumed, ...branchParseResult.consumed]
					};
					return {
						success: true,
						next: {
							...discriminatorResult.next,
							state: {
								discriminatorState: discriminatorResult.next.state,
								discriminatorValue: value,
								selectedBranch: {
									kind: "branch",
									key: value
								},
								branchState: branchParser.initialState
							}
						},
						consumed: discriminatorResult.consumed
					};
				}
			}
		}
		if (defaultBranch !== void 0) {
			const defaultResult = await defaultBranch.parse({
				...context,
				state: state.branchState ?? defaultBranch.initialState,
				usage: defaultBranch.usage
			});
			if (defaultResult.success && defaultResult.consumed.length > 0) return {
				success: true,
				next: {
					...defaultResult.next,
					state: {
						...state,
						selectedBranch: { kind: "default" },
						branchState: defaultResult.next.state
					}
				},
				consumed: defaultResult.consumed
			};
		}
		return {
			success: false,
			consumed: 0,
			error: getNoMatchError$1()
		};
	};
	const completeSync = (state) => {
		const syncDefaultBranch = defaultBranch;
		const syncBranches = branches;
		if (state.selectedBranch === void 0) {
			if (syncDefaultBranch !== void 0) {
				const branchState = state.branchState ?? syncDefaultBranch.initialState;
				const defaultResult = syncDefaultBranch.complete(branchState);
				if (!defaultResult.success) return defaultResult;
				return {
					success: true,
					value: [void 0, defaultResult.value]
				};
			}
			return {
				success: false,
				error: message`Missing required discriminator option.`
			};
		}
		const branchParser = state.selectedBranch.kind === "default" ? syncDefaultBranch : syncBranches[state.selectedBranch.key];
		const branchResult = branchParser.complete(state.branchState);
		if (!branchResult.success) {
			if (state.discriminatorValue !== void 0 && options?.errors?.branchError) return {
				success: false,
				error: options.errors.branchError(state.discriminatorValue, branchResult.error)
			};
			return branchResult;
		}
		const discriminatorValue = state.selectedBranch.kind === "default" ? void 0 : state.selectedBranch.key;
		return {
			success: true,
			value: [discriminatorValue, branchResult.value]
		};
	};
	const completeAsync = async (state) => {
		if (state.selectedBranch === void 0) {
			if (defaultBranch !== void 0) {
				const branchState = state.branchState ?? defaultBranch.initialState;
				const defaultResult = await defaultBranch.complete(branchState);
				if (!defaultResult.success) return defaultResult;
				return {
					success: true,
					value: [void 0, defaultResult.value]
				};
			}
			return {
				success: false,
				error: message`Missing required discriminator option.`
			};
		}
		const branchParser = state.selectedBranch.kind === "default" ? defaultBranch : branches[state.selectedBranch.key];
		const branchResult = await branchParser.complete(state.branchState);
		if (!branchResult.success) {
			if (state.discriminatorValue !== void 0 && options?.errors?.branchError) return {
				success: false,
				error: options.errors.branchError(state.discriminatorValue, branchResult.error)
			};
			return branchResult;
		}
		const discriminatorValue = state.selectedBranch.kind === "default" ? void 0 : state.selectedBranch.key;
		return {
			success: true,
			value: [discriminatorValue, branchResult.value]
		};
	};
	function* suggestSync(context, prefix) {
		const state = context.state ?? initialState;
		const syncDiscriminator = discriminator;
		const syncBranches = branches;
		const syncDefaultBranch = defaultBranch;
		if (state.selectedBranch === void 0) {
			yield* syncDiscriminator.suggest({
				...context,
				state: state.discriminatorState
			}, prefix);
			if (syncDefaultBranch !== void 0) yield* syncDefaultBranch.suggest({
				...context,
				state: state.branchState ?? syncDefaultBranch.initialState
			}, prefix);
		} else {
			const branchParser = state.selectedBranch.kind === "default" ? syncDefaultBranch : syncBranches[state.selectedBranch.key];
			yield* branchParser.suggest({
				...context,
				state: state.branchState
			}, prefix);
		}
	}
	async function* suggestAsync(context, prefix) {
		const state = context.state ?? initialState;
		if (state.selectedBranch === void 0) {
			yield* discriminator.suggest({
				...context,
				state: state.discriminatorState
			}, prefix);
			if (defaultBranch !== void 0) yield* defaultBranch.suggest({
				...context,
				state: state.branchState ?? defaultBranch.initialState
			}, prefix);
		} else {
			const branchParser = state.selectedBranch.kind === "default" ? defaultBranch : branches[state.selectedBranch.key];
			yield* branchParser.suggest({
				...context,
				state: state.branchState
			}, prefix);
		}
	}
	return {
		$mode: combinedMode,
		$valueType: [],
		$stateType: [],
		priority: maxPriority,
		usage,
		initialState,
		parse(context) {
			if (isAsync) return parseAsync(context);
			return parseSync(context);
		},
		complete(state) {
			if (isAsync) return completeAsync(state);
			return completeSync(state);
		},
		suggest(context, prefix) {
			if (isAsync) return suggestAsync(context, prefix);
			return suggestSync(context, prefix);
		},
		getDocFragments(_state, _defaultValue) {
			const fragments = [];
			const discriminatorFragments = discriminator.getDocFragments({ kind: "unavailable" }, void 0);
			fragments.push(...discriminatorFragments.fragments);
			for (const [key, branchParser] of branchParsers) {
				const branchFragments = branchParser.getDocFragments({ kind: "unavailable" }, void 0);
				const entries = branchFragments.fragments.filter((f) => f.type === "entry");
				for (const fragment of branchFragments.fragments) if (fragment.type === "section") entries.push(...fragment.entries);
				if (entries.length > 0) fragments.push({
					type: "section",
					title: `Options when ${key}`,
					entries
				});
			}
			if (defaultBranch !== void 0) {
				const defaultFragments = defaultBranch.getDocFragments({ kind: "unavailable" }, void 0);
				const entries = defaultFragments.fragments.filter((f) => f.type === "entry");
				for (const fragment of defaultFragments.fragments) if (fragment.type === "section") entries.push(...fragment.entries);
				if (entries.length > 0) fragments.push({
					type: "section",
					title: "Default options",
					entries
				});
			}
			return { fragments };
		}
	};
}

//#endregion
export { DuplicateOptionError, concat, conditional, group, longestMatch, merge, object, or, tuple };