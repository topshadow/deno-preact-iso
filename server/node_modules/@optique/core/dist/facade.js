import { commandLine, formatMessage, message, optionName, text, value } from "./message.js";
import { formatUsage } from "./usage.js";
import { longestMatch, object } from "./constructs.js";
import { formatDocPage } from "./doc.js";
import { bash, fish, nu, pwsh, zsh } from "./completion.js";
import { multiple, optional, withDefault } from "./modifiers.js";
import { string } from "./valueparser.js";
import { argument, command, constant, flag, option } from "./primitives.js";
import { getDocPage, parseAsync, parseSync, suggest, suggestAsync } from "./parser.js";

//#region src/facade.ts
/**
* Creates help parsers based on the specified mode.
*/
function createHelpParser(mode) {
	const helpCommand = command("help", multiple(argument(string({ metavar: "COMMAND" }), { description: message`Command name to show help for.` })), { description: message`Show help information.` });
	const helpOption = flag("--help", { description: message`Show help information.` });
	switch (mode) {
		case "command": return {
			helpCommand,
			helpOption: null
		};
		case "option": return {
			helpCommand: null,
			helpOption
		};
		case "both": return {
			helpCommand,
			helpOption
		};
	}
}
/**
* Creates version parsers based on the specified mode.
*/
function createVersionParser(mode) {
	const versionCommand = command("version", object({}), { description: message`Show version information.` });
	const versionOption = flag("--version", { description: message`Show version information.` });
	switch (mode) {
		case "command": return {
			versionCommand,
			versionOption: null
		};
		case "option": return {
			versionCommand: null,
			versionOption
		};
		case "both": return {
			versionCommand,
			versionOption
		};
	}
}
/**
* Creates completion parsers based on the specified mode.
*/
function createCompletionParser(mode, programName, availableShells, name = "both") {
	const shellList = [];
	for (const shell in availableShells) {
		if (shellList.length > 0) shellList.push(text(", "));
		shellList.push(value(shell));
	}
	const completionInner = object({
		shell: optional(argument(string({ metavar: "SHELL" }), { description: message`Shell type (${shellList}). Generate completion script when used alone, or provide completions when followed by arguments.` })),
		args: multiple(argument(string({ metavar: "ARG" }), { description: message`Command line arguments for completion suggestions (used by shell integration; you usually don't need to provide this).` }))
	});
	const commandName = name === "plural" ? "completions" : "completion";
	const completionCommandConfig = {
		brief: message`Generate shell completion script or provide completions.`,
		description: message`Generate shell completion script or provide completions.`,
		footer: message`Examples:
  Bash:       ${commandLine(`eval "$(${programName} ${commandName} bash)"`)}
  zsh:        ${commandLine(`eval "$(${programName} ${commandName} zsh)"`)}
  fish:       ${commandLine(`eval "$(${programName} ${commandName} fish)"`)}
  PowerShell: ${commandLine(`${programName} ${commandName} pwsh > ${programName}-completion.ps1; . ./${programName}-completion.ps1`)}
  Nushell:    ${commandLine(`${programName} ${commandName} nu | save ${programName}-completion.nu; source ./${programName}-completion.nu`)}
`
	};
	const completionCommands = [];
	if (name === "singular" || name === "both") completionCommands.push(command("completion", completionInner, completionCommandConfig));
	if (name === "plural" || name === "both") completionCommands.push(command("completions", completionInner, completionCommandConfig));
	const completionCommand = longestMatch(...completionCommands);
	const completionOptionNames = [];
	if (name === "singular" || name === "both") completionOptionNames.push("--completion");
	if (name === "plural" || name === "both") completionOptionNames.push("--completions");
	const completionOptionArgs = [
		...completionOptionNames,
		string({ metavar: "SHELL" }),
		{ description: message`Generate shell completion script.` }
	];
	const completionOption = option(...completionOptionArgs);
	const argsParser = withDefault(multiple(argument(string({ metavar: "ARG" }), { description: message`Command line arguments for completion suggestions (used by shell integration; you usually don't need to provide this).` })), []);
	const optionParser = object({
		shell: completionOption,
		args: argsParser
	});
	switch (mode) {
		case "command": return {
			completionCommand,
			completionOption: null
		};
		case "option": return {
			completionCommand: null,
			completionOption: optionParser
		};
		case "both": return {
			completionCommand,
			completionOption: optionParser
		};
	}
}
/**
* Systematically combines the original parser with help, version, and completion parsers.
*/
function combineWithHelpVersion(originalParser, helpParsers, versionParsers, completionParsers) {
	const parsers = [];
	if (helpParsers.helpOption) {
		const lenientHelpParser = {
			$mode: "sync",
			$valueType: [],
			$stateType: [],
			priority: 200,
			usage: helpParsers.helpOption.usage,
			initialState: null,
			parse(context) {
				const { buffer, optionsTerminated } = context;
				if (optionsTerminated) return {
					success: false,
					error: message`Options terminated.`,
					consumed: 0
				};
				let helpFound = false;
				let helpIndex = -1;
				let versionIndex = -1;
				for (let i = 0; i < buffer.length; i++) {
					if (buffer[i] === "--") break;
					if (buffer[i] === "--help") {
						helpFound = true;
						helpIndex = i;
					}
					if (buffer[i] === "--version") versionIndex = i;
				}
				if (helpFound && versionIndex > helpIndex) return {
					success: false,
					error: message`Version option wins.`,
					consumed: 0
				};
				if (helpFound) {
					const commands = [];
					for (let i = 0; i < helpIndex; i++) {
						const arg = buffer[i];
						if (!arg.startsWith("-")) commands.push(arg);
					}
					return {
						success: true,
						next: {
							...context,
							buffer: [],
							state: {
								help: true,
								version: false,
								commands,
								helpFlag: true
							}
						},
						consumed: buffer.slice(0)
					};
				}
				return {
					success: false,
					error: message`Flag ${optionName("--help")} not found.`,
					consumed: 0
				};
			},
			complete(state) {
				return {
					success: true,
					value: state
				};
			},
			*suggest(_context, prefix) {
				if ("--help".startsWith(prefix)) yield {
					kind: "literal",
					text: "--help"
				};
			},
			getDocFragments(state) {
				return helpParsers.helpOption?.getDocFragments(state) ?? { fragments: [] };
			}
		};
		parsers.push(lenientHelpParser);
	}
	if (versionParsers.versionOption) {
		const lenientVersionParser = {
			$mode: "sync",
			$valueType: [],
			$stateType: [],
			priority: 200,
			usage: versionParsers.versionOption.usage,
			initialState: null,
			parse(context) {
				const { buffer, optionsTerminated } = context;
				if (optionsTerminated) return {
					success: false,
					error: message`Options terminated.`,
					consumed: 0
				};
				let versionFound = false;
				let versionIndex = -1;
				let helpIndex = -1;
				for (let i = 0; i < buffer.length; i++) {
					if (buffer[i] === "--") break;
					if (buffer[i] === "--version") {
						versionFound = true;
						versionIndex = i;
					}
					if (buffer[i] === "--help") helpIndex = i;
				}
				if (versionFound && helpIndex > versionIndex) return {
					success: false,
					error: message`Help option wins.`,
					consumed: 0
				};
				if (versionFound) return {
					success: true,
					next: {
						...context,
						buffer: [],
						state: {
							help: false,
							version: true,
							versionFlag: true
						}
					},
					consumed: buffer.slice(0)
				};
				return {
					success: false,
					error: message`Flag ${optionName("--version")} not found.`,
					consumed: 0
				};
			},
			complete(state) {
				return {
					success: true,
					value: state
				};
			},
			*suggest(_context, prefix) {
				if ("--version".startsWith(prefix)) yield {
					kind: "literal",
					text: "--version"
				};
			},
			getDocFragments(state) {
				return versionParsers.versionOption?.getDocFragments(state) ?? { fragments: [] };
			}
		};
		parsers.push(lenientVersionParser);
	}
	if (versionParsers.versionCommand) parsers.push(object({
		help: constant(false),
		version: constant(true),
		completion: constant(false),
		result: versionParsers.versionCommand,
		helpFlag: helpParsers.helpOption ? optional(helpParsers.helpOption) : constant(false)
	}));
	if (completionParsers.completionCommand) parsers.push(object({
		help: constant(false),
		version: constant(false),
		completion: constant(true),
		completionData: completionParsers.completionCommand,
		helpFlag: helpParsers.helpOption ? optional(helpParsers.helpOption) : constant(false)
	}));
	if (helpParsers.helpCommand) parsers.push(object({
		help: constant(true),
		version: constant(false),
		completion: constant(false),
		commands: helpParsers.helpCommand
	}));
	parsers.push(object({
		help: constant(false),
		version: constant(false),
		completion: constant(false),
		result: originalParser
	}));
	if (parsers.length === 1) return parsers[0];
	else if (parsers.length === 2) return longestMatch(parsers[0], parsers[1]);
	else return longestMatch(...parsers);
}
/**
* Classifies the parsing result into a discriminated union for cleaner handling.
*/
function classifyResult(result, args) {
	if (!result.success) return {
		type: "error",
		error: result.error
	};
	const value$1 = result.value;
	if (typeof value$1 === "object" && value$1 != null && "help" in value$1 && "version" in value$1) {
		const parsedValue = value$1;
		const hasVersionOption = args.includes("--version");
		const hasVersionCommand = args.length > 0 && args[0] === "version";
		const hasHelpOption = args.includes("--help");
		const hasHelpCommand = args.length > 0 && args[0] === "help";
		const hasCompletionCommand = args.length > 0 && args[0] === "completion";
		if (hasVersionOption && hasHelpOption && !hasVersionCommand && !hasHelpCommand) {}
		if (hasVersionCommand && hasHelpOption && parsedValue.helpFlag) return {
			type: "help",
			commands: ["version"]
		};
		if (hasCompletionCommand && hasHelpOption && parsedValue.helpFlag) return {
			type: "help",
			commands: ["completion"]
		};
		if (parsedValue.help && (hasHelpOption || hasHelpCommand)) {
			let commandContext = [];
			if (Array.isArray(parsedValue.commands)) commandContext = parsedValue.commands;
			else if (typeof parsedValue.commands === "object" && parsedValue.commands != null && "length" in parsedValue.commands) commandContext = parsedValue.commands;
			return {
				type: "help",
				commands: commandContext
			};
		}
		if ((hasVersionOption || hasVersionCommand) && (parsedValue.version || parsedValue.versionFlag)) return { type: "version" };
		if (parsedValue.completion && parsedValue.completionData) return {
			type: "completion",
			shell: parsedValue.completionData.shell || "",
			args: parsedValue.completionData.args || []
		};
		return {
			type: "success",
			value: parsedValue.result ?? value$1
		};
	}
	return {
		type: "success",
		value: value$1
	};
}
/**
* Handles shell completion requests.
* @since 0.6.0
*/
function handleCompletion(completionArgs, programName, parser, completionParser, stdout, stderr, onCompletion, onError, availableShells, colors, maxWidth, completionMode, completionName) {
	const shellName = completionArgs[0] || "";
	const args = completionArgs.slice(1);
	const callOnError = (code) => {
		try {
			return onError(code);
		} catch {
			return onError();
		}
	};
	const callOnCompletion = (code) => {
		try {
			return onCompletion(code);
		} catch {
			return onCompletion();
		}
	};
	if (!shellName) {
		stderr("Error: Missing shell name for completion.\n");
		if (completionParser) {
			const doc = getDocPage(completionParser, ["completion"]);
			if (doc) stderr(formatDocPage(programName, doc, {
				colors,
				maxWidth
			}));
		}
		if (parser.$mode === "async") return Promise.resolve(callOnError(1));
		return callOnError(1);
	}
	const shell = availableShells[shellName];
	if (!shell) {
		const available = [];
		for (const name in availableShells) {
			if (available.length > 0) available.push(text(", "));
			available.push(value(name));
		}
		stderr(formatMessage(message`Error: Unsupported shell ${shellName}. Available shells: ${available}.`, {
			colors,
			quotes: !colors
		}));
		if (parser.$mode === "async") return Promise.resolve(callOnError(1));
		return callOnError(1);
	}
	if (args.length === 0) {
		const usePlural = completionName === "plural";
		const completionArg = completionMode === "option" ? usePlural ? "--completions" : "--completion" : usePlural ? "completions" : "completion";
		const script = shell.generateScript(programName, [completionArg, shellName]);
		stdout(script);
		if (parser.$mode === "async") return Promise.resolve(callOnCompletion(0));
		return callOnCompletion(0);
	}
	if (parser.$mode === "async") return (async () => {
		const suggestions$1 = await suggestAsync(parser, args);
		for (const chunk of shell.encodeSuggestions(suggestions$1)) stdout(chunk);
		return callOnCompletion(0);
	})();
	const syncParser = parser;
	const suggestions = suggest(syncParser, args);
	for (const chunk of shell.encodeSuggestions(suggestions)) stdout(chunk);
	return callOnCompletion(0);
}
function runParser(parser, programName, args, options = {}) {
	const { colors, maxWidth, showDefault, aboveError = "usage", onError = () => {
		throw new RunParserError("Failed to parse command line arguments.");
	}, stderr = console.error, stdout = console.log, brief, description, footer } = options;
	const helpMode = options.help?.mode ?? "option";
	const onHelp = options.help?.onShow ?? (() => ({}));
	const versionMode = options.version?.mode ?? "option";
	const versionValue = options.version?.value ?? "";
	const onVersion = options.version?.onShow ?? (() => ({}));
	const completionMode = options.completion?.mode ?? "both";
	const completionName = options.completion?.name ?? "both";
	const onCompletion = options.completion?.onShow ?? (() => ({}));
	const defaultShells = {
		bash,
		fish,
		nu,
		pwsh,
		zsh
	};
	const availableShells = options.completion?.shells ? {
		...defaultShells,
		...options.completion.shells
	} : defaultShells;
	const help = options.help ? helpMode : "none";
	const version = options.version ? versionMode : "none";
	const completion = options.completion ? completionMode : "none";
	const helpParsers = help === "none" ? {
		helpCommand: null,
		helpOption: null
	} : createHelpParser(help);
	const versionParsers = version === "none" ? {
		versionCommand: null,
		versionOption: null
	} : createVersionParser(version);
	const completionParsers = completion === "none" ? {
		completionCommand: null,
		completionOption: null
	} : createCompletionParser(completion, programName, availableShells, completionName);
	if (options.completion) {
		const hasHelpOption = args.includes("--help");
		if ((completionMode === "command" || completionMode === "both") && args.length >= 1 && ((completionName === "singular" || completionName === "both" ? args[0] === "completion" : false) || (completionName === "plural" || completionName === "both" ? args[0] === "completions" : false)) && !hasHelpOption) return handleCompletion(args.slice(1), programName, parser, completionParsers.completionCommand, stdout, stderr, onCompletion, onError, availableShells, colors, maxWidth, completionMode, completionName);
		if (completionMode === "option" || completionMode === "both") for (let i = 0; i < args.length; i++) {
			const arg = args[i];
			const singularMatch = completionName === "singular" || completionName === "both" ? arg.startsWith("--completion=") : false;
			const pluralMatch = completionName === "plural" || completionName === "both" ? arg.startsWith("--completions=") : false;
			if (singularMatch || pluralMatch) {
				const shell = arg.slice(arg.indexOf("=") + 1);
				const completionArgs = args.slice(i + 1);
				return handleCompletion([shell, ...completionArgs], programName, parser, completionParsers.completionCommand, stdout, stderr, onCompletion, onError, availableShells, colors, maxWidth, completionMode, completionName);
			} else {
				const singularMatchExact = completionName === "singular" || completionName === "both" ? arg === "--completion" : false;
				const pluralMatchExact = completionName === "plural" || completionName === "both" ? arg === "--completions" : false;
				if ((singularMatchExact || pluralMatchExact) && i + 1 < args.length) {
					const shell = args[i + 1];
					const completionArgs = args.slice(i + 2);
					return handleCompletion([shell, ...completionArgs], programName, parser, completionParsers.completionCommand, stdout, stderr, onCompletion, onError, availableShells, colors, maxWidth, completionMode, completionName);
				}
			}
		}
	}
	const augmentedParser = help === "none" && version === "none" && completion === "none" ? parser : combineWithHelpVersion(parser, helpParsers, versionParsers, completionParsers);
	const handleResult = (result) => {
		const classified = classifyResult(result, args);
		switch (classified.type) {
			case "success": return classified.value;
			case "version":
				stdout(versionValue);
				try {
					return onVersion(0);
				} catch {
					return onVersion();
				}
			case "completion": throw new RunParserError("Completion should be handled by early return");
			case "help": {
				let helpGeneratorParser;
				const helpAsCommand = help === "command" || help === "both";
				const versionAsCommand = version === "command" || version === "both";
				const completionAsCommand = completion === "command" || completion === "both";
				const requestedCommand = classified.commands[0];
				if ((requestedCommand === "completion" || requestedCommand === "completions") && completionAsCommand && completionParsers.completionCommand) helpGeneratorParser = completionParsers.completionCommand;
				else if (requestedCommand === "help" && helpAsCommand && helpParsers.helpCommand) helpGeneratorParser = helpParsers.helpCommand;
				else if (requestedCommand === "version" && versionAsCommand && versionParsers.versionCommand) helpGeneratorParser = versionParsers.versionCommand;
				else {
					const commandParsers = [parser];
					if (helpAsCommand) {
						if (helpParsers.helpCommand) commandParsers.push(helpParsers.helpCommand);
					}
					if (versionAsCommand) {
						if (versionParsers.versionCommand) commandParsers.push(versionParsers.versionCommand);
					}
					if (completionAsCommand) {
						if (completionParsers.completionCommand) commandParsers.push(completionParsers.completionCommand);
					}
					if (commandParsers.length === 1) helpGeneratorParser = commandParsers[0];
					else if (commandParsers.length === 2) helpGeneratorParser = longestMatch(commandParsers[0], commandParsers[1]);
					else helpGeneratorParser = longestMatch(...commandParsers);
				}
				const displayHelp = (doc) => {
					if (doc != null) {
						const isMetaCommandHelp = (completionName === "singular" || completionName === "both" ? requestedCommand === "completion" : false) || (completionName === "plural" || completionName === "both" ? requestedCommand === "completions" : false) || requestedCommand === "help" || requestedCommand === "version";
						const augmentedDoc = {
							...doc,
							brief: !isMetaCommandHelp ? brief ?? doc.brief : doc.brief,
							description: !isMetaCommandHelp ? description ?? doc.description : doc.description,
							footer: !isMetaCommandHelp ? footer ?? doc.footer : doc.footer
						};
						stdout(formatDocPage(programName, augmentedDoc, {
							colors,
							maxWidth,
							showDefault
						}));
					}
					try {
						return onHelp(0);
					} catch {
						return onHelp();
					}
				};
				const docOrPromise = getDocPage(helpGeneratorParser, classified.commands);
				if (docOrPromise instanceof Promise) return docOrPromise.then(displayHelp);
				return displayHelp(docOrPromise);
			}
			case "error": {
				const displayError = (doc, currentAboveError) => {
					let effectiveAboveError = currentAboveError;
					if (effectiveAboveError === "help") if (doc == null) effectiveAboveError = "usage";
					else {
						const augmentedDoc = {
							...doc,
							brief: brief ?? doc.brief,
							description: description ?? doc.description,
							footer: footer ?? doc.footer
						};
						stderr(formatDocPage(programName, augmentedDoc, {
							colors,
							maxWidth,
							showDefault
						}));
					}
					if (effectiveAboveError === "usage") stderr(`Usage: ${indentLines(formatUsage(programName, augmentedParser.usage, {
						colors,
						maxWidth: maxWidth == null ? void 0 : maxWidth - 7,
						expandCommands: true
					}), 7)}`);
					const errorMessage = formatMessage(classified.error, {
						colors,
						quotes: !colors
					});
					stderr(`Error: ${errorMessage}`);
					return onError(1);
				};
				if (aboveError === "help") {
					const parserForDoc = args.length < 1 ? augmentedParser : parser;
					const docOrPromise = getDocPage(parserForDoc, args);
					if (docOrPromise instanceof Promise) return docOrPromise.then((doc) => displayError(doc, aboveError));
					return displayError(docOrPromise, aboveError);
				}
				return displayError(void 0, aboveError);
			}
			default: throw new RunParserError("Unexpected parse result type");
		}
	};
	if (parser.$mode === "async") return parseAsync(augmentedParser, args).then(handleResult);
	else {
		const result = parseSync(augmentedParser, args);
		return handleResult(result);
	}
}
/**
* Runs a synchronous command-line parser with the given options.
*
* This is a type-safe version of {@link runParser} that only accepts sync
* parsers. Use this when you know your parser is sync-only to get direct
* return values without Promise wrappers.
*
* @template TParser The sync parser type being executed.
* @template THelp The return type of the onHelp callback.
* @template TError The return type of the onError callback.
* @param parser The synchronous command-line parser to execute.
* @param programName The name of the program for help messages.
* @param args The command-line arguments to parse.
* @param options Configuration options for customizing behavior.
* @returns The parsed result if successful.
* @since 0.9.0
*/
function runParserSync(parser, programName, args, options) {
	return runParser(parser, programName, args, options);
}
/**
* Runs any command-line parser asynchronously with the given options.
*
* This function accepts parsers of any mode (sync or async) and always
* returns a Promise. Use this when working with parsers that may contain
* async value parsers.
*
* @template TParser The parser type being executed.
* @template THelp The return type of the onHelp callback.
* @template TError The return type of the onError callback.
* @param parser The command-line parser to execute.
* @param programName The name of the program for help messages.
* @param args The command-line arguments to parse.
* @param options Configuration options for customizing behavior.
* @returns A Promise of the parsed result if successful.
* @since 0.9.0
*/
function runParserAsync(parser, programName, args, options) {
	const result = runParser(parser, programName, args, options);
	return Promise.resolve(result);
}
/**
* @deprecated Use `runParser()` instead. This export will be removed in
*             a future major version. The name `run` conflicts with
*             `@optique/run`'s `run()` function, causing IDE autocomplete
*             confusion.
*/
const run = runParser;
/**
* An error class used to indicate that the command line arguments
* could not be parsed successfully.
*/
var RunParserError = class extends Error {
	constructor(message$1) {
		super(message$1);
		this.name = "RunParserError";
	}
};
/**
* @deprecated Use `RunParserError` instead. This export will be removed in
*             a future major version.
*/
const RunError = RunParserError;
function indentLines(text$1, indent) {
	return text$1.split("\n").join("\n" + " ".repeat(indent));
}

//#endregion
export { RunError, RunParserError, run, runParser, runParserAsync, runParserSync };