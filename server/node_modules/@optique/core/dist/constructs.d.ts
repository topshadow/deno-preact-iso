import { Message } from "./message.js";
import { CombineModes, InferValue, Mode, Parser, ParserResult } from "./parser.js";

//#region src/constructs.d.ts

/**
 * Helper type to extract Mode from a Parser.
 * @internal
 */
type ExtractMode<T> = T extends Parser<infer M, unknown, unknown> ? M : never;
/**
 * Helper type to combine modes from an object of parsers.
 * Returns "async" if any parser is async, otherwise "sync".
 * @internal
 */
type CombineObjectModes<T extends {
  readonly [key: string | symbol]: Parser<Mode, unknown, unknown>;
}> = CombineModes<{ [K in keyof T]: ExtractMode<T[K]> }[keyof T] extends infer M ? M extends Mode ? readonly [M] : never : never>;
/**
 * Helper type to combine modes from a tuple of parsers.
 * Returns "async" if any parser is async, otherwise "sync".
 * @internal
 */
type CombineTupleModes<T extends readonly Parser<Mode, unknown, unknown>[]> = CombineModes<{ readonly [K in keyof T]: ExtractMode<T[K]> }>;
/**
 * Options for customizing error messages in the {@link or} combinator.
 * @since 0.5.0
 */
interface OrOptions {
  /**
   * Error message customization options.
   */
  errors?: OrErrorOptions;
}
/**
 * Context information about what types of inputs are expected,
 * used for generating contextual error messages.
 * @since 0.9.0
 */
interface NoMatchContext {
  /**
   * Whether any of the parsers expect options.
   */
  readonly hasOptions: boolean;
  /**
   * Whether any of the parsers expect commands.
   */
  readonly hasCommands: boolean;
  /**
   * Whether any of the parsers expect arguments.
   */
  readonly hasArguments: boolean;
}
/**
 * Options for customizing error messages in the {@link or} parser.
 * @since 0.5.0
 */
interface OrErrorOptions {
  /**
   * Custom error message when no parser matches.
   * Can be a static message or a function that receives context about what
   * types of inputs are expected, allowing for more precise error messages.
   *
   * @example
   * ```typescript
   * // Static message (overrides all cases)
   * { noMatch: message`Invalid input.` }
   *
   * // Dynamic message based on context (for i18n, etc.)
   * {
   *   noMatch: ({ hasOptions, hasCommands, hasArguments }) => {
   *     if (hasArguments && !hasOptions && !hasCommands) {
   *       return message`인수가 필요합니다.`; // Korean: "Argument required"
   *     }
   *     // ... other cases
   *   }
   * }
   * ```
   * @since 0.9.0 - Function form added
   */
  noMatch?: Message | ((context: NoMatchContext) => Message);
  /**
   * Custom error message for unexpected input.
   * Can be a static message or a function that receives the unexpected token.
   */
  unexpectedInput?: Message | ((token: string) => Message);
  /**
   * Custom function to format suggestion messages.
   * If provided, this will be used instead of the default "Did you mean?"
   * formatting. The function receives an array of similar valid options/commands
   * and should return a formatted message to append to the error.
   *
   * @param suggestions Array of similar valid option/command names
   * @returns Formatted message to append to the error (can be empty array for no suggestions)
   * @since 0.7.0
   */
  suggestions?: (suggestions: readonly string[]) => Message;
}
/**
 * Error class thrown when duplicate option names are detected during parser
 * construction. This is a programmer error, not a user error.
 */
declare class DuplicateOptionError extends Error {
  readonly optionName: string;
  readonly sources: readonly (string | symbol)[];
  constructor(optionName: string, sources: readonly (string | symbol)[]);
}
/**
 * Creates a parser that combines two mutually exclusive parsers into one.
 * The resulting parser will try each of the provided parsers in order,
 * and return the result of the first successful parser.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @returns A {@link Parser} that tries to parse using the provided parsers
 *          in order, returning the result of the first successful parser.
 */
declare function or<MA extends Mode, MB extends Mode, TA, TB, TStateA, TStateB>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>): Parser<CombineModes<readonly [MA, MB]>, TA | TB, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>]>;
/**
 * Creates a parser that combines three mutually exclusive parsers into one.
 * The resulting parser will try each of the provided parsers in order,
 * and return the result of the first successful parser.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @return A {@link Parser} that tries to parse using the provided parsers
 *         in order, returning the result of the first successful parser.
 */
declare function or<MA extends Mode, MB extends Mode, MC extends Mode, TA, TB, TC, TStateA, TStateB, TStateC>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>): Parser<CombineModes<readonly [MA, MB, MC]>, TA | TB | TC, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>]>;
/**
 * Creates a parser that combines four mutually exclusive parsers into one.
 * The resulting parser will try each of the provided parsers in order,
 * and return the result of the first successful parser.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template MD The mode of the fourth parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TD The type of the value returned by the fourth parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @template TStateD The type of the state used by the fourth parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param d The fourth {@link Parser} to try.
 * @return A {@link Parser} that tries to parse using the provided parsers
 *         in order, returning the result of the first successful parser.
 */
declare function or<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, TA, TB, TC, TD, TStateA, TStateB, TStateC, TStateD>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>): Parser<CombineModes<readonly [MA, MB, MC, MD]>, TA | TB | TC | TD, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>] | [3, ParserResult<TStateD>]>;
/**
 * Creates a parser that combines five mutually exclusive parsers into one.
 * The resulting parser will try each of the provided parsers in order,
 * and return the result of the first successful parser.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template MD The mode of the fourth parser.
 * @template ME The mode of the fifth parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TD The type of the value returned by the fourth parser.
 * @template TE The type of the value returned by the fifth parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @template TStateD The type of the state used by the fourth parser.
 * @template TStateE The type of the state used by the fifth parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param d The fourth {@link Parser} to try.
 * @param e The fifth {@link Parser} to try.
 * @return A {@link Parser} that tries to parse using the provided parsers
 *         in order, returning the result of the first successful parser.
 */
declare function or<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, ME extends Mode, TA, TB, TC, TD, TE, TStateA, TStateB, TStateC, TStateD, TStateE>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>, e: Parser<ME, TE, TStateE>): Parser<CombineModes<readonly [MA, MB, MC, MD, ME]>, TA | TB | TC | TD | TE, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>] | [3, ParserResult<TStateD>] | [4, ParserResult<TStateE>]>;
/**
 * Creates a parser that combines six mutually exclusive parsers into one.
 * The resulting parser will try each of the provided parsers in order,
 * and return the result of the first successful parser.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template MD The mode of the fourth parser.
 * @template ME The mode of the fifth parser.
 * @template MF The mode of the sixth parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TD The type of the value returned by the fourth parser.
 * @template TE The type of the value returned by the fifth parser.
 * @template TF The type of the value returned by the sixth parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @template TStateD The type of the state used by the fourth parser.
 * @template TStateE The type of the state used by the fifth parser.
 * @template TStateF The type of the state used by the sixth parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param d The fourth {@link Parser} to try.
 * @param e The fifth {@link Parser} to try.
 * @param f The sixth {@link Parser} to try.
 * @return A {@link Parser} that tries to parse using the provided parsers
 *         in order, returning the result of the first successful parser.
 * @since 0.3.0
 */
declare function or<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, ME extends Mode, MF extends Mode, TA, TB, TC, TD, TE, TF, TStateA, TStateB, TStateC, TStateD, TStateE, TStateF>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>, e: Parser<ME, TE, TStateE>, f: Parser<MF, TF, TStateF>): Parser<CombineModes<readonly [MA, MB, MC, MD, ME, MF]>, TA | TB | TC | TD | TE | TF, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>] | [3, ParserResult<TStateD>] | [4, ParserResult<TStateE>] | [5, ParserResult<TStateF>]>;
/**
 * Creates a parser that combines seven mutually exclusive parsers into one.
 * The resulting parser will try each of the provided parsers in order,
 * and return the result of the first successful parser.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template MD The mode of the fourth parser.
 * @template ME The mode of the fifth parser.
 * @template MF The mode of the sixth parser.
 * @template MG The mode of the seventh parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TD The type of the value returned by the fourth parser.
 * @template TE The type of the value returned by the fifth parser.
 * @template TF The type of the value returned by the sixth parser.
 * @template TG The type of the value returned by the seventh parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @template TStateD The type of the state used by the fourth parser.
 * @template TStateE The type of the state used by the fifth parser.
 * @template TStateF The type of the state used by the sixth parser.
 * @template TStateG The type of the state used by the seventh parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param d The fourth {@link Parser} to try.
 * @param e The fifth {@link Parser} to try.
 * @param f The sixth {@link Parser} to try.
 * @param g The seventh {@link Parser} to try.
 * @return A {@link Parser} that tries to parse using the provided parsers
 *         in order, returning the result of the first successful parser.
 * @since 0.3.0
 */
declare function or<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, ME extends Mode, MF extends Mode, MG extends Mode, TA, TB, TC, TD, TE, TF, TG, TStateA, TStateB, TStateC, TStateD, TStateE, TStateF, TStateG>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>, e: Parser<ME, TE, TStateE>, f: Parser<MF, TF, TStateF>, g: Parser<MG, TG, TStateG>): Parser<CombineModes<readonly [MA, MB, MC, MD, ME, MF, MG]>, TA | TB | TC | TD | TE | TF | TG, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>] | [3, ParserResult<TStateD>] | [4, ParserResult<TStateE>] | [5, ParserResult<TStateF>] | [6, ParserResult<TStateG>]>;
/**
 * Creates a parser that combines eight mutually exclusive parsers into one.
 * The resulting parser will try each of the provided parsers in order,
 * and return the result of the first successful parser.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template MD The mode of the fourth parser.
 * @template ME The mode of the fifth parser.
 * @template MF The mode of the sixth parser.
 * @template MG The mode of the seventh parser.
 * @template MH The mode of the eighth parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TD The type of the value returned by the fourth parser.
 * @template TE The type of the value returned by the fifth parser.
 * @template TF The type of the value returned by the sixth parser.
 * @template TG The type of the value returned by the seventh parser.
 * @template TH The type of the value returned by the eighth parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @template TStateD The type of the state used by the fourth parser.
 * @template TStateE The type of the state used by the fifth parser.
 * @template TStateF The type of the state used by the sixth parser.
 * @template TStateG The type of the state used by the seventh parser.
 * @template TStateH The type of the state used by the eighth parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param d The fourth {@link Parser} to try.
 * @param e The fifth {@link Parser} to try.
 * @param f The sixth {@link Parser} to try.
 * @param g The seventh {@link Parser} to try.
 * @param h The eighth {@link Parser} to try.
 * @return A {@link Parser} that tries to parse using the provided parsers
 *         in order, returning the result of the first successful parser.
 * @since 0.3.0
 */
declare function or<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, ME extends Mode, MF extends Mode, MG extends Mode, MH extends Mode, TA, TB, TC, TD, TE, TF, TG, TH, TStateA, TStateB, TStateC, TStateD, TStateE, TStateF, TStateG, TStateH>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>, e: Parser<ME, TE, TStateE>, f: Parser<MF, TF, TStateF>, g: Parser<MG, TG, TStateG>, h: Parser<MH, TH, TStateH>): Parser<CombineModes<readonly [MA, MB, MC, MD, ME, MF, MG, MH]>, TA | TB | TC | TD | TE | TF | TG | TH, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>] | [3, ParserResult<TStateD>] | [4, ParserResult<TStateE>] | [5, ParserResult<TStateF>] | [6, ParserResult<TStateG>] | [7, ParserResult<TStateH>]>;
/**
 * Creates a parser that combines nine mutually exclusive parsers into one.
 * The resulting parser will try each of the provided parsers in order,
 * and return the result of the first successful parser.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template MD The mode of the fourth parser.
 * @template ME The mode of the fifth parser.
 * @template MF The mode of the sixth parser.
 * @template MG The mode of the seventh parser.
 * @template MH The mode of the eighth parser.
 * @template MI The mode of the ninth parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TD The type of the value returned by the fourth parser.
 * @template TE The type of the value returned by the fifth parser.
 * @template TF The type of the value returned by the sixth parser.
 * @template TG The type of the value returned by the seventh parser.
 * @template TH The type of the value returned by the eighth parser.
 * @template TI The type of the value returned by the ninth parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @template TStateD The type of the state used by the fourth parser.
 * @template TStateE The type of the state used by the fifth parser.
 * @template TStateF The type of the state used by the sixth parser.
 * @template TStateG The type of the state used by the seventh parser.
 * @template TStateH The type of the state used by the eighth parser.
 * @template TStateI The type of the state used by the ninth parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param d The fourth {@link Parser} to try.
 * @param e The fifth {@link Parser} to try.
 * @param f The sixth {@link Parser} to try.
 * @param g The seventh {@link Parser} to try.
 * @param h The eighth {@link Parser} to try.
 * @param i The ninth {@link Parser} to try.
 * @return A {@link Parser} that tries to parse using the provided parsers
 *         in order, returning the result of the first successful parser.
 * @since 0.3.0
 */
declare function or<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, ME extends Mode, MF extends Mode, MG extends Mode, MH extends Mode, MI extends Mode, TA, TB, TC, TD, TE, TF, TG, TH, TI, TStateA, TStateB, TStateC, TStateD, TStateE, TStateF, TStateG, TStateH, TStateI>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>, e: Parser<ME, TE, TStateE>, f: Parser<MF, TF, TStateF>, g: Parser<MG, TG, TStateG>, h: Parser<MH, TH, TStateH>, i: Parser<MI, TI, TStateI>): Parser<CombineModes<readonly [MA, MB, MC, MD, ME, MF, MG, MH, MI]>, TA | TB | TC | TD | TE | TF | TG | TH | TI, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>] | [3, ParserResult<TStateD>] | [4, ParserResult<TStateE>] | [5, ParserResult<TStateF>] | [6, ParserResult<TStateG>] | [7, ParserResult<TStateH>] | [8, ParserResult<TStateI>]>;
/**
 * Creates a parser that combines ten mutually exclusive parsers into one.
 * The resulting parser will try each of the provided parsers in order,
 * and return the result of the first successful parser.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template MD The mode of the fourth parser.
 * @template ME The mode of the fifth parser.
 * @template MF The mode of the sixth parser.
 * @template MG The mode of the seventh parser.
 * @template MH The mode of the eighth parser.
 * @template MI The mode of the ninth parser.
 * @template MJ The mode of the tenth parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TD The type of the value returned by the fourth parser.
 * @template TE The type of the value returned by the fifth parser.
 * @template TF The type of the value returned by the sixth parser.
 * @template TG The type of the value returned by the seventh parser.
 * @template TH The type of the value returned by the eighth parser.
 * @template TI The type of the value returned by the ninth parser.
 * @template TJ The type of the value returned by the tenth parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @template TStateD The type of the state used by the fourth parser.
 * @template TStateE The type of the state used by the fifth parser.
 * @template TStateF The type of the state used by the sixth parser.
 * @template TStateG The type of the state used by the seventh parser.
 * @template TStateH The type of the state used by the eighth parser.
 * @template TStateI The type of the state used by the ninth parser.
 * @template TStateJ The type of the state used by the tenth parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param d The fourth {@link Parser} to try.
 * @param e The fifth {@link Parser} to try.
 * @param f The sixth {@link Parser} to try.
 * @param g The seventh {@link Parser} to try.
 * @param h The eighth {@link Parser} to try.
 * @param i The ninth {@link Parser} to try.
 * @param j The tenth {@link Parser} to try.
 * @return A {@link Parser} that tries to parse using the provided parsers
 *         in order, returning the result of the first successful parser.
 * @since 0.3.0
 */
declare function or<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, ME extends Mode, MF extends Mode, MG extends Mode, MH extends Mode, MI extends Mode, MJ extends Mode, TA, TB, TC, TD, TE, TF, TG, TH, TI, TJ, TStateA, TStateB, TStateC, TStateD, TStateE, TStateF, TStateG, TStateH, TStateI, TStateJ>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>, e: Parser<ME, TE, TStateE>, f: Parser<MF, TF, TStateF>, g: Parser<MG, TG, TStateG>, h: Parser<MH, TH, TStateH>, i: Parser<MI, TI, TStateI>, j: Parser<MJ, TJ, TStateJ>): Parser<CombineModes<readonly [MA, MB, MC, MD, ME, MF, MG, MH, MI, MJ]>, TA | TB | TC | TD | TE | TF | TG | TH | TI | TJ, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>] | [3, ParserResult<TStateD>] | [4, ParserResult<TStateE>] | [5, ParserResult<TStateF>] | [6, ParserResult<TStateG>] | [7, ParserResult<TStateH>] | [8, ParserResult<TStateI>] | [9, ParserResult<TStateJ>]>;
/**
 * Creates a parser that combines two mutually exclusive parsers into one,
 * with custom error message options.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param options Custom error message options.
 * @return A {@link Parser} that tries to parse using the provided parsers.
 * @since 0.5.0
 */
declare function or<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, options: OrOptions): Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>]>, InferValue<TA> | InferValue<TB>, undefined | [number, ParserResult<unknown>]>;
/**
 * Creates a parser that combines three mutually exclusive parsers into one,
 * with custom error message options.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param options Custom error message options.
 * @return A {@link Parser} that tries to parse using the provided parsers.
 * @since 0.5.0
 */
declare function or<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, c: TC, options: OrOptions): Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>, ExtractMode<TC>]>, InferValue<TA> | InferValue<TB> | InferValue<TC>, undefined | [number, ParserResult<unknown>]>;
declare function or(...parsers: Parser<Mode, unknown, unknown>[]): Parser<Mode, unknown, undefined | [number, ParserResult<unknown>]>;
/**
 * Creates a parser that tries each parser in sequence until one succeeds,
 * with custom error message options.
 * @param parser1 The first parser to try.
 * @param rest Additional parsers and {@link OrOptions} for error customization.
 * @returns A parser that succeeds if any of the input parsers succeed.
 * @since 0.5.0
 */
declare function or(parser1: Parser<Mode, unknown, unknown>, ...rest: [...parsers: Parser<Mode, unknown, unknown>[], options: OrOptions]): Parser<Mode, unknown, undefined | [number, ParserResult<unknown>]>;
/**
 * Options for customizing error messages in the {@link longestMatch}
 * combinator.
 * @since 0.5.0
 */
interface LongestMatchOptions {
  /**
   * Error message customization options.
   */
  errors?: LongestMatchErrorOptions;
}
/**
 * Options for customizing error messages in the {@link longesMatch} parser.
 * @since 0.5.0
 */
interface LongestMatchErrorOptions {
  /**
   * Custom error message when no parser matches.
   * Can be a static message or a function that receives context about what
   * types of inputs are expected, allowing for more precise error messages.
   *
   * @example
   * ```typescript
   * // Static message (overrides all cases)
   * { noMatch: message`Invalid input.` }
   *
   * // Dynamic message based on context (for i18n, etc.)
   * {
   *   noMatch: ({ hasOptions, hasCommands, hasArguments }) => {
   *     if (hasArguments && !hasOptions && !hasCommands) {
   *       return message`引数が必要です。`; // Japanese: "Argument required"
   *     }
   *     // ... other cases
   *   }
   * }
   * ```
   * @since 0.9.0 - Function form added
   */
  noMatch?: Message | ((context: NoMatchContext) => Message);
  /**
   * Custom error message for unexpected input.
   * Can be a static message or a function that receives the unexpected token.
   */
  unexpectedInput?: Message | ((token: string) => Message);
  /**
   * Custom function to format suggestion messages.
   * If provided, this will be used instead of the default "Did you mean?"
   * formatting. The function receives an array of similar valid options/commands
   * and should return a formatted message to append to the error.
   *
   * @param suggestions Array of similar valid option/command names
   * @returns Formatted message to append to the error (can be empty array for no suggestions)
   * @since 0.7.0
   */
  suggestions?: (suggestions: readonly string[]) => Message;
}
/**
 * Creates a parser that combines two mutually exclusive parsers into one,
 * selecting the parser that consumes the most tokens.
 * The resulting parser will try both parsers and return the result
 * of the parser that consumed more input tokens.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @returns A {@link Parser} that tries to parse using both parsers
 *          and returns the result of the parser that consumed more tokens.
 * @since 0.3.0
 */
declare function longestMatch<MA extends Mode, MB extends Mode, TA, TB, TStateA, TStateB>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>): Parser<CombineModes<readonly [MA, MB]>, TA | TB, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>]>;
/**
 * Creates a parser that combines three mutually exclusive parsers into one,
 * selecting the parser that consumes the most tokens.
 * The resulting parser will try all parsers and return the result
 * of the parser that consumed the most input tokens.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @returns A {@link Parser} that tries to parse using all parsers
 *          and returns the result of the parser that consumed the most tokens.
 * @since 0.3.0
 */
declare function longestMatch<MA extends Mode, MB extends Mode, MC extends Mode, TA, TB, TC, TStateA, TStateB, TStateC>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>): Parser<CombineModes<readonly [MA, MB, MC]>, TA | TB | TC, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>]>;
/**
 * Creates a parser that combines four mutually exclusive parsers into one,
 * selecting the parser that consumes the most tokens.
 * The resulting parser will try all parsers and return the result
 * of the parser that consumed the most input tokens.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template MD The mode of the fourth parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TD The type of the value returned by the fourth parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @template TStateD The type of the state used by the fourth parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param d The fourth {@link Parser} to try.
 * @returns A {@link Parser} that tries to parse using all parsers
 *          and returns the result of the parser that consumed the most tokens.
 * @since 0.3.0
 */
declare function longestMatch<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, TA, TB, TC, TD, TStateA, TStateB, TStateC, TStateD>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>): Parser<CombineModes<readonly [MA, MB, MC, MD]>, TA | TB | TC | TD, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>] | [3, ParserResult<TStateD>]>;
/**
 * Creates a parser that combines five mutually exclusive parsers into one,
 * selecting the parser that consumes the most tokens.
 * The resulting parser will try all parsers and return the result
 * of the parser that consumed the most input tokens.
 * @template MA The mode of the first parser.
 * @template MB The mode of the second parser.
 * @template MC The mode of the third parser.
 * @template MD The mode of the fourth parser.
 * @template ME The mode of the fifth parser.
 * @template TA The type of the value returned by the first parser.
 * @template TB The type of the value returned by the second parser.
 * @template TC The type of the value returned by the third parser.
 * @template TD The type of the value returned by the fourth parser.
 * @template TE The type of the value returned by the fifth parser.
 * @template TStateA The type of the state used by the first parser.
 * @template TStateB The type of the state used by the second parser.
 * @template TStateC The type of the state used by the third parser.
 * @template TStateD The type of the state used by the fourth parser.
 * @template TStateE The type of the state used by the fifth parser.
 * @param a The first {@link Parser} to try.
 * @param b The second {@link Parser} to try.
 * @param c The third {@link Parser} to try.
 * @param d The fourth {@link Parser} to try.
 * @param e The fifth {@link Parser} to try.
 * @returns A {@link Parser} that tries to parse using all parsers
 *          and returns the result of the parser that consumed the most tokens.
 * @since 0.3.0
 */
declare function longestMatch<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, ME extends Mode, TA, TB, TC, TD, TE, TStateA, TStateB, TStateC, TStateD, TStateE>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>, e: Parser<ME, TE, TStateE>): Parser<CombineModes<readonly [MA, MB, MC, MD, ME]>, TA | TB | TC | TD | TE, undefined | [0, ParserResult<TStateA>] | [1, ParserResult<TStateB>] | [2, ParserResult<TStateC>] | [3, ParserResult<TStateD>] | [4, ParserResult<TStateE>]>;
/**
 * Creates a parser that combines two mutually exclusive parsers into one,
 * with custom error message options.
 * @since 0.5.0
 */
declare function longestMatch<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, options: LongestMatchOptions): Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>]>, InferValue<TA> | InferValue<TB>, undefined | [number, ParserResult<unknown>]>;
/**
 * Creates a parser that combines three mutually exclusive parsers into one,
 * with custom error message options.
 * @since 0.5.0
 */
declare function longestMatch<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, c: TC, options: LongestMatchOptions): Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>, ExtractMode<TC>]>, InferValue<TA> | InferValue<TB> | InferValue<TC>, undefined | [number, ParserResult<unknown>]>;
declare function longestMatch(...parsers: Parser<Mode, unknown, unknown>[]): Parser<Mode, unknown, undefined | [number, ParserResult<unknown>]>;
/**
 * Creates a parser that tries all parsers and selects the one that consumes
 * the most input, with custom error message options.
 * @param parser1 The first parser to try.
 * @param rest Additional parsers and {@link LongestMatchOptions} for error customization.
 * @returns A parser that succeeds with the result from the parser that
 *          consumed the most input.
 * @since 0.5.0
 */
declare function longestMatch(parser1: Parser<Mode, unknown, unknown>, ...rest: [...parsers: Parser<Mode, unknown, unknown>[], options: LongestMatchOptions]): Parser<Mode, unknown, undefined | [number, ParserResult<unknown>]>;
/**
 * Options for the {@link object} parser.
 * @since 0.5.0
 */
interface ObjectOptions {
  /**
   * Error messages customization.
   */
  readonly errors?: ObjectErrorOptions;
  /**
   * When `true`, allows duplicate option names across different fields.
   * By default (`false`), duplicate option names will cause a parse error.
   *
   * @default `false`
   * @since 0.7.0
   */
  readonly allowDuplicates?: boolean;
}
/**
 * Options for customizing error messages in the {@link object} parser.
 * @since 0.5.0
 */
interface ObjectErrorOptions {
  /**
   * Error message when an unexpected option or argument is encountered.
   */
  readonly unexpectedInput?: Message | ((token: string) => Message);
  /**
   * Error message when end of input is reached unexpectedly.
   * Can be a static message or a function that receives context about what
   * types of inputs are expected, allowing for more precise error messages.
   *
   * @example
   * ```typescript
   * // Static message (overrides all cases)
   * { endOfInput: message`Invalid input.` }
   *
   * // Dynamic message based on context (for i18n, etc.)
   * {
   *   endOfInput: ({ hasOptions, hasCommands, hasArguments }) => {
   *     if (hasArguments && !hasOptions && !hasCommands) {
   *       return message`Argument manquant.`; // French: "Missing argument"
   *     }
   *     // ... other cases
   *   }
   * }
   * ```
   * @since 0.9.0 - Function form added
   */
  readonly endOfInput?: Message | ((context: NoMatchContext) => Message);
  /**
   * Custom function to format suggestion messages.
   * If provided, this will be used instead of the default "Did you mean?"
   * formatting. The function receives an array of similar valid options/commands
   * and should return a formatted message to append to the error.
   *
   * @param suggestions Array of similar valid option/command names
   * @returns Formatted message to append to the error (can be empty array for no suggestions)
   * @since 0.7.0
   */
  readonly suggestions?: (suggestions: readonly string[]) => Message;
}
/**
 * Creates a parser that combines multiple parsers into a single object parser.
 * Each parser in the object is applied to parse different parts of the input,
 * and the results are combined into an object with the same structure.
 * @template T A record type where each value is a {@link Parser}.
 * @param parsers An object containing named parsers that will be combined
 *                into a single object parser.
 * @returns A {@link Parser} that produces an object with the same keys as
 *          the input, where each value is the result of the corresponding
 *          parser.
 */
declare function object<T extends {
  readonly [key: string | symbol]: Parser<Mode, unknown, unknown>;
}>(parsers: T): Parser<CombineObjectModes<T>, { readonly [K in keyof T]: T[K]["$valueType"][number] extends (infer U) ? U : never }, { readonly [K in keyof T]: T[K]["$stateType"][number] extends (infer U2) ? U2 : never }>;
/**
 * Creates a parser that combines multiple parsers into a single object parser.
 * Each parser in the object is applied to parse different parts of the input,
 * and the results are combined into an object with the same structure.
 * @template T A record type where each value is a {@link Parser}.
 * @param parsers An object containing named parsers that will be combined
 *                into a single object parser.
 * @param options Optional configuration for error customization.
 *                See {@link ObjectOptions}.
 * @returns A {@link Parser} that produces an object with the same keys as
 *          the input, where each value is the result of the corresponding
 *          parser.
 * @since 0.5.0
 */
declare function object<T extends {
  readonly [key: string | symbol]: Parser<Mode, unknown, unknown>;
}>(parsers: T, options: ObjectOptions): Parser<CombineObjectModes<T>, { readonly [K in keyof T]: T[K]["$valueType"][number] extends (infer U) ? U : never }, { readonly [K in keyof T]: T[K]["$stateType"][number] extends (infer U2) ? U2 : never }>;
/**
 * Creates a labeled parser that combines multiple parsers into a single
 * object parser with an associated label for documentation or error reporting.
 * @template T A record type where each value is a {@link Parser}.
 * @param label A descriptive label for this parser group, used for
 *              documentation and error messages.
 * @param parsers An object containing named parsers that will be combined
 *                into a single object parser.
 * @returns A {@link Parser} that produces an object with the same keys as
 *          the input, where each value is the result of the corresponding
 *          parser.
 */
declare function object<T extends {
  readonly [key: string | symbol]: Parser<Mode, unknown, unknown>;
}>(label: string, parsers: T): Parser<CombineObjectModes<T>, { readonly [K in keyof T]: T[K]["$valueType"][number] extends (infer U) ? U : never }, { readonly [K in keyof T]: T[K]["$stateType"][number] extends (infer U2) ? U2 : never }>;
/**
 * Creates a labeled parser that combines multiple parsers into a single
 * object parser with an associated label for documentation or error reporting.
 * @template T A record type where each value is a {@link Parser}.
 * @param label A descriptive label for this parser group, used for
 *              documentation and error messages.
 * @param parsers An object containing named parsers that will be combined
 *                into a single object parser.
 * @param options Optional configuration for error customization.
 *                See {@link ObjectOptions}.
 * @returns A {@link Parser} that produces an object with the same keys as
 *          the input, where each value is the result of the corresponding
 *          parser.
 * @since 0.5.0
 */
declare function object<T extends {
  readonly [key: string | symbol]: Parser<Mode, unknown, unknown>;
}>(label: string, parsers: T, options: ObjectOptions): Parser<CombineObjectModes<T>, { readonly [K in keyof T]: T[K]["$valueType"][number] extends (infer U) ? U : never }, { readonly [K in keyof T]: T[K]["$stateType"][number] extends (infer U2) ? U2 : never }>;
/**
 * Options for the {@link tuple} parser.
 * @since 0.7.0
 */
interface TupleOptions {
  /**
   * When `true`, allows duplicate option names across different parsers.
   * By default (`false`), duplicate option names will cause a parse error.
   *
   * @default `false`
   * @since 0.7.0
   */
  readonly allowDuplicates?: boolean;
}
/**
 * Creates a parser that combines multiple parsers into a sequential tuple parser.
 * The parsers are applied in the order they appear in the array, and all must
 * succeed for the tuple parser to succeed.
 * @template T A readonly array type where each element is a {@link Parser}.
 * @param parsers An array of parsers that will be applied sequentially
 *                to create a tuple of their results.
 * @param options Optional configuration for the tuple parser.
 * @returns A {@link Parser} that produces a readonly tuple with the same length
 *          as the input array, where each element is the result of the
 *          corresponding parser.
 */
declare function tuple<const T extends readonly Parser<Mode, unknown, unknown>[]>(parsers: T, options?: TupleOptions): Parser<CombineTupleModes<T>, { readonly [K in keyof T]: T[K]["$valueType"][number] extends (infer U) ? U : never }, { readonly [K in keyof T]: T[K]["$stateType"][number] extends (infer U2) ? U2 : never }>;
/**
 * Creates a labeled parser that combines multiple parsers into a sequential
 * tuple parser with an associated label for documentation or error reporting.
 * @template T A readonly array type where each element is a {@link Parser}.
 * @param label A descriptive label for this parser group, used for
 *              documentation and error messages.
 * @param parsers An array of parsers that will be applied sequentially
 *                to create a tuple of their results.
 * @param options Optional configuration for the tuple parser.
 * @returns A {@link Parser} that produces a readonly tuple with the same length
 *          as the input array, where each element is the result of the
 *          corresponding parser.
 */
declare function tuple<const T extends readonly Parser<Mode, unknown, unknown>[]>(label: string, parsers: T, options?: TupleOptions): Parser<CombineTupleModes<T>, { readonly [K in keyof T]: T[K]["$valueType"][number] extends (infer U) ? U : never }, { readonly [K in keyof T]: T[K]["$stateType"][number] extends (infer U2) ? U2 : never }>;
/**
 * Helper type to check if all members of a union are object-like.
 * This allows merge() to work with parsers like withDefault() that produce union types.
 */
type AllObjectLike<T> = T extends readonly unknown[] ? never : T extends Record<string | symbol, unknown> ? T : never;
/**
 * Helper type to extract object-like types from parser value types,
 * including union types where all members are objects.
 */
type ExtractObjectTypes<P> = P extends Parser<Mode, infer V, unknown> ? [AllObjectLike<V>] extends [never] ? never : V : never;
/**
 * Options for the {@link merge} parser.
 * @since 0.7.0
 */
interface MergeOptions {
  /**
   * When `true`, allows duplicate option names across merged parsers.
   * By default (`false`), duplicate option names will cause a parse error.
   *
   * @default `false`
   * @since 0.7.0
   */
  readonly allowDuplicates?: boolean;
}
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the two parsers into a single object.
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>>(a: ExtractObjectTypes<TA> extends never ? never : TA, b: ExtractObjectTypes<TB> extends never ? never : TB): Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param options Optional configuration for the merge parser.
 * @return A new {@link object} parser that combines the values and states
 *         of the two parsers into a single object.
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>>(a: ExtractObjectTypes<TA> extends never ? never : TA, b: ExtractObjectTypes<TB> extends never ? never : TB, options: MergeOptions): Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser
 * with a label for documentation and help text organization.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @param label A descriptive label for this merged group, used for
 *              documentation and help messages.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the two parsers into a single object.
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>>(label: string, a: ExtractObjectTypes<TA> extends never ? never : TA, b: ExtractObjectTypes<TB> extends never ? never : TB): Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the two parsers into a single object.
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>>(a: ExtractObjectTypes<TA> extends never ? never : TA, b: ExtractObjectTypes<TB> extends never ? never : TB, c: ExtractObjectTypes<TC> extends never ? never : TC): Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>, ExtractMode<TC>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser
 * with a label for documentation and help text organization.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @param label A descriptive label for this merged group, used for
 *              documentation and help messages.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the two parsers into a single object.
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>>(label: string, a: TA, b: TB, c: TC): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>, ExtractMode<TC>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the two parsers into a single object.
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, c: TC, d: TD): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>, ExtractMode<TC>, ExtractMode<TD>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser
 * with a label for documentation and help text organization.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @param label A descriptive label for this merged group, used for
 *              documentation and help messages.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the two parsers into a single object.
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>>(label: string, a: TA, b: TB, c: TC, d: TD): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>, ExtractMode<TC>, ExtractMode<TD>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the two parsers into a single object.
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>>(a: ExtractObjectTypes<TA> extends never ? never : TA, b: ExtractObjectTypes<TB> extends never ? never : TB, c: ExtractObjectTypes<TC> extends never ? never : TC, d: ExtractObjectTypes<TD> extends never ? never : TD, e: ExtractObjectTypes<TE> extends never ? never : TE): Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>, ExtractMode<TC>, ExtractMode<TD>, ExtractMode<TE>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser
 * with a label for documentation and help text organization.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @param label A descriptive label for this merged group, used for
 *              documentation and help messages.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the two parsers into a single object.
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>>(label: string, a: TA, b: TB, c: TC, d: TD, e: TE): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>, ExtractMode<TC>, ExtractMode<TD>, ExtractMode<TE>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, c: TC, d: TD, e: TE, f: TF): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : Parser<ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser
 * with a label for documentation and help text organization.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @param label A descriptive label for this merged group, used for
 *              documentation and help messages.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>>(label: string, a: TA, b: TB, c: TC, d: TD, e: TE, f: TF): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : Parser<ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @template TG The type of the seventh parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @param g The seventh {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>, TG extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, c: TC, d: TD, e: TE, f: TF, g: TG): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : ExtractObjectTypes<TG> extends never ? never : Parser<ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF> & ExtractObjectTypes<TG>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser
 * with a label for documentation and help text organization.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @template TG The type of the seventh parser.
 * @param label A descriptive label for this merged group, used for
 *              documentation and help messages.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @param g The seventh {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>, TG extends Parser<Mode, unknown, unknown>>(label: string, a: TA, b: TB, c: TC, d: TD, e: TE, f: TF, g: TG): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : ExtractObjectTypes<TG> extends never ? never : Parser<ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF> & ExtractObjectTypes<TG>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @template TG The type of the seventh parser.
 * @template TH The type of the eighth parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @param g The seventh {@link object} parser to merge.
 * @param h The eighth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>, TG extends Parser<Mode, unknown, unknown>, TH extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, c: TC, d: TD, e: TE, f: TF, g: TG, h: TH): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : ExtractObjectTypes<TG> extends never ? never : ExtractObjectTypes<TH> extends never ? never : Parser<ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF> & ExtractObjectTypes<TG> & ExtractObjectTypes<TH>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser
 * with a label for documentation and help text organization.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @template TG The type of the seventh parser.
 * @template TH The type of the eighth parser.
 * @param label A descriptive label for this merged group, used for
 *              documentation and help messages.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @param g The seventh {@link object} parser to merge.
 * @param h The eighth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>, TG extends Parser<Mode, unknown, unknown>, TH extends Parser<Mode, unknown, unknown>>(label: string, a: TA, b: TB, c: TC, d: TD, e: TE, f: TF, g: TG, h: TH): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : ExtractObjectTypes<TG> extends never ? never : ExtractObjectTypes<TH> extends never ? never : Parser<ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF> & ExtractObjectTypes<TG> & ExtractObjectTypes<TH>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @template TG The type of the seventh parser.
 * @template TH The type of the eighth parser.
 * @template TI The type of the ninth parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @param g The seventh {@link object} parser to merge.
 * @param h The eighth {@link object} parser to merge.
 * @param i The ninth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>, TG extends Parser<Mode, unknown, unknown>, TH extends Parser<Mode, unknown, unknown>, TI extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, c: TC, d: TD, e: TE, f: TF, g: TG, h: TH, i: TI): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : ExtractObjectTypes<TG> extends never ? never : ExtractObjectTypes<TH> extends never ? never : ExtractObjectTypes<TI> extends never ? never : Parser<ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF> & ExtractObjectTypes<TG> & ExtractObjectTypes<TH> & ExtractObjectTypes<TI>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser
 * with a label for documentation and help text organization.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @template TG The type of the seventh parser.
 * @template TH The type of the eighth parser.
 * @template TI The type of the ninth parser.
 * @param label A descriptive label for this merged group, used for
 *              documentation and help messages.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @param g The seventh {@link object} parser to merge.
 * @param h The eighth {@link object} parser to merge.
 * @param i The ninth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>, TG extends Parser<Mode, unknown, unknown>, TH extends Parser<Mode, unknown, unknown>, TI extends Parser<Mode, unknown, unknown>>(label: string, a: TA, b: TB, c: TC, d: TD, e: TE, f: TF, g: TG, h: TH, i: TI): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : ExtractObjectTypes<TG> extends never ? never : ExtractObjectTypes<TH> extends never ? never : ExtractObjectTypes<TI> extends never ? never : Parser<ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF> & ExtractObjectTypes<TG> & ExtractObjectTypes<TH> & ExtractObjectTypes<TI>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @template TG The type of the seventh parser.
 * @template TH The type of the eighth parser.
 * @template TI The type of the ninth parser.
 * @template TJ The type of the tenth parser.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @param g The seventh {@link object} parser to merge.
 * @param h The eighth {@link object} parser to merge.
 * @param i The ninth {@link object} parser to merge.
 * @param j The tenth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>, TG extends Parser<Mode, unknown, unknown>, TH extends Parser<Mode, unknown, unknown>, TI extends Parser<Mode, unknown, unknown>, TJ extends Parser<Mode, unknown, unknown>>(a: TA, b: TB, c: TC, d: TD, e: TE, f: TF, g: TG, h: TH, i: TI, j: TJ): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : ExtractObjectTypes<TG> extends never ? never : ExtractObjectTypes<TH> extends never ? never : ExtractObjectTypes<TI> extends never ? never : ExtractObjectTypes<TJ> extends never ? never : Parser<ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF> & ExtractObjectTypes<TG> & ExtractObjectTypes<TH> & ExtractObjectTypes<TI> & ExtractObjectTypes<TJ>, Record<string | symbol, unknown>>;
/**
 * Merges multiple {@link object} parsers into a single {@link object} parser
 * with a label for documentation and help text organization.
 * It is useful for combining multiple {@link object} parsers so that
 * the unified parser produces a single object containing all the values
 * from the individual parsers while separating the fields into multiple
 * groups.
 * @template TA The type of the first parser.
 * @template TB The type of the second parser.
 * @template TC The type of the third parser.
 * @template TD The type of the fourth parser.
 * @template TE The type of the fifth parser.
 * @template TF The type of the sixth parser.
 * @template TG The type of the seventh parser.
 * @template TH The type of the eighth parser.
 * @template TI The type of the ninth parser.
 * @template TJ The type of the tenth parser.
 * @param label A descriptive label for this merged group, used for
 *              documentation and help messages.
 * @param a The first {@link object} parser to merge.
 * @param b The second {@link object} parser to merge.
 * @param c The third {@link object} parser to merge.
 * @param d The fourth {@link object} parser to merge.
 * @param e The fifth {@link object} parser to merge.
 * @param f The sixth {@link object} parser to merge.
 * @param g The seventh {@link object} parser to merge.
 * @param h The eighth {@link object} parser to merge.
 * @param i The ninth {@link object} parser to merge.
 * @param j The tenth {@link object} parser to merge.
 * @return A new {@link object} parser that combines the values and states
 *         of the parsers into a single object.
 * @since 0.4.0
 */
declare function merge<TA extends Parser<Mode, unknown, unknown>, TB extends Parser<Mode, unknown, unknown>, TC extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, unknown, unknown>, TE extends Parser<Mode, unknown, unknown>, TF extends Parser<Mode, unknown, unknown>, TG extends Parser<Mode, unknown, unknown>, TH extends Parser<Mode, unknown, unknown>, TI extends Parser<Mode, unknown, unknown>, TJ extends Parser<Mode, unknown, unknown>>(label: string, a: TA, b: TB, c: TC, d: TD, e: TE, f: TF, g: TG, h: TH, i: TI, j: TJ): ExtractObjectTypes<TA> extends never ? never : ExtractObjectTypes<TB> extends never ? never : ExtractObjectTypes<TC> extends never ? never : ExtractObjectTypes<TD> extends never ? never : ExtractObjectTypes<TE> extends never ? never : ExtractObjectTypes<TF> extends never ? never : ExtractObjectTypes<TG> extends never ? never : ExtractObjectTypes<TH> extends never ? never : ExtractObjectTypes<TI> extends never ? never : ExtractObjectTypes<TJ> extends never ? never : Parser<CombineModes<readonly [ExtractMode<TA>, ExtractMode<TB>, ExtractMode<TC>, ExtractMode<TD>, ExtractMode<TE>, ExtractMode<TF>, ExtractMode<TG>, ExtractMode<TH>, ExtractMode<TI>, ExtractMode<TJ>]>, ExtractObjectTypes<TA> & ExtractObjectTypes<TB> & ExtractObjectTypes<TC> & ExtractObjectTypes<TD> & ExtractObjectTypes<TE> & ExtractObjectTypes<TF> & ExtractObjectTypes<TG> & ExtractObjectTypes<TH> & ExtractObjectTypes<TI> & ExtractObjectTypes<TJ>, Record<string | symbol, unknown>>;
/**
 * Concatenates two {@link tuple} parsers into a single parser that produces
 * a flattened tuple containing the values from both parsers in order.
 *
 * This is similar to {@link merge} for object parsers, but operates on tuple
 * parsers and preserves the sequential, positional nature of tuples by
 * flattening the results into a single tuple array.
 *
 * @example
 * ```typescript
 * const basicTuple = tuple([
 *   option("-v", "--verbose"),
 *   option("-p", "--port", integer()),
 * ]);
 *
 * const serverTuple = tuple([
 *   option("-h", "--host", string()),
 *   option("-d", "--debug"),
 * ]);
 *
 * const combined = concat(basicTuple, serverTuple);
 * // Type: Parser<[boolean, number, string, boolean], [BasicState, ServerState]>
 *
 * const result = parse(combined, ["-v", "-p", "8080", "-h", "localhost", "-d"]);
 * // result.value: [true, 8080, "localhost", true]
 * ```
 *
 * @template TA The value type of the first tuple parser.
 * @template TB The value type of the second tuple parser.
 * @template TStateA The state type of the first tuple parser.
 * @template TStateB The state type of the second tuple parser.
 * @param a The first {@link tuple} parser to concatenate.
 * @param b The second {@link tuple} parser to concatenate.
 * @return A new {@link tuple} parser that combines the values of both parsers
 *         into a single flattened tuple.
 * @since 0.2.0
 */
declare function concat<MA extends Mode, MB extends Mode, TA extends readonly unknown[], TB extends readonly unknown[], TStateA, TStateB>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>): Parser<CombineModes<readonly [MA, MB]>, [...TA, ...TB], [TStateA, TStateB]>;
/**
 * Concatenates three {@link tuple} parsers into a single parser that produces
 * a flattened tuple containing the values from all parsers in order.
 *
 * @template TA The value type of the first tuple parser.
 * @template TB The value type of the second tuple parser.
 * @template TC The value type of the third tuple parser.
 * @template TStateA The state type of the first tuple parser.
 * @template TStateB The state type of the second tuple parser.
 * @template TStateC The state type of the third tuple parser.
 * @param a The first {@link tuple} parser to concatenate.
 * @param b The second {@link tuple} parser to concatenate.
 * @param c The third {@link tuple} parser to concatenate.
 * @return A new {@link tuple} parser that combines the values of all parsers
 *         into a single flattened tuple.
 * @since 0.2.0
 */
declare function concat<MA extends Mode, MB extends Mode, MC extends Mode, TA extends readonly unknown[], TB extends readonly unknown[], TC extends readonly unknown[], TStateA, TStateB, TStateC>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>): Parser<CombineModes<readonly [MA, MB, MC]>, [...TA, ...TB, ...TC], [TStateA, TStateB, TStateC]>;
/**
 * Concatenates four {@link tuple} parsers into a single parser that produces
 * a flattened tuple containing the values from all parsers in order.
 *
 * @template TA The value type of the first tuple parser.
 * @template TB The value type of the second tuple parser.
 * @template TC The value type of the third tuple parser.
 * @template TD The value type of the fourth tuple parser.
 * @template TStateA The state type of the first tuple parser.
 * @template TStateB The state type of the second tuple parser.
 * @template TStateC The state type of the third tuple parser.
 * @template TStateD The state type of the fourth tuple parser.
 * @param a The first {@link tuple} parser to concatenate.
 * @param b The second {@link tuple} parser to concatenate.
 * @param c The third {@link tuple} parser to concatenate.
 * @param d The fourth {@link tuple} parser to concatenate.
 * @return A new {@link tuple} parser that combines the values of all parsers
 *         into a single flattened tuple.
 * @since 0.2.0
 */
declare function concat<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, TA extends readonly unknown[], TB extends readonly unknown[], TC extends readonly unknown[], TD extends readonly unknown[], TStateA, TStateB, TStateC, TStateD>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>): Parser<CombineModes<readonly [MA, MB, MC, MD]>, [...TA, ...TB, ...TC, ...TD], [TStateA, TStateB, TStateC, TStateD]>;
/**
 * Concatenates five {@link tuple} parsers into a single parser that produces
 * a flattened tuple containing the values from all parsers in order.
 *
 * @template TA The value type of the first tuple parser.
 * @template TB The value type of the second tuple parser.
 * @template TC The value type of the third tuple parser.
 * @template TD The value type of the fourth tuple parser.
 * @template TE The value type of the fifth tuple parser.
 * @template TStateA The state type of the first tuple parser.
 * @template TStateB The state type of the second tuple parser.
 * @template TStateC The state type of the third tuple parser.
 * @template TStateD The state type of the fourth tuple parser.
 * @template TStateE The state type of the fifth tuple parser.
 * @param a The first {@link tuple} parser to concatenate.
 * @param b The second {@link tuple} parser to concatenate.
 * @param c The third {@link tuple} parser to concatenate.
 * @param d The fourth {@link tuple} parser to concatenate.
 * @param e The fifth {@link tuple} parser to concatenate.
 * @return A new {@link tuple} parser that combines the values of all parsers
 *         into a single flattened tuple.
 * @since 0.2.0
 */
declare function concat<MA extends Mode, MB extends Mode, MC extends Mode, MD extends Mode, ME extends Mode, TA extends readonly unknown[], TB extends readonly unknown[], TC extends readonly unknown[], TD extends readonly unknown[], TE extends readonly unknown[], TStateA, TStateB, TStateC, TStateD, TStateE>(a: Parser<MA, TA, TStateA>, b: Parser<MB, TB, TStateB>, c: Parser<MC, TC, TStateC>, d: Parser<MD, TD, TStateD>, e: Parser<ME, TE, TStateE>): Parser<CombineModes<readonly [MA, MB, MC, MD, ME]>, [...TA, ...TB, ...TC, ...TD, ...TE], [TStateA, TStateB, TStateC, TStateD, TStateE]>;
/**
 * Wraps a parser with a group label for documentation purposes.
 *
 * The `group()` function is a documentation-only wrapper that applies a label
 * to any parser for help text organization. This allows you to use clean code
 * structure with combinators like {@link merge} while maintaining well-organized
 * help text through group labeling.
 *
 * The wrapped parser has identical parsing behavior but generates documentation
 * fragments wrapped in a labeled section. This is particularly useful when
 * combining parsers using {@link merge}—you can wrap the merged result with
 * `group()` to add a section header in help output.
 *
 * @example
 * ```typescript
 * const apiOptions = merge(
 *   object({ endpoint: option("--endpoint", string()) }),
 *   object({ timeout: option("--timeout", integer()) })
 * );
 *
 * const groupedApiOptions = group("API Options", apiOptions);
 * // Now produces a labeled "API Options" section in help text
 * ```
 *
 * @example
 * ```typescript
 * // Can be used with any parser, not just merge()
 * const verboseGroup = group("Verbosity", object({
 *   verbose: option("-v", "--verbose"),
 *   quiet: option("-q", "--quiet")
 * }));
 * ```
 *
 * @template TValue The value type of the wrapped parser.
 * @template TState The state type of the wrapped parser.
 * @param label A descriptive label for this parser group, used for
 *              documentation and help text organization.
 * @param parser The parser to wrap with a group label.
 * @returns A new parser that behaves identically to the input parser
 *          but generates documentation within a labeled section.
 * @since 0.4.0
 */
declare function group<M extends Mode, TValue, TState>(label: string, parser: Parser<M, TValue, TState>): Parser<M, TValue, TState>;
/**
 * Tagged union type representing which branch is selected.
 * Uses tagged union to avoid collision with discriminator values.
 * @internal
 */
type SelectedBranch<TDiscriminator extends string> = {
  readonly kind: "branch";
  readonly key: TDiscriminator;
} | {
  readonly kind: "default";
};
/**
 * State type for the conditional parser.
 * @internal
 */
interface ConditionalState<TDiscriminator extends string> {
  readonly discriminatorState: unknown;
  readonly discriminatorValue: TDiscriminator | undefined;
  readonly selectedBranch: SelectedBranch<TDiscriminator> | undefined;
  readonly branchState: unknown;
}
/**
 * Options for customizing error messages in the {@link conditional} combinator.
 * @since 0.8.0
 */
interface ConditionalErrorOptions {
  /**
   * Custom error message when branch parser fails.
   * Receives the discriminator value for context.
   */
  branchError?: (discriminatorValue: string | undefined, error: Message) => Message;
  /**
   * Custom error message for no matching input.
   */
  noMatch?: Message | ((context: NoMatchContext) => Message);
}
/**
 * Options for customizing the {@link conditional} combinator behavior.
 * @since 0.8.0
 */
interface ConditionalOptions {
  /**
   * Custom error messages.
   */
  errors?: ConditionalErrorOptions;
}
/**
 * Helper type to infer result type without default branch.
 * @internal
 */
type ConditionalResultWithoutDefault<TDiscriminator extends string, TBranches extends Record<string, Parser<Mode, unknown, unknown>>> = { [K in keyof TBranches & string]: readonly [K, InferValue<TBranches[K]>] }[keyof TBranches & string];
/**
 * Helper type to infer result type with default branch.
 * @internal
 */
type ConditionalResultWithDefault<TDiscriminator extends string, TBranches extends Record<string, Parser<Mode, unknown, unknown>>, TDefault extends Parser<Mode, unknown, unknown>> = ConditionalResultWithoutDefault<TDiscriminator, TBranches> | readonly [undefined, InferValue<TDefault>];
/**
 * Creates a conditional parser without a default branch.
 * The discriminator option is required; parsing fails if not provided.
 *
 * @template TDiscriminator The string literal union type of discriminator values.
 * @template TBranches Record mapping discriminator values to branch parsers.
 * @param discriminator Parser for the discriminator option (typically using choice()).
 * @param branches Object mapping each discriminator value to its branch parser.
 * @returns A parser that produces a tuple `[discriminatorValue, branchResult]`.
 * @since 0.8.0
 */
declare function conditional<TDiscriminator extends string, TBranches extends { [K in TDiscriminator]: Parser<Mode, unknown, unknown> }, TD extends Parser<Mode, TDiscriminator, unknown>>(discriminator: TD, branches: TBranches): Parser<CombineModes<readonly [ExtractMode<TD>, ...{ [K in keyof TBranches]: ExtractMode<TBranches[K]> }[keyof TBranches][]]>, ConditionalResultWithoutDefault<TDiscriminator, TBranches>, ConditionalState<TDiscriminator>>;
/**
 * Creates a conditional parser with a default branch.
 * The default branch is used when the discriminator option is not provided.
 *
 * @template TDiscriminator The string literal union type of discriminator values.
 * @template TBranches Record mapping discriminator values to branch parsers.
 * @template TDefault The default branch parser type.
 * @param discriminator Parser for the discriminator option (typically using choice()).
 * @param branches Object mapping each discriminator value to its branch parser.
 * @param defaultBranch Parser to use when discriminator is not provided.
 * @param options Optional configuration for error messages.
 * @returns A parser that produces a tuple `[discriminatorValue | undefined, branchResult]`.
 * @since 0.8.0
 */
declare function conditional<TDiscriminator extends string, TBranches extends { [K in TDiscriminator]: Parser<Mode, unknown, unknown> }, TDefault extends Parser<Mode, unknown, unknown>, TD extends Parser<Mode, TDiscriminator, unknown>>(discriminator: TD, branches: TBranches, defaultBranch: TDefault, options?: ConditionalOptions): Parser<CombineModes<readonly [ExtractMode<TD>, ExtractMode<TDefault>, ...{ [K in keyof TBranches]: ExtractMode<TBranches[K]> }[keyof TBranches][]]>, ConditionalResultWithDefault<TDiscriminator, TBranches, TDefault>, ConditionalState<TDiscriminator>>;
//#endregion
export { ConditionalErrorOptions, ConditionalOptions, DuplicateOptionError, LongestMatchErrorOptions, LongestMatchOptions, MergeOptions, NoMatchContext, ObjectErrorOptions, ObjectOptions, OrErrorOptions, OrOptions, TupleOptions, concat, conditional, group, longestMatch, merge, object, or, tuple };