
//#region src/message.ts
/**
* Creates a structured message with template strings and values.
*
* This function allows creating messages where specific values can be
* highlighted or styled differently when displayed to the user.
*
* @example
* ```typescript
* const error = message`Expected number between ${min} and ${max}, got ${value}`;
* const concat = message`${optionName("--age")}: ${error}`;
* ```
*
* @param message Template strings array (from template literal).
* @param values Values to be interpolated into the template.
* @returns A structured Message object.
*/
function message(message$1, ...values$1) {
	const messageTerms = [];
	for (let i = 0; i < message$1.length; i++) {
		if (message$1[i] !== "") messageTerms.push({
			type: "text",
			text: message$1[i]
		});
		if (i >= values$1.length) continue;
		const value$1 = values$1[i];
		if (typeof value$1 === "string") messageTerms.push({
			type: "value",
			value: value$1
		});
		else if (Array.isArray(value$1)) messageTerms.push(...value$1);
		else if (typeof value$1 === "object" && value$1 != null && "type" in value$1) messageTerms.push(value$1);
		else throw new TypeError(`Invalid value type in message: ${typeof value$1}.`);
	}
	return messageTerms;
}
/**
* Creates a {@link MessageTerm} for plain text.  Usually used for
* dynamically generated messages.
* @param text The plain text to be included in the message.
* @returns A {@link MessageTerm} representing the plain text.
*/
function text(text$1) {
	return {
		type: "text",
		text: text$1
	};
}
/**
* Creates a {@link MessageTerm} for an option name.
* @param name The name of the option, which can be a short or long option name.
*             For example, `"-f"` or `"--foo"`.
* @returns A {@link MessageTerm} representing the option name.
*/
function optionName(name) {
	return {
		type: "optionName",
		optionName: name
	};
}
/**
* Creates a {@link MessageTerm} for a list of option names.
* @param names The list of option names, which can include both short and long
*              option names. For example, `["--foo", "--bar"]`.
* @returns A {@link MessageTerm} representing the list of option names.
*/
function optionNames(names) {
	return {
		type: "optionNames",
		optionNames: names
	};
}
/**
* Creates a {@link MessageTerm} for a metavariable.
* @param metavar The metavariable name, which is a string that represents
*                a variable in the message. For example, `"VALUE"` or
*                `"ARG"`.
* @returns A {@link MessageTerm} representing the metavariable.
*/
function metavar(metavar$1) {
	return {
		type: "metavar",
		metavar: metavar$1
	};
}
/**
* Creates a {@link MessageTerm} for a single value.  However, you usually
* don't need to use this function directly, as {@link message} string template
* will automatically create a {@link MessageTerm} for a value when
* you use a string in a template literal.
* @param value The value, which can be any string representation of a value.
*              For example, `"42"` or `"hello"`.
* @returns A {@link MessageTerm} representing the value.
*/
function value(value$1) {
	return {
		type: "value",
		value: value$1
	};
}
/**
* Creates a {@link MessageTerm} for a list of consecutive values.
* @param values The list of consecutive values, which can include multiple
*               string representations of consecutive values.
*               For example, `["42", "hello"]`.
* @returns A {@link MessageTerm} representing the list of values.
*/
function values(values$1) {
	return {
		type: "values",
		values: values$1
	};
}
/**
* Creates a {@link MessageTerm} for an environment variable.
* @param envVar The environment variable name, which is a string that represents
*               an environment variable. For example, `"PATH"` or `"API_URL"`.
* @returns A {@link MessageTerm} representing the environment variable.
* @since 0.5.0
*/
function envVar(envVar$1) {
	return {
		type: "envVar",
		envVar: envVar$1
	};
}
/**
* Creates a {@link MessageTerm} for a command-line example.
* @param commandLine The command-line string, which can be a complete command
*                    with arguments. For example,
*                    `"myapp completion bash > myapp-completion.bash"`.
* @returns A {@link MessageTerm} representing the command-line example.
* @since 0.6.0
*/
function commandLine(commandLine$1) {
	return {
		type: "commandLine",
		commandLine: commandLine$1
	};
}
/**
* Creates a {@link Message} for a formatted list of values using the
* `Intl.ListFormat` API.  This is useful for displaying choice lists
* in error messages with proper locale-aware formatting.
*
* Each value in the list becomes a separate value term, and the separators
* (commas, "and", "or", etc.) become text terms.  This allows each value
* to be styled independently while respecting the locale's list formatting
* conventions.
*
* @example
* ```typescript
* // English conjunction (default): "error", "warn", and "info"
* const msg1 = message`Expected one of ${valueSet(["error", "warn", "info"])}.`;
*
* // English disjunction: "error", "warn", or "info"
* const msg2 = message`Expected ${
*   valueSet(["error", "warn", "info"], { type: "disjunction" })
* }.`;
*
* // Korean disjunction: "error", "warn" 또는 "info"
* const msg3 = message`${
*   valueSet(["error", "warn", "info"], { locale: "ko", type: "disjunction" })
* } 중 하나여야 합니다.`;
* ```
*
* @param values The list of values to format.
* @param options Optional formatting options including locale and list type.
* @returns A {@link Message} with alternating value and text terms.
* @since 0.9.0
*/
function valueSet(values$1, options) {
	if (values$1.length === 0) return [];
	const formatter = new Intl.ListFormat(options?.locale, {
		type: options?.type,
		style: options?.style
	});
	const parts = formatter.formatToParts(values$1);
	const result = [];
	for (const part of parts) if (part.type === "element") result.push({
		type: "value",
		value: part.value
	});
	else result.push({
		type: "text",
		text: part.value
	});
	return result;
}
/**
* Formats a {@link Message} into a human-readable string for
* the terminal.
* @param msg The message to format, which is an array of
*              {@link MessageTerm} objects.
* @param options Optional formatting options to customize the output.
* @returns A formatted string representation of the message.
*/
function formatMessage(msg, options = {}) {
	const colorConfig = options.colors ?? false;
	const useColors = typeof colorConfig === "boolean" ? colorConfig : true;
	const resetSuffix = typeof colorConfig === "object" ? colorConfig.resetSuffix ?? "" : "";
	const useQuotes = options.quotes ?? true;
	const resetSequence = `\x1b[0m${resetSuffix}`;
	function* stream() {
		const wordPattern = /\s*\S+\s*/g;
		for (const term of msg) if (term.type === "text") if (term.text.includes("\n\n")) {
			const paragraphs = term.text.split(/\n\n+/);
			for (let paragraphIndex = 0; paragraphIndex < paragraphs.length; paragraphIndex++) {
				if (paragraphIndex > 0) yield {
					text: "\n",
					width: -1
				};
				const paragraph = paragraphs[paragraphIndex].replace(/\n/g, " ");
				wordPattern.lastIndex = 0;
				while (true) {
					const match = wordPattern.exec(paragraph);
					if (match == null) break;
					yield {
						text: match[0],
						width: match[0].length
					};
				}
			}
		} else {
			const normalizedText = term.text.replace(/\n/g, " ");
			if (normalizedText.trim() === "" && normalizedText.length > 0) yield {
				text: " ",
				width: 1
			};
			else {
				wordPattern.lastIndex = 0;
				while (true) {
					const match = wordPattern.exec(normalizedText);
					if (match == null) break;
					yield {
						text: match[0],
						width: match[0].length
					};
				}
			}
		}
		else if (term.type === "optionName") {
			const name = useQuotes ? `\`${term.optionName}\`` : term.optionName;
			yield {
				text: useColors ? `\x1b[3m${name}${resetSequence}` : name,
				width: name.length
			};
		} else if (term.type === "optionNames") {
			const names = term.optionNames.map((name) => useQuotes ? `\`${name}\`` : name);
			let i = 0;
			for (const name of names) {
				if (i > 0) yield {
					text: "/",
					width: 1
				};
				yield {
					text: useColors ? `\x1b[3m${name}${resetSequence}` : name,
					width: name.length
				};
				i++;
			}
		} else if (term.type === "metavar") {
			const metavar$1 = useQuotes ? `\`${term.metavar}\`` : term.metavar;
			yield {
				text: useColors ? `\x1b[1m${metavar$1}${resetSequence}` : metavar$1,
				width: metavar$1.length
			};
		} else if (term.type === "value") {
			const value$1 = useQuotes ? `${JSON.stringify(term.value)}` : term.value;
			yield {
				text: useColors ? `\x1b[32m${value$1}${resetSequence}` : value$1,
				width: value$1.length
			};
		} else if (term.type === "values") for (let i = 0; i < term.values.length; i++) {
			if (i > 0) yield {
				text: " ",
				width: 1
			};
			const value$1 = useQuotes ? JSON.stringify(term.values[i]) : term.values[i];
			yield {
				text: useColors ? i <= 0 ? `\x1b[32m${value$1}` : i + 1 >= term.values.length ? `${value$1}${resetSequence}` : value$1 : value$1,
				width: value$1.length
			};
		}
		else if (term.type === "envVar") {
			const envVar$1 = useQuotes ? `\`${term.envVar}\`` : term.envVar;
			yield {
				text: useColors ? `\x1b[1;4m${envVar$1}${resetSequence}` : envVar$1,
				width: envVar$1.length
			};
		} else if (term.type === "commandLine") {
			const cmd = useQuotes ? `\`${term.commandLine}\`` : term.commandLine;
			yield {
				text: useColors ? `\x1b[36m${cmd}${resetSequence}` : cmd,
				width: cmd.length
			};
		} else throw new TypeError(`Invalid MessageTerm type: ${term["type"]}.`);
	}
	let output = "";
	let totalWidth = 0;
	for (const { text: text$1, width } of stream()) {
		if (width === -1) {
			output += text$1;
			totalWidth = 0;
			continue;
		}
		if (options.maxWidth != null && totalWidth + width > options.maxWidth) {
			output += "\n";
			totalWidth = 0;
		}
		output += text$1;
		totalWidth += width;
	}
	return output;
}

//#endregion
exports.commandLine = commandLine;
exports.envVar = envVar;
exports.formatMessage = formatMessage;
exports.message = message;
exports.metavar = metavar;
exports.optionName = optionName;
exports.optionNames = optionNames;
exports.text = text;
exports.value = value;
exports.valueSet = valueSet;
exports.values = values;