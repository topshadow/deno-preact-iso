import { message, text, valueSet } from "./message.js";
import { ensureNonEmptyString, isNonEmptyString } from "./nonempty.js";

//#region src/valueparser.ts
/**
* A predicate function that checks if an object is a {@link ValueParser}.
* @param object The object to check.
* @return `true` if the object is a {@link ValueParser}, `false` otherwise.
*/
function isValueParser(object) {
	return typeof object === "object" && object != null && "$mode" in object && (object.$mode === "sync" || object.$mode === "async") && "metavar" in object && typeof object.metavar === "string" && "parse" in object && typeof object.parse === "function" && "format" in object && typeof object.format === "function";
}
/**
* Implementation of the choice parser for both string and number types.
*/
function choice(choices, options = {}) {
	const metavar = options.metavar ?? "TYPE";
	ensureNonEmptyString(metavar);
	const isNumberChoice = choices.length > 0 && typeof choices[0] === "number";
	if (isNumberChoice) {
		const numberChoices = choices;
		const numberOptions = options;
		return {
			$mode: "sync",
			metavar,
			parse(input) {
				const parsed = Number(input);
				if (Number.isNaN(parsed)) return {
					success: false,
					error: formatNumberChoiceError(input, numberChoices, numberOptions)
				};
				const index = numberChoices.indexOf(parsed);
				if (index < 0) return {
					success: false,
					error: formatNumberChoiceError(input, numberChoices, numberOptions)
				};
				return {
					success: true,
					value: numberChoices[index]
				};
			},
			format(value) {
				return String(value);
			},
			suggest(prefix) {
				return numberChoices.map((value) => String(value)).filter((valueStr) => valueStr.startsWith(prefix)).map((valueStr) => ({
					kind: "literal",
					text: valueStr
				}));
			}
		};
	}
	const stringChoices = choices;
	const stringOptions = options;
	const normalizedValues = stringOptions.caseInsensitive ? stringChoices.map((v) => v.toLowerCase()) : stringChoices;
	return {
		$mode: "sync",
		metavar,
		parse(input) {
			const normalizedInput = stringOptions.caseInsensitive ? input.toLowerCase() : input;
			const index = normalizedValues.indexOf(normalizedInput);
			if (index < 0) return {
				success: false,
				error: formatStringChoiceError(input, stringChoices, stringOptions)
			};
			return {
				success: true,
				value: stringChoices[index]
			};
		},
		format(value) {
			return String(value);
		},
		suggest(prefix) {
			const normalizedPrefix = stringOptions.caseInsensitive ? prefix.toLowerCase() : prefix;
			return stringChoices.filter((value) => {
				const normalizedValue = stringOptions.caseInsensitive ? value.toLowerCase() : value;
				return normalizedValue.startsWith(normalizedPrefix);
			}).map((value) => ({
				kind: "literal",
				text: value
			}));
		}
	};
}
/**
* Formats error message for string choice parser.
*/
function formatStringChoiceError(input, choices, options) {
	if (options.errors?.invalidChoice) return typeof options.errors.invalidChoice === "function" ? options.errors.invalidChoice(input, choices) : options.errors.invalidChoice;
	return formatDefaultChoiceError(input, choices);
}
/**
* Formats error message for number choice parser.
*/
function formatNumberChoiceError(input, choices, options) {
	if (options.errors?.invalidChoice) return typeof options.errors.invalidChoice === "function" ? options.errors.invalidChoice(input, choices) : options.errors.invalidChoice;
	return formatDefaultChoiceError(input, choices);
}
/**
* Formats default error message for choice parser.
*/
function formatDefaultChoiceError(input, choices) {
	const choiceStrings = choices.map((c) => String(c));
	return message`Expected one of ${valueSet(choiceStrings, { locale: "en-US" })}, but got ${input}.`;
}
/**
* Creates a {@link ValueParser} for strings.
*
* This parser validates that the input is a string and optionally checks
* if it matches a specified regular expression pattern.
*
* **Security note**: When using the `pattern` option with user-defined or
* complex patterns, be aware of potential Regular Expression Denial of Service
* (ReDoS) attacks. See {@link StringOptions.pattern} for more details.
*
* @param options Configuration options for the string parser.
* @returns A {@link ValueParser} that parses strings according to the
*          specified options.
*/
function string(options = {}) {
	const metavar = options.metavar ?? "STRING";
	ensureNonEmptyString(metavar);
	return {
		$mode: "sync",
		metavar,
		parse(input) {
			if (options.pattern != null && !options.pattern.test(input)) return {
				success: false,
				error: options.errors?.patternMismatch ? typeof options.errors.patternMismatch === "function" ? options.errors.patternMismatch(input, options.pattern) : options.errors.patternMismatch : message`Expected a string matching pattern ${text(options.pattern.source)}, but got ${input}.`
			};
			return {
				success: true,
				value: input
			};
		},
		format(value) {
			return value;
		}
	};
}
/**
* Creates a ValueParser for parsing integer values from strings.
*
* This function provides two modes of operation:
*
* - Regular mode: Returns JavaScript numbers
*   (safe up to `Number.MAX_SAFE_INTEGER`)
* - `bigint` mode: Returns `bigint` values for arbitrarily large integers
*
* The parser validates that the input is a valid integer and optionally
* enforces minimum and maximum value constraints.
*
* @example
* ```typescript
* // Create a parser for regular integers
* const portParser = integer({ min: 1, max: 0xffff });
*
* // Create a parser for BigInt values
* const bigIntParser = integer({ type: "bigint", min: 0n });
*
* // Use the parser
* const result = portParser.parse("8080");
* if (result.success) {
*   console.log(`Port: ${result.value}`);
* } else {
*   console.error(result.error);
* }
* ```
*
* @param options Configuration options specifying the type and constraints.
* @returns A {@link ValueParser} that converts string input to the specified
*          integer type.
*/
function integer(options) {
	if (options?.type === "bigint") {
		const metavar$1 = options.metavar ?? "INTEGER";
		ensureNonEmptyString(metavar$1);
		return {
			$mode: "sync",
			metavar: metavar$1,
			parse(input) {
				let value;
				try {
					value = BigInt(input);
				} catch (e) {
					if (e instanceof SyntaxError) return {
						success: false,
						error: options.errors?.invalidInteger ? typeof options.errors.invalidInteger === "function" ? options.errors.invalidInteger(input) : options.errors.invalidInteger : message`Expected a valid integer, but got ${input}.`
					};
					throw e;
				}
				if (options.min != null && value < options.min) return {
					success: false,
					error: options.errors?.belowMinimum ? typeof options.errors.belowMinimum === "function" ? options.errors.belowMinimum(value, options.min) : options.errors.belowMinimum : message`Expected a value greater than or equal to ${text(options.min.toLocaleString("en"))}, but got ${input}.`
				};
				else if (options.max != null && value > options.max) return {
					success: false,
					error: options.errors?.aboveMaximum ? typeof options.errors.aboveMaximum === "function" ? options.errors.aboveMaximum(value, options.max) : options.errors.aboveMaximum : message`Expected a value less than or equal to ${text(options.max.toLocaleString("en"))}, but got ${input}.`
				};
				return {
					success: true,
					value
				};
			},
			format(value) {
				return value.toString();
			}
		};
	}
	const metavar = options?.metavar ?? "INTEGER";
	ensureNonEmptyString(metavar);
	return {
		$mode: "sync",
		metavar,
		parse(input) {
			if (!input.match(/^-?\d+$/)) return {
				success: false,
				error: options?.errors?.invalidInteger ? typeof options.errors.invalidInteger === "function" ? options.errors.invalidInteger(input) : options.errors.invalidInteger : message`Expected a valid integer, but got ${input}.`
			};
			const value = Number.parseInt(input);
			if (options?.min != null && value < options.min) return {
				success: false,
				error: options.errors?.belowMinimum ? typeof options.errors.belowMinimum === "function" ? options.errors.belowMinimum(value, options.min) : options.errors.belowMinimum : message`Expected a value greater than or equal to ${text(options.min.toLocaleString("en"))}, but got ${input}.`
			};
			else if (options?.max != null && value > options.max) return {
				success: false,
				error: options.errors?.aboveMaximum ? typeof options.errors.aboveMaximum === "function" ? options.errors.aboveMaximum(value, options.max) : options.errors.aboveMaximum : message`Expected a value less than or equal to ${text(options.max.toLocaleString("en"))}, but got ${input}.`
			};
			return {
				success: true,
				value
			};
		},
		format(value) {
			return value.toString();
		}
	};
}
/**
* Creates a {@link ValueParser} for floating-point numbers.
*
* This parser validates that the input is a valid floating-point number
* and optionally enforces minimum and maximum value constraints.
* @param options Configuration options for the float parser.
* @returns A {@link ValueParser} that parses strings into floating-point
*          numbers.
*/
function float(options = {}) {
	const floatRegex = /^[+-]?(?:(?:\d+\.?\d*)|(?:\d*\.\d+))(?:[eE][+-]?\d+)?$/;
	const metavar = options.metavar ?? "NUMBER";
	ensureNonEmptyString(metavar);
	return {
		$mode: "sync",
		metavar,
		parse(input) {
			let value;
			const lowerInput = input.toLowerCase();
			if (lowerInput === "nan" && options.allowNaN) value = NaN;
			else if ((lowerInput === "infinity" || lowerInput === "+infinity") && options.allowInfinity) value = Infinity;
			else if (lowerInput === "-infinity" && options.allowInfinity) value = -Infinity;
			else if (floatRegex.test(input)) {
				value = Number(input);
				if (Number.isNaN(value)) return {
					success: false,
					error: options.errors?.invalidNumber ? typeof options.errors.invalidNumber === "function" ? options.errors.invalidNumber(input) : options.errors.invalidNumber : message`Expected a valid number, but got ${input}.`
				};
			} else return {
				success: false,
				error: options.errors?.invalidNumber ? typeof options.errors.invalidNumber === "function" ? options.errors.invalidNumber(input) : options.errors.invalidNumber : message`Expected a valid number, but got ${input}.`
			};
			if (options.min != null && value < options.min) return {
				success: false,
				error: options.errors?.belowMinimum ? typeof options.errors.belowMinimum === "function" ? options.errors.belowMinimum(value, options.min) : options.errors.belowMinimum : message`Expected a value greater than or equal to ${text(options.min.toLocaleString("en"))}, but got ${input}.`
			};
			else if (options.max != null && value > options.max) return {
				success: false,
				error: options.errors?.aboveMaximum ? typeof options.errors.aboveMaximum === "function" ? options.errors.aboveMaximum(value, options.max) : options.errors.aboveMaximum : message`Expected a value less than or equal to ${text(options.max.toLocaleString("en"))}, but got ${input}.`
			};
			return {
				success: true,
				value
			};
		},
		format(value) {
			return value.toString();
		}
	};
}
/**
* Creates a {@link ValueParser} for URL values.
*
* This parser validates that the input is a well-formed URL and optionally
* restricts the allowed protocols. The parsed result is a JavaScript `URL`
* object.
* @param options Configuration options for the URL parser.
* @returns A {@link ValueParser} that converts string input to `URL` objects.
*/
function url(options = {}) {
	const allowedProtocols = options.allowedProtocols?.map((p) => p.toLowerCase());
	const metavar = options.metavar ?? "URL";
	ensureNonEmptyString(metavar);
	return {
		$mode: "sync",
		metavar,
		parse(input) {
			if (!URL.canParse(input)) return {
				success: false,
				error: options.errors?.invalidUrl ? typeof options.errors.invalidUrl === "function" ? options.errors.invalidUrl(input) : options.errors.invalidUrl : message`Invalid URL: ${input}.`
			};
			const url$1 = new URL(input);
			if (allowedProtocols != null && !allowedProtocols.includes(url$1.protocol)) return {
				success: false,
				error: options.errors?.disallowedProtocol ? typeof options.errors.disallowedProtocol === "function" ? options.errors.disallowedProtocol(url$1.protocol, options.allowedProtocols) : options.errors.disallowedProtocol : message`URL protocol ${url$1.protocol} is not allowed. Allowed protocols: ${allowedProtocols.join(", ")}.`
			};
			return {
				success: true,
				value: url$1
			};
		},
		format(value) {
			return value.href;
		},
		*suggest(prefix) {
			if (allowedProtocols && prefix.length > 0 && !prefix.includes("://")) for (const protocol of allowedProtocols) {
				const cleanProtocol = protocol.replace(/:+$/, "");
				if (cleanProtocol.startsWith(prefix.toLowerCase())) yield {
					kind: "literal",
					text: `${cleanProtocol}://`
				};
			}
		}
	};
}
/**
* Creates a {@link ValueParser} for locale values.
*
* This parser validates that the input is a well-formed locale identifier
* according to the Unicode Locale Identifier standard (BCP 47).
* The parsed result is a JavaScript `Intl.Locale` object.
* @param options Configuration options for the locale parser.
* @returns A {@link ValueParser} that converts string input to `Intl.Locale`
*          objects.
*/
function locale(options = {}) {
	const metavar = options.metavar ?? "LOCALE";
	ensureNonEmptyString(metavar);
	return {
		$mode: "sync",
		metavar,
		parse(input) {
			let locale$1;
			try {
				locale$1 = new Intl.Locale(input);
			} catch (e) {
				if (e instanceof RangeError) return {
					success: false,
					error: options.errors?.invalidLocale ? typeof options.errors.invalidLocale === "function" ? options.errors.invalidLocale(input) : options.errors.invalidLocale : message`Invalid locale: ${input}.`
				};
				throw e;
			}
			return {
				success: true,
				value: locale$1
			};
		},
		format(value) {
			return value.baseName;
		},
		*suggest(prefix) {
			const commonLocales = [
				"en",
				"en-US",
				"en-GB",
				"en-CA",
				"en-AU",
				"en-NZ",
				"en-IE",
				"en-ZA",
				"en-IN",
				"es",
				"es-ES",
				"es-MX",
				"es-AR",
				"es-CL",
				"es-CO",
				"es-PE",
				"es-VE",
				"es-EC",
				"es-GT",
				"es-CU",
				"es-BO",
				"es-DO",
				"es-HN",
				"es-PY",
				"es-SV",
				"es-NI",
				"es-CR",
				"es-PA",
				"es-UY",
				"es-PR",
				"fr",
				"fr-FR",
				"fr-CA",
				"fr-BE",
				"fr-CH",
				"fr-LU",
				"fr-MC",
				"de",
				"de-DE",
				"de-AT",
				"de-CH",
				"de-BE",
				"de-LU",
				"de-LI",
				"it",
				"it-IT",
				"it-CH",
				"it-SM",
				"it-VA",
				"pt",
				"pt-BR",
				"pt-PT",
				"pt-AO",
				"pt-MZ",
				"pt-CV",
				"pt-GW",
				"pt-ST",
				"pt-TL",
				"ru",
				"ru-RU",
				"ru-BY",
				"ru-KZ",
				"ru-KG",
				"ru-MD",
				"uk",
				"uk-UA",
				"be",
				"be-BY",
				"bg",
				"bg-BG",
				"cs",
				"cs-CZ",
				"sk",
				"sk-SK",
				"sl",
				"sl-SI",
				"hr",
				"hr-HR",
				"sr",
				"sr-RS",
				"mk",
				"mk-MK",
				"ja",
				"ja-JP",
				"ko",
				"ko-KR",
				"zh",
				"zh-CN",
				"zh-TW",
				"zh-HK",
				"zh-SG",
				"zh-MO",
				"ar",
				"ar-SA",
				"ar-AE",
				"ar-BH",
				"ar-DZ",
				"ar-EG",
				"ar-IQ",
				"ar-JO",
				"ar-KW",
				"ar-LB",
				"ar-LY",
				"ar-MA",
				"ar-OM",
				"ar-QA",
				"ar-SY",
				"ar-TN",
				"ar-YE",
				"hi",
				"hi-IN",
				"bn",
				"bn-BD",
				"bn-IN",
				"ur",
				"ur-PK",
				"ta",
				"ta-IN",
				"te",
				"te-IN",
				"mr",
				"mr-IN",
				"gu",
				"gu-IN",
				"kn",
				"kn-IN",
				"ml",
				"ml-IN",
				"pa",
				"pa-IN",
				"tr",
				"tr-TR",
				"tr-CY",
				"pl",
				"pl-PL",
				"nl",
				"nl-NL",
				"nl-BE",
				"nl-SR",
				"sv",
				"sv-SE",
				"sv-FI",
				"da",
				"da-DK",
				"no",
				"no-NO",
				"nb",
				"nb-NO",
				"nn",
				"nn-NO",
				"fi",
				"fi-FI",
				"is",
				"is-IS",
				"el",
				"el-GR",
				"el-CY",
				"hu",
				"hu-HU",
				"ro",
				"ro-RO",
				"et",
				"et-EE",
				"lv",
				"lv-LV",
				"lt",
				"lt-LT",
				"mt",
				"mt-MT",
				"ga",
				"ga-IE",
				"cy",
				"cy-GB",
				"eu",
				"eu-ES",
				"ca",
				"ca-ES",
				"ca-AD",
				"th",
				"th-TH",
				"vi",
				"vi-VN",
				"id",
				"id-ID",
				"ms",
				"ms-MY",
				"ms-BN",
				"ms-SG",
				"tl",
				"tl-PH",
				"km",
				"km-KH",
				"my",
				"my-MM",
				"lo",
				"lo-LA",
				"si",
				"si-LK",
				"ne",
				"ne-NP",
				"sw",
				"sw-TZ",
				"sw-KE",
				"am",
				"am-ET",
				"ha",
				"ha-NG",
				"yo",
				"yo-NG",
				"ig",
				"ig-NG",
				"zu",
				"zu-ZA",
				"xh",
				"xh-ZA",
				"af",
				"af-ZA",
				"he",
				"he-IL",
				"fa",
				"fa-IR",
				"fa-AF"
			];
			for (const locale$1 of commonLocales) if (locale$1.toLowerCase().startsWith(prefix.toLowerCase())) yield {
				kind: "literal",
				text: locale$1
			};
		}
	};
}
/**
* Creates a {@link ValueParser} for UUID values.
*
* This parser validates that the input is a well-formed UUID string in the
* standard format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx` where each `x`
* is a hexadecimal digit.  The parser can optionally restrict to specific
* UUID versions.
*
* @param options Configuration options for the UUID parser.
* @returns A {@link ValueParser} that converts string input to {@link Uuid}
*          strings.
*/
function uuid(options = {}) {
	const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
	const metavar = options.metavar ?? "UUID";
	ensureNonEmptyString(metavar);
	return {
		$mode: "sync",
		metavar,
		parse(input) {
			if (!uuidRegex.test(input)) return {
				success: false,
				error: options.errors?.invalidUuid ? typeof options.errors.invalidUuid === "function" ? options.errors.invalidUuid(input) : options.errors.invalidUuid : message`Expected a valid UUID in format ${"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"}, but got ${input}.`
			};
			if (options.allowedVersions != null && options.allowedVersions.length > 0) {
				const versionChar = input.charAt(14);
				const version = parseInt(versionChar, 16);
				if (!options.allowedVersions.includes(version)) return {
					success: false,
					error: options.errors?.disallowedVersion ? typeof options.errors.disallowedVersion === "function" ? options.errors.disallowedVersion(version, options.allowedVersions) : options.errors.disallowedVersion : (() => {
						let expectedVersions = message``;
						let i = 0;
						for (const v of options.allowedVersions) {
							expectedVersions = i < 1 ? message`${expectedVersions}${v.toLocaleString("en")}` : i + 1 >= options.allowedVersions.length ? message`${expectedVersions}, or ${v.toLocaleString("en")}` : message`${expectedVersions}, ${v.toLocaleString("en")}`;
							i++;
						}
						return message`Expected UUID version ${expectedVersions}, but got version ${version.toLocaleString("en")}.`;
					})()
				};
			}
			return {
				success: true,
				value: input
			};
		},
		format(value) {
			return value;
		}
	};
}

//#endregion
export { choice, ensureNonEmptyString, float, integer, isNonEmptyString, isValueParser, locale, string, url, uuid };