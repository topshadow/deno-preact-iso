import { formatMessage, message, text } from "./message.js";

//#region src/modifiers.ts
/**
* Internal helper for optional-style parsing logic shared by optional()
* and withDefault(). Handles the common pattern of:
* - Unwrapping optional state to inner parser state
* - Detecting if inner parser actually matched (state changed or no consumption)
* - Returning success with undefined state when inner parser fails without consuming
* @internal
*/
function parseOptionalStyleSync(context, parser) {
	const innerState = typeof context.state === "undefined" ? parser.initialState : context.state[0];
	const result = parser.parse({
		...context,
		state: innerState
	});
	return processOptionalStyleResult(result, innerState, context);
}
/**
* Internal async helper for optional-style parsing logic.
* @internal
*/
async function parseOptionalStyleAsync(context, parser) {
	const innerState = typeof context.state === "undefined" ? parser.initialState : context.state[0];
	const result = await parser.parse({
		...context,
		state: innerState
	});
	return processOptionalStyleResult(result, innerState, context);
}
/**
* Internal helper to process optional-style parse results.
* @internal
*/
function processOptionalStyleResult(result, innerState, context) {
	if (result.success) {
		if (result.next.state !== innerState || result.consumed.length === 0) return {
			success: true,
			next: {
				...result.next,
				state: [result.next.state]
			},
			consumed: result.consumed
		};
		return {
			success: true,
			next: {
				...result.next,
				state: context.state
			},
			consumed: result.consumed
		};
	}
	if (result.consumed === 0) return {
		success: true,
		next: context,
		consumed: []
	};
	return result;
}
/**
* Creates a parser that makes another parser optional, allowing it to succeed
* without consuming input if the wrapped parser fails to match.
* If the wrapped parser succeeds, this returns its value.
* If the wrapped parser fails, this returns `undefined` without consuming input.
* @template M The execution mode of the parser.
* @template TValue The type of the value returned by the wrapped parser.
* @template TState The type of the state used by the wrapped parser.
* @param parser The {@link Parser} to make optional.
* @returns A {@link Parser} that produces either the result of the wrapped parser
*          or `undefined` if the wrapped parser fails to match.
*/
function optional(parser) {
	const syncParser = parser;
	const isAsync = parser.$mode === "async";
	function* suggestSync(context, prefix) {
		const innerState = typeof context.state === "undefined" ? syncParser.initialState : context.state[0];
		yield* syncParser.suggest({
			...context,
			state: innerState
		}, prefix);
	}
	async function* suggestAsync(context, prefix) {
		const innerState = typeof context.state === "undefined" ? syncParser.initialState : context.state[0];
		const suggestions = parser.suggest({
			...context,
			state: innerState
		}, prefix);
		for await (const s of suggestions) yield s;
	}
	return {
		$mode: parser.$mode,
		$valueType: [],
		$stateType: [],
		priority: parser.priority,
		usage: [{
			type: "optional",
			terms: parser.usage
		}],
		initialState: void 0,
		parse(context) {
			if (isAsync) return parseOptionalStyleAsync(context, parser);
			return parseOptionalStyleSync(context, syncParser);
		},
		complete(state) {
			if (typeof state === "undefined") return {
				success: true,
				value: void 0
			};
			if (!isAsync) return syncParser.complete(state[0]);
			return parser.complete(state[0]);
		},
		suggest(context, prefix) {
			if (isAsync) return suggestAsync(context, prefix);
			return suggestSync(context, prefix);
		},
		getDocFragments(state, defaultValue) {
			const innerState = state.kind === "unavailable" ? { kind: "unavailable" } : state.state === void 0 ? { kind: "unavailable" } : {
				kind: "available",
				state: state.state[0]
			};
			return syncParser.getDocFragments(innerState, defaultValue);
		}
	};
}
/**
* Error type for structured error messages in {@link withDefault} default value callbacks.
* Unlike regular errors that only support string messages, this error type accepts
* a {@link Message} object that supports rich formatting, colors, and structured content.
*
* @example
* ```typescript
* withDefault(option("--url", url()), () => {
*   if (!process.env.INSTANCE_URL) {
*     throw new WithDefaultError(
*       message`Environment variable ${envVar("INSTANCE_URL")} is not set.`
*     );
*   }
*   return new URL(process.env.INSTANCE_URL);
* })
* ```
*
* @since 0.5.0
*/
var WithDefaultError = class extends Error {
	/**
	* The structured message associated with this error.
	*/
	errorMessage;
	/**
	* Creates a new WithDefaultError with a structured message.
	* @param message The structured {@link Message} describing the error.
	*/
	constructor(message$1) {
		super(formatMessage(message$1));
		this.errorMessage = message$1;
		this.name = "WithDefaultError";
	}
};
function withDefault(parser, defaultValue, options) {
	const syncParser = parser;
	const isAsync = parser.$mode === "async";
	function* suggestSync(context, prefix) {
		const innerState = typeof context.state === "undefined" ? syncParser.initialState : context.state[0];
		yield* syncParser.suggest({
			...context,
			state: innerState
		}, prefix);
	}
	async function* suggestAsync(context, prefix) {
		const innerState = typeof context.state === "undefined" ? syncParser.initialState : context.state[0];
		const suggestions = parser.suggest({
			...context,
			state: innerState
		}, prefix);
		for await (const s of suggestions) yield s;
	}
	return {
		$mode: parser.$mode,
		$valueType: [],
		$stateType: [],
		priority: parser.priority,
		usage: [{
			type: "optional",
			terms: parser.usage
		}],
		initialState: void 0,
		parse(context) {
			if (isAsync) return parseOptionalStyleAsync(context, parser);
			return parseOptionalStyleSync(context, syncParser);
		},
		complete(state) {
			if (typeof state === "undefined") try {
				const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
				return {
					success: true,
					value
				};
			} catch (error) {
				return {
					success: false,
					error: error instanceof WithDefaultError ? error.errorMessage : message`${text(String(error))}`
				};
			}
			if (!isAsync) return syncParser.complete(state[0]);
			return parser.complete(state[0]);
		},
		suggest(context, prefix) {
			if (isAsync) return suggestAsync(context, prefix);
			return suggestSync(context, prefix);
		},
		getDocFragments(state, upperDefaultValue) {
			const innerState = state.kind === "unavailable" ? { kind: "unavailable" } : state.state === void 0 ? { kind: "unavailable" } : {
				kind: "available",
				state: state.state[0]
			};
			const actualDefaultValue = upperDefaultValue != null ? upperDefaultValue : typeof defaultValue === "function" ? defaultValue() : defaultValue;
			const fragments = syncParser.getDocFragments(innerState, actualDefaultValue);
			if (options?.message) {
				const modifiedFragments = fragments.fragments.map((fragment) => {
					if (fragment.type === "entry") return {
						...fragment,
						default: options.message
					};
					return fragment;
				});
				return {
					...fragments,
					fragments: modifiedFragments
				};
			}
			return fragments;
		}
	};
}
/**
* Creates a parser that transforms the result value of another parser using
* a mapping function. This enables value transformation while preserving
* the original parser's parsing logic and state management.
*
* The `map()` function is useful for:
* - Converting parsed values to different types
* - Applying transformations like string formatting or boolean inversion
* - Computing derived values from parsed input
* - Creating reusable transformations that can be applied to any parser
*
* @template M The execution mode of the parser.
* @template T The type of the value produced by the original parser.
* @template U The type of the value produced by the mapping function.
* @template TState The type of the state used by the original parser.
* @param parser The {@link Parser} whose result will be transformed.
* @param transform A function that transforms the parsed value from type T to type U.
* @returns A {@link Parser} that produces the transformed value of type U
*          while preserving the original parser's state type and parsing behavior.
*
* @example
* ```typescript
* // Transform boolean flag to its inverse
* const parser = object({
*   disallow: map(option("--allow"), b => !b)
* });
*
* // Transform string to uppercase
* const upperParser = map(argument(string()), s => s.toUpperCase());
*
* // Transform number to formatted string
* const prefixedParser = map(option("-n", integer()), n => `value: ${n}`);
* ```
*/
function map(parser, transform) {
	const complete = (state) => {
		const res = parser.complete(state);
		if (res instanceof Promise) return res.then((r) => {
			if (r.success) return {
				success: true,
				value: transform(r.value)
			};
			return r;
		});
		if (res.success) return {
			success: true,
			value: transform(res.value)
		};
		return res;
	};
	return {
		...parser,
		$valueType: [],
		complete,
		getDocFragments(state, _defaultValue) {
			return parser.getDocFragments(state, void 0);
		}
	};
}
/**
* Creates a parser that allows multiple occurrences of a given parser.
* This parser can be used to parse multiple values of the same type,
* such as multiple command-line arguments or options.
* @template M The execution mode of the parser.
* @template TValue The type of the value that the parser produces.
* @template TState The type of the state used by the parser.
* @param parser The {@link Parser} to apply multiple times.
* @param options Optional configuration for the parser,
*                allowing you to specify the minimum and maximum number of
*                occurrences allowed.
* @returns A {@link Parser} that produces an array of values
*          of type {@link TValue} and an array of states
*          of type {@link TState}.
*/
function multiple(parser, options = {}) {
	const syncParser = parser;
	const isAsync = parser.$mode === "async";
	const { min = 0, max = Infinity } = options;
	const parseSync = (context) => {
		let added = context.state.length < 1;
		let result = syncParser.parse({
			...context,
			state: context.state.at(-1) ?? syncParser.initialState
		});
		if (!result.success) if (!added) {
			result = syncParser.parse({
				...context,
				state: syncParser.initialState
			});
			if (!result.success) return result;
			added = true;
		} else return result;
		return {
			success: true,
			next: {
				...result.next,
				state: [...added ? context.state : context.state.slice(0, -1), result.next.state]
			},
			consumed: result.consumed
		};
	};
	const parseAsync = async (context) => {
		let added = context.state.length < 1;
		let resultOrPromise = parser.parse({
			...context,
			state: context.state.at(-1) ?? parser.initialState
		});
		let result = await resultOrPromise;
		if (!result.success) if (!added) {
			resultOrPromise = parser.parse({
				...context,
				state: parser.initialState
			});
			result = await resultOrPromise;
			if (!result.success) return result;
			added = true;
		} else return result;
		return {
			success: true,
			next: {
				...result.next,
				state: [...added ? context.state : context.state.slice(0, -1), result.next.state]
			},
			consumed: result.consumed
		};
	};
	const resultParser = {
		$mode: parser.$mode,
		$valueType: [],
		$stateType: [],
		priority: parser.priority,
		usage: [{
			type: "multiple",
			terms: parser.usage,
			min
		}],
		initialState: [],
		parse(context) {
			if (isAsync) return parseAsync(context);
			return parseSync(context);
		},
		complete(state) {
			if (!isAsync) {
				const result = [];
				for (const s of state) {
					const valueResult = syncParser.complete(s);
					if (valueResult.success) result.push(valueResult.value);
					else return {
						success: false,
						error: valueResult.error
					};
				}
				return validateMultipleResult(result);
			}
			return (async () => {
				const results = await Promise.all(state.map((s) => parser.complete(s)));
				const values = [];
				for (const valueResult of results) if (valueResult.success) values.push(valueResult.value);
				else return {
					success: false,
					error: valueResult.error
				};
				return validateMultipleResult(values);
			})();
		},
		suggest(context, prefix) {
			const innerState = context.state.length > 0 ? context.state.at(-1) : parser.initialState;
			const selectedValues = /* @__PURE__ */ new Set();
			for (const s of context.state) {
				const completed = syncParser.complete(s);
				if (completed.success) {
					const valueStr = String(completed.value);
					selectedValues.add(valueStr);
				}
			}
			const shouldInclude = (suggestion) => {
				if (suggestion.kind === "literal") return !selectedValues.has(suggestion.text);
				return true;
			};
			if (isAsync) return async function* () {
				const suggestions = parser.suggest({
					...context,
					state: innerState
				}, prefix);
				for await (const s of suggestions) if (shouldInclude(s)) yield s;
			}();
			return function* () {
				for (const s of syncParser.suggest({
					...context,
					state: innerState
				}, prefix)) if (shouldInclude(s)) yield s;
			}();
		},
		getDocFragments(state, defaultValue) {
			const innerState = state.kind === "unavailable" ? { kind: "unavailable" } : state.state.length > 0 ? {
				kind: "available",
				state: state.state.at(-1)
			} : { kind: "unavailable" };
			return syncParser.getDocFragments(innerState, defaultValue != null && defaultValue.length > 0 ? defaultValue[0] : void 0);
		}
	};
	function validateMultipleResult(result) {
		if (result.length < min) {
			const customMessage = options.errors?.tooFew;
			return {
				success: false,
				error: customMessage ? typeof customMessage === "function" ? customMessage(min, result.length) : customMessage : message`Expected at least ${text(min.toLocaleString("en"))} values, but got only ${text(result.length.toLocaleString("en"))}.`
			};
		} else if (result.length > max) {
			const customMessage = options.errors?.tooMany;
			return {
				success: false,
				error: customMessage ? typeof customMessage === "function" ? customMessage(max, result.length) : customMessage : message`Expected at most ${text(max.toLocaleString("en"))} values, but got ${text(result.length.toLocaleString("en"))}.`
			};
		}
		return {
			success: true,
			value: result
		};
	}
	return resultParser;
}

//#endregion
export { WithDefaultError, map, multiple, optional, withDefault };