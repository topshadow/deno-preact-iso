{"version":3,"file":"logger.js","names":["category: string | readonly string[]","rootLogger: LoggerImpl | null","parent: LoggerImpl | null","category: readonly string[]","subcategory:\n      | string\n      | readonly [string]\n      | readonly [string, ...(readonly string[])]","child: LoggerImpl | undefined","properties: Record<string, unknown>","record: LogRecord","level: LogLevel","record: Omit<LogRecord, \"category\"> | LogRecord","bypassSinks?: Set<Sink>","rawMessage: string","properties: Record<string, unknown> | (() => Record<string, unknown>)","cachedProps: Record<string, unknown> | undefined","callback: LogCallback","rawMessage: TemplateStringsArray | undefined","msg: unknown[] | undefined","messageTemplate: TemplateStringsArray","values: unknown[]","message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>","logger: LoggerImpl","subcategory: string | readonly [string] | readonly [string, ...string[]]","message: string","record: Omit<LogRecord, \"category\">","key: string","obj: unknown","path: string","fromIndex: number","segment: string | number","current: unknown","template: string","message: unknown[]","prop: unknown","template: TemplateStringsArray","values: readonly unknown[]"],"sources":["../src/logger.ts"],"sourcesContent":["import {\n  type ContextLocalStorage,\n  getCategoryPrefix,\n  getImplicitContext,\n} from \"./context.ts\";\nimport type { Filter } from \"./filter.ts\";\nimport { compareLogLevel, type LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\nimport type { Sink } from \"./sink.ts\";\n\n/**\n * A logger interface.  It provides methods to log messages at different\n * severity levels.\n *\n * ```typescript\n * const logger = getLogger(\"category\");\n * logger.trace `A trace message with ${value}`\n * logger.debug `A debug message with ${value}.`;\n * logger.info `An info message with ${value}.`;\n * logger.warn `A warning message with ${value}.`;\n * logger.error `An error message with ${value}.`;\n * logger.fatal `A fatal error message with ${value}.`;\n * ```\n */\nexport interface Logger {\n  /**\n   * The category of the logger.  It is an array of strings.\n   */\n  readonly category: readonly string[];\n\n  /**\n   * The logger with the supercategory of the current logger.  If the current\n   * logger is the root logger, this is `null`.\n   */\n  readonly parent: Logger | null;\n\n  /**\n   * Get a child logger with the given subcategory.\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const subLogger = logger.getChild(\"sub-category\");\n   * ```\n   *\n   * The above code is equivalent to:\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const subLogger = getLogger([\"category\", \"sub-category\"]);\n   * ```\n   *\n   * @param subcategory The subcategory.\n   * @returns The child logger.\n   */\n  getChild(\n    subcategory: string | readonly [string] | readonly [string, ...string[]],\n  ): Logger;\n\n  /**\n   * Get a logger with contextual properties.  This is useful for\n   * log multiple messages with the shared set of properties.\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const ctx = logger.with({ foo: 123, bar: \"abc\" });\n   * ctx.info(\"A message with {foo} and {bar}.\");\n   * ctx.warn(\"Another message with {foo}, {bar}, and {baz}.\", { baz: true });\n   * ```\n   *\n   * The above code is equivalent to:\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * logger.info(\"A message with {foo} and {bar}.\", { foo: 123, bar: \"abc\" });\n   * logger.warn(\n   *   \"Another message with {foo}, {bar}, and {baz}.\",\n   *   { foo: 123, bar: \"abc\", baz: true },\n   * );\n   * ```\n   *\n   * @param properties\n   * @returns\n   * @since 0.5.0\n   */\n  with(properties: Record<string, unknown>): Logger;\n\n  /**\n   * Log a trace message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.trace `A trace message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   * @since 0.12.0\n   */\n  trace(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a trace message with properties.\n   *\n   * ```typescript\n   * logger.trace('A trace message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.trace(\n   *   'A trace message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   * @since 0.12.0\n   */\n  trace(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a trace values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.trace({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.trace('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.trace('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.12.0\n   */\n  trace(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a trace message.  Use this when the message values are expensive\n   * to compute and should only be computed if the message is actually logged.\n   *\n   * ```typescript\n   * logger.trace(l => l`A trace message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   * @since 0.12.0\n   */\n  trace(callback: LogCallback): void;\n\n  /**\n   * Log a debug message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.debug `A debug message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  debug(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a debug message with properties.\n   *\n   * ```typescript\n   * logger.debug('A debug message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.debug(\n   *   'A debug message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  debug(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a debug values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.debug({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.debug('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.debug('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  debug(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a debug message.  Use this when the message values are expensive\n   * to compute and should only be computed if the message is actually logged.\n   *\n   * ```typescript\n   * logger.debug(l => l`A debug message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  debug(callback: LogCallback): void;\n\n  /**\n   * Log an informational message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.info `An info message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  info(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log an informational message with properties.\n   *\n   * ```typescript\n   * logger.info('An info message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.info(\n   *   'An info message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  info(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log an informational values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.info({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.info('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.info('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  info(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log an informational message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.info(l => l`An info message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  info(callback: LogCallback): void;\n\n  /**\n   * Log a warning message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.warn `A warning message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  warn(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a warning message with properties.\n   *\n   * ```typescript\n   * logger.warn('A warning message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.warn(\n   *   'A warning message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  warn(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a warning values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.warn({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.warn('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.warn('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  warn(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a warning message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.warn(l => l`A warning message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  warn(callback: LogCallback): void;\n\n  /**\n   * Log a warning message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.warning `A warning message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   * @since 0.12.0\n   */\n  warning(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a warning message with properties.\n   *\n   * ```typescript\n   * logger.warning('A warning message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.warning(\n   *   'A warning message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   * @since 0.12.0\n   */\n  warning(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a warning values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.warning({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.warning('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.warning('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.12.0\n   */\n  warning(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a warning message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.warning(l => l`A warning message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   * @since 0.12.0\n   */\n  warning(callback: LogCallback): void;\n\n  /**\n   * Log an error message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.error `An error message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  error(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log an error message with properties.\n   *\n   * ```typescript\n   * logger.warn('An error message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.error(\n   *   'An error message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  error(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log an error values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.error({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.error('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.error('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  error(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log an error message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.error(l => l`An error message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  error(callback: LogCallback): void;\n\n  /**\n   * Log a fatal error message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.fatal `A fatal error message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  fatal(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a fatal error message with properties.\n   *\n   * ```typescript\n   * logger.warn('A fatal error message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.fatal(\n   *   'A fatal error message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  fatal(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a fatal error values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.fatal({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.fatal('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.fatal('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  fatal(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a fatal error message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.fatal(l => l`A fatal error message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  fatal(callback: LogCallback): void;\n\n  /**\n   * Emits a log record with custom fields while using this logger's\n   * category.\n   *\n   * This is a low-level API for integration scenarios where you need full\n   * control over the log record, particularly for preserving timestamps\n   * from external systems.\n   *\n   * ```typescript\n   * const logger = getLogger([\"my-app\", \"integration\"]);\n   *\n   * // Emit a log with a custom timestamp\n   * logger.emit({\n   *   timestamp: kafkaLog.originalTimestamp,\n   *   level: \"info\",\n   *   message: [kafkaLog.message],\n   *   rawMessage: kafkaLog.message,\n   *   properties: {\n   *     source: \"kafka\",\n   *     partition: kafkaLog.partition,\n   *     offset: kafkaLog.offset,\n   *   },\n   * });\n   * ```\n   *\n   * @param record Log record without category field (category comes from\n   *               the logger instance)\n   * @since 1.1.0\n   */\n  emit(record: Omit<LogRecord, \"category\">): void;\n}\n\n/**\n * A logging callback function.  It is used to defer the computation of a\n * message template until it is actually logged.\n * @param prefix The message template prefix.\n * @returns The rendered message array.\n */\nexport type LogCallback = (prefix: LogTemplatePrefix) => unknown[];\n\n/**\n * A logging template prefix function.  It is used to log a message in\n * a {@link LogCallback} function.\n * @param message The message template strings array.\n * @param values The message template values.\n * @returns The rendered message array.\n */\nexport type LogTemplatePrefix = (\n  message: TemplateStringsArray,\n  ...values: unknown[]\n) => unknown[];\n\n/**\n * A function type for logging methods in the {@link Logger} interface.\n * @since 1.0.0\n */\nexport interface LogMethod {\n  /**\n   * Log a message with the given level using a template string.\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  (\n    message: TemplateStringsArray,\n    ...values: readonly unknown[]\n  ): void;\n\n  /**\n   * Log a message with the given level with properties.\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  (\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a message with the given level with no message.\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   */\n  (properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a message with the given level.\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  (callback: LogCallback): void;\n}\n\n/**\n * Get a logger with the given category.\n *\n * ```typescript\n * const logger = getLogger([\"my-app\"]);\n * ```\n *\n * @param category The category of the logger.  It can be a string or an array\n *                 of strings.  If it is a string, it is equivalent to an array\n *                 with a single element.\n * @returns The logger.\n */\nexport function getLogger(category: string | readonly string[] = []): Logger {\n  return LoggerImpl.getLogger(category);\n}\n\n/**\n * The symbol for the global root logger.\n */\nconst globalRootLoggerSymbol = Symbol.for(\"logtape.rootLogger\");\n\n/**\n * The global root logger registry.\n */\ninterface GlobalRootLoggerRegistry {\n  [globalRootLoggerSymbol]?: LoggerImpl;\n}\n\n/**\n * A logger implementation.  Do not use this directly; use {@link getLogger}\n * instead.  This class is exported for testing purposes.\n */\nexport class LoggerImpl implements Logger {\n  readonly parent: LoggerImpl | null;\n  readonly children: Record<string, LoggerImpl | WeakRef<LoggerImpl>>;\n  readonly category: readonly string[];\n  readonly sinks: Sink[];\n  parentSinks: \"inherit\" | \"override\" = \"inherit\";\n  readonly filters: Filter[];\n  lowestLevel: LogLevel | null = \"trace\";\n  contextLocalStorage?: ContextLocalStorage<Record<string, unknown>>;\n\n  static getLogger(category: string | readonly string[] = []): LoggerImpl {\n    let rootLogger: LoggerImpl | null = globalRootLoggerSymbol in globalThis\n      ? ((globalThis as GlobalRootLoggerRegistry)[globalRootLoggerSymbol] ??\n        null)\n      : null;\n    if (rootLogger == null) {\n      rootLogger = new LoggerImpl(null, []);\n      (globalThis as GlobalRootLoggerRegistry)[globalRootLoggerSymbol] =\n        rootLogger;\n    }\n    if (typeof category === \"string\") return rootLogger.getChild(category);\n    if (category.length === 0) return rootLogger;\n    return rootLogger.getChild(category as readonly [string, ...string[]]);\n  }\n\n  private constructor(parent: LoggerImpl | null, category: readonly string[]) {\n    this.parent = parent;\n    this.children = {};\n    this.category = category;\n    this.sinks = [];\n    this.filters = [];\n  }\n\n  getChild(\n    subcategory:\n      | string\n      | readonly [string]\n      | readonly [string, ...(readonly string[])],\n  ): LoggerImpl {\n    const name = typeof subcategory === \"string\" ? subcategory : subcategory[0];\n    const childRef = this.children[name];\n    let child: LoggerImpl | undefined = childRef instanceof LoggerImpl\n      ? childRef\n      : childRef?.deref();\n    if (child == null) {\n      child = new LoggerImpl(this, [...this.category, name]);\n      this.children[name] = \"WeakRef\" in globalThis\n        ? new WeakRef(child)\n        : child;\n    }\n    if (typeof subcategory === \"string\" || subcategory.length === 1) {\n      return child;\n    }\n    return child.getChild(\n      subcategory.slice(1) as [string, ...(readonly string[])],\n    );\n  }\n\n  /**\n   * Reset the logger.  This removes all sinks and filters from the logger.\n   */\n  reset(): void {\n    while (this.sinks.length > 0) this.sinks.shift();\n    this.parentSinks = \"inherit\";\n    while (this.filters.length > 0) this.filters.shift();\n    this.lowestLevel = \"trace\";\n  }\n\n  /**\n   * Reset the logger and all its descendants.  This removes all sinks and\n   * filters from the logger and all its descendants.\n   */\n  resetDescendants(): void {\n    for (const child of Object.values(this.children)) {\n      const logger = child instanceof LoggerImpl ? child : child.deref();\n      if (logger != null) logger.resetDescendants();\n    }\n    this.reset();\n  }\n\n  with(properties: Record<string, unknown>): Logger {\n    return new LoggerCtx(this, { ...properties });\n  }\n\n  filter(record: LogRecord): boolean {\n    for (const filter of this.filters) {\n      if (!filter(record)) return false;\n    }\n    if (this.filters.length < 1) return this.parent?.filter(record) ?? true;\n    return true;\n  }\n\n  *getSinks(level: LogLevel): Iterable<Sink> {\n    if (\n      this.lowestLevel === null || compareLogLevel(level, this.lowestLevel) < 0\n    ) {\n      return;\n    }\n    if (this.parent != null && this.parentSinks === \"inherit\") {\n      for (const sink of this.parent.getSinks(level)) yield sink;\n    }\n    for (const sink of this.sinks) yield sink;\n  }\n\n  emit(record: Omit<LogRecord, \"category\">): void;\n  emit(record: LogRecord, bypassSinks?: Set<Sink>): void;\n  emit(\n    record: Omit<LogRecord, \"category\"> | LogRecord,\n    bypassSinks?: Set<Sink>,\n  ): void {\n    const categoryPrefix = getCategoryPrefix();\n    const baseCategory = \"category\" in record\n      ? (record as LogRecord).category\n      : this.category;\n    const fullCategory = categoryPrefix.length > 0\n      ? [...categoryPrefix, ...baseCategory]\n      : baseCategory;\n\n    // Create the full record by copying property descriptors from the original\n    // record, which preserves getters without invoking them (unlike spread).\n    const descriptors = Object.getOwnPropertyDescriptors(record) as\n      & PropertyDescriptorMap\n      & { category?: PropertyDescriptor };\n    descriptors.category = {\n      value: fullCategory,\n      enumerable: true,\n      configurable: true,\n    };\n    const fullRecord = Object.defineProperties({}, descriptors) as LogRecord;\n\n    if (\n      this.lowestLevel === null ||\n      compareLogLevel(fullRecord.level, this.lowestLevel) < 0 ||\n      !this.filter(fullRecord)\n    ) {\n      return;\n    }\n    for (const sink of this.getSinks(fullRecord.level)) {\n      if (bypassSinks?.has(sink)) continue;\n      try {\n        sink(fullRecord);\n      } catch (error) {\n        const bypassSinks2 = new Set(bypassSinks);\n        bypassSinks2.add(sink);\n        metaLogger.log(\n          \"fatal\",\n          \"Failed to emit a log record to sink {sink}: {error}\",\n          { sink, error, record: fullRecord },\n          bypassSinks2,\n        );\n      }\n    }\n  }\n\n  log(\n    level: LogLevel,\n    rawMessage: string,\n    properties: Record<string, unknown> | (() => Record<string, unknown>),\n    bypassSinks?: Set<Sink>,\n  ): void {\n    const implicitContext = getImplicitContext();\n    let cachedProps: Record<string, unknown> | undefined = undefined;\n    const record: LogRecord = typeof properties === \"function\"\n      ? {\n        category: this.category,\n        level,\n        timestamp: Date.now(),\n        get message() {\n          return parseMessageTemplate(rawMessage, this.properties);\n        },\n        rawMessage,\n        get properties() {\n          if (cachedProps == null) {\n            cachedProps = {\n              ...implicitContext,\n              ...properties(),\n            };\n          }\n          return cachedProps;\n        },\n      }\n      : {\n        category: this.category,\n        level,\n        timestamp: Date.now(),\n        message: parseMessageTemplate(rawMessage, {\n          ...implicitContext,\n          ...properties,\n        }),\n        rawMessage,\n        properties: { ...implicitContext, ...properties },\n      };\n    this.emit(record, bypassSinks);\n  }\n\n  logLazily(\n    level: LogLevel,\n    callback: LogCallback,\n    properties: Record<string, unknown> = {},\n  ): void {\n    const implicitContext = getImplicitContext();\n    let rawMessage: TemplateStringsArray | undefined = undefined;\n    let msg: unknown[] | undefined = undefined;\n    function realizeMessage(): [unknown[], TemplateStringsArray] {\n      if (msg == null || rawMessage == null) {\n        msg = callback((tpl, ...values) => {\n          rawMessage = tpl;\n          return renderMessage(tpl, values);\n        });\n        if (rawMessage == null) throw new TypeError(\"No log record was made.\");\n      }\n      return [msg, rawMessage];\n    }\n    this.emit({\n      category: this.category,\n      level,\n      get message() {\n        return realizeMessage()[0];\n      },\n      get rawMessage() {\n        return realizeMessage()[1];\n      },\n      timestamp: Date.now(),\n      properties: { ...implicitContext, ...properties },\n    });\n  }\n\n  logTemplate(\n    level: LogLevel,\n    messageTemplate: TemplateStringsArray,\n    values: unknown[],\n    properties: Record<string, unknown> = {},\n  ): void {\n    const implicitContext = getImplicitContext();\n    this.emit({\n      category: this.category,\n      level,\n      message: renderMessage(messageTemplate, values),\n      rawMessage: messageTemplate,\n      timestamp: Date.now(),\n      properties: { ...implicitContext, ...properties },\n    });\n  }\n\n  trace(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"trace\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"trace\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"trace\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"trace\", message as TemplateStringsArray, values);\n    }\n  }\n\n  debug(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"debug\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"debug\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"debug\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"debug\", message as TemplateStringsArray, values);\n    }\n  }\n\n  info(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"info\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"info\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"info\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"info\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warn(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\n        \"warning\",\n        message,\n        (values[0] ?? {}) as Record<string, unknown>,\n      );\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"warning\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"warning\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"warning\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warning(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    this.warn(message, ...values);\n  }\n\n  error(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"error\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"error\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"error\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"error\", message as TemplateStringsArray, values);\n    }\n  }\n\n  fatal(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"fatal\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"fatal\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"fatal\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"fatal\", message as TemplateStringsArray, values);\n    }\n  }\n}\n\n/**\n * A logger implementation with contextual properties.  Do not use this\n * directly; use {@link Logger.with} instead.  This class is exported\n * for testing purposes.\n */\nexport class LoggerCtx implements Logger {\n  logger: LoggerImpl;\n  properties: Record<string, unknown>;\n\n  constructor(logger: LoggerImpl, properties: Record<string, unknown>) {\n    this.logger = logger;\n    this.properties = properties;\n  }\n\n  get category(): readonly string[] {\n    return this.logger.category;\n  }\n\n  get parent(): Logger | null {\n    return this.logger.parent;\n  }\n\n  getChild(\n    subcategory: string | readonly [string] | readonly [string, ...string[]],\n  ): Logger {\n    return this.logger.getChild(subcategory).with(this.properties);\n  }\n\n  with(properties: Record<string, unknown>): Logger {\n    return new LoggerCtx(this.logger, { ...this.properties, ...properties });\n  }\n\n  log(\n    level: LogLevel,\n    message: string,\n    properties: Record<string, unknown> | (() => Record<string, unknown>),\n    bypassSinks?: Set<Sink>,\n  ): void {\n    this.logger.log(\n      level,\n      message,\n      typeof properties === \"function\"\n        ? () => ({\n          ...this.properties,\n          ...properties(),\n        })\n        : { ...this.properties, ...properties },\n      bypassSinks,\n    );\n  }\n\n  logLazily(level: LogLevel, callback: LogCallback): void {\n    this.logger.logLazily(level, callback, this.properties);\n  }\n\n  logTemplate(\n    level: LogLevel,\n    messageTemplate: TemplateStringsArray,\n    values: unknown[],\n  ): void {\n    this.logger.logTemplate(level, messageTemplate, values, this.properties);\n  }\n\n  emit(record: Omit<LogRecord, \"category\">): void {\n    const recordWithContext = {\n      ...record,\n      properties: { ...this.properties, ...record.properties },\n    };\n    this.logger.emit(recordWithContext);\n  }\n\n  trace(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"trace\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"trace\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"trace\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"trace\", message as TemplateStringsArray, values);\n    }\n  }\n\n  debug(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"debug\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"debug\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"debug\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"debug\", message as TemplateStringsArray, values);\n    }\n  }\n\n  info(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"info\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"info\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"info\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"info\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warn(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\n        \"warning\",\n        message,\n        (values[0] ?? {}) as Record<string, unknown>,\n      );\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"warning\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"warning\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"warning\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warning(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    this.warn(message, ...values);\n  }\n\n  error(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"error\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"error\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"error\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"error\", message as TemplateStringsArray, values);\n    }\n  }\n\n  fatal(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"fatal\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"fatal\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"fatal\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"fatal\", message as TemplateStringsArray, values);\n    }\n  }\n}\n\n/**\n * The meta logger.  It is a logger with the category `[\"logtape\", \"meta\"]`.\n */\nconst metaLogger = LoggerImpl.getLogger([\"logtape\", \"meta\"]);\n\n/**\n * Check if a property access key contains nested access patterns.\n * @param key The property key to check.\n * @returns True if the key contains nested access patterns.\n */\nfunction isNestedAccess(key: string): boolean {\n  return key.includes(\".\") || key.includes(\"[\") || key.includes(\"?.\");\n}\n\n/**\n * Safely access an own property from an object, blocking prototype pollution.\n *\n * @param obj The object to access the property from.\n * @param key The property key to access.\n * @returns The property value or undefined if not accessible.\n */\nfunction getOwnProperty(obj: unknown, key: string): unknown {\n  // Block dangerous prototype keys\n  if (key === \"__proto__\" || key === \"prototype\" || key === \"constructor\") {\n    return undefined;\n  }\n\n  if ((typeof obj === \"object\" || typeof obj === \"function\") && obj !== null) {\n    return Object.prototype.hasOwnProperty.call(obj, key)\n      ? (obj as Record<string, unknown>)[key]\n      : undefined;\n  }\n\n  return undefined;\n}\n\n/**\n * Result of parsing a single segment from a property path.\n */\ninterface ParseSegmentResult {\n  segment: string | number;\n  nextIndex: number;\n}\n\n/**\n * Parse the next segment from a property path string.\n *\n * @param path The full property path string.\n * @param fromIndex The index to start parsing from.\n * @returns The parsed segment and next index, or null if parsing fails.\n */\nfunction parseNextSegment(\n  path: string,\n  fromIndex: number,\n): ParseSegmentResult | null {\n  const len = path.length;\n  let i = fromIndex;\n\n  if (i >= len) return null;\n\n  let segment: string | number;\n\n  if (path[i] === \"[\") {\n    // Bracket notation: [0] or [\"prop\"]\n    i++;\n    if (i >= len) return null;\n\n    if (path[i] === '\"' || path[i] === \"'\") {\n      // Quoted property name: [\"prop-name\"]\n      const quote = path[i];\n      i++;\n      // Build segment with proper escape handling\n      let segmentStr = \"\";\n      while (i < len && path[i] !== quote) {\n        if (path[i] === \"\\\\\") {\n          i++; // Skip backslash\n          if (i < len) {\n            // Handle escape sequences according to JavaScript spec\n            const escapeChar = path[i];\n            switch (escapeChar) {\n              case \"n\":\n                segmentStr += \"\\n\";\n                break;\n              case \"t\":\n                segmentStr += \"\\t\";\n                break;\n              case \"r\":\n                segmentStr += \"\\r\";\n                break;\n              case \"b\":\n                segmentStr += \"\\b\";\n                break;\n              case \"f\":\n                segmentStr += \"\\f\";\n                break;\n              case \"v\":\n                segmentStr += \"\\v\";\n                break;\n              case \"0\":\n                segmentStr += \"\\0\";\n                break;\n              case \"\\\\\":\n                segmentStr += \"\\\\\";\n                break;\n              case '\"':\n                segmentStr += '\"';\n                break;\n              case \"'\":\n                segmentStr += \"'\";\n                break;\n              case \"u\":\n                // Unicode escape: \\uXXXX\n                if (i + 4 < len) {\n                  const hex = path.slice(i + 1, i + 5);\n                  const codePoint = Number.parseInt(hex, 16);\n                  if (!Number.isNaN(codePoint)) {\n                    segmentStr += String.fromCharCode(codePoint);\n                    i += 4; // Skip the 4 hex digits\n                  } else {\n                    // Invalid unicode escape, keep as-is\n                    segmentStr += escapeChar;\n                  }\n                } else {\n                  // Not enough characters for unicode escape\n                  segmentStr += escapeChar;\n                }\n                break;\n              default:\n                // For any other character after \\, just add it as-is\n                segmentStr += escapeChar;\n            }\n            i++;\n          }\n        } else {\n          segmentStr += path[i];\n          i++;\n        }\n      }\n      if (i >= len) return null;\n      segment = segmentStr;\n      i++; // Skip closing quote\n    } else {\n      // Array index: [0]\n      const startIndex = i;\n      while (\n        i < len && path[i] !== \"]\" && path[i] !== \"'\" && path[i] !== '\"'\n      ) {\n        i++;\n      }\n      if (i >= len) return null;\n      const indexStr = path.slice(startIndex, i);\n      // Empty bracket is invalid\n      if (indexStr.length === 0) return null;\n      const indexNum = Number(indexStr);\n      segment = Number.isNaN(indexNum) ? indexStr : indexNum;\n    }\n\n    // Skip closing bracket\n    while (i < len && path[i] !== \"]\") i++;\n    if (i < len) i++;\n  } else {\n    // Dot notation: prop\n    const startIndex = i;\n    while (\n      i < len && path[i] !== \".\" && path[i] !== \"[\" && path[i] !== \"?\" &&\n      path[i] !== \"]\"\n    ) {\n      i++;\n    }\n    segment = path.slice(startIndex, i);\n    // Empty segment is invalid (e.g., leading dot, double dot, trailing dot)\n    if (segment.length === 0) return null;\n  }\n\n  // Skip dot separator\n  if (i < len && path[i] === \".\") i++;\n\n  return { segment, nextIndex: i };\n}\n\n/**\n * Access a property or index on an object or array.\n *\n * @param obj The object or array to access.\n * @param segment The property key or array index.\n * @returns The accessed value or undefined if not accessible.\n */\nfunction accessProperty(obj: unknown, segment: string | number): unknown {\n  if (typeof segment === \"string\") {\n    return getOwnProperty(obj, segment);\n  }\n\n  // Numeric index for arrays\n  if (Array.isArray(obj) && segment >= 0 && segment < obj.length) {\n    return obj[segment];\n  }\n\n  return undefined;\n}\n\n/**\n * Resolve a nested property path from an object.\n *\n * There are two types of property access patterns:\n * 1. Array/index access: [0] or [\"prop\"]\n * 2. Property access: prop or prop?.next\n *\n * @param obj The object to traverse.\n * @param path The property path (e.g., \"user.name\", \"users[0].email\", \"user['full-name']\").\n * @returns The resolved value or undefined if path doesn't exist.\n */\nfunction resolvePropertyPath(obj: unknown, path: string): unknown {\n  if (obj == null) return undefined;\n\n  // Check for invalid paths\n  if (path.length === 0 || path.endsWith(\".\")) return undefined;\n\n  let current: unknown = obj;\n  let i = 0;\n  const len = path.length;\n\n  while (i < len) {\n    // Handle optional chaining\n    const isOptional = path.slice(i, i + 2) === \"?.\";\n    if (isOptional) {\n      i += 2;\n      if (current == null) return undefined;\n    } else if (current == null) {\n      return undefined;\n    }\n\n    // Parse the next segment\n    const result = parseNextSegment(path, i);\n    if (result === null) return undefined;\n\n    const { segment, nextIndex } = result;\n    i = nextIndex;\n\n    // Access the property/index\n    current = accessProperty(current, segment);\n    if (current === undefined) {\n      return undefined;\n    }\n  }\n\n  return current;\n}\n\n/**\n * Parse a message template into a message template array and a values array.\n *\n * Placeholders to be replaced with `values` are indicated by keys in curly braces\n * (e.g., `{value}`). The system supports both simple property access and nested\n * property access patterns:\n *\n * **Simple property access:**\n * ```ts\n * parseMessageTemplate(\"Hello, {user}!\", { user: \"foo\" })\n * // Returns: [\"Hello, \", \"foo\", \"!\"]\n * ```\n *\n * **Nested property access (dot notation):**\n * ```ts\n * parseMessageTemplate(\"Hello, {user.name}!\", {\n *   user: { name: \"foo\", email: \"foo@example.com\" }\n * })\n * // Returns: [\"Hello, \", \"foo\", \"!\"]\n * ```\n *\n * **Array indexing:**\n * ```ts\n * parseMessageTemplate(\"First: {users[0]}\", {\n *   users: [\"foo\", \"bar\", \"baz\"]\n * })\n * // Returns: [\"First: \", \"foo\", \"\"]\n * ```\n *\n * **Bracket notation for special property names:**\n * ```ts\n * parseMessageTemplate(\"Name: {user[\\\"full-name\\\"]}\", {\n *   user: { \"full-name\": \"foo bar\" }\n * })\n * // Returns: [\"Name: \", \"foo bar\", \"\"]\n * ```\n *\n * **Optional chaining for safe navigation:**\n * ```ts\n * parseMessageTemplate(\"Email: {user?.profile?.email}\", {\n *   user: { name: \"foo\" }\n * })\n * // Returns: [\"Email: \", undefined, \"\"]\n * ```\n *\n * **Wildcard patterns:**\n * - `{*}` - Replaced with the entire properties object\n * - `{ key-with-whitespace }` - Whitespace is trimmed when looking up keys\n *\n * **Escaping:**\n * - `{{` and `}}` are escaped literal braces\n *\n * **Error handling:**\n * - Non-existent paths return `undefined`\n * - Malformed expressions resolve to `undefined` without throwing errors\n * - Out of bounds array access returns `undefined`\n *\n * @param template The message template string containing placeholders.\n * @param properties The values to replace placeholders with.\n * @returns The message template array with values interleaved between text segments.\n */\nexport function parseMessageTemplate(\n  template: string,\n  properties: Record<string, unknown>,\n): readonly unknown[] {\n  const length = template.length;\n  if (length === 0) return [\"\"];\n\n  // Fast path: no placeholders\n  if (!template.includes(\"{\")) return [template];\n\n  const message: unknown[] = [];\n  let startIndex = 0;\n\n  for (let i = 0; i < length; i++) {\n    const char = template[i];\n\n    if (char === \"{\") {\n      const nextChar = i + 1 < length ? template[i + 1] : \"\";\n\n      if (nextChar === \"{\") {\n        // Escaped { character - skip and continue\n        i++; // Skip the next {\n        continue;\n      }\n\n      // Find the closing }\n      const closeIndex = template.indexOf(\"}\", i + 1);\n      if (closeIndex === -1) {\n        // No closing } found, treat as literal text\n        continue;\n      }\n\n      // Add text before placeholder\n      const beforeText = template.slice(startIndex, i);\n      message.push(beforeText.replace(/{{/g, \"{\").replace(/}}/g, \"}\"));\n\n      // Extract and process placeholder key\n      const key = template.slice(i + 1, closeIndex);\n\n      // Resolve property value\n      let prop: unknown;\n\n      // Check for wildcard patterns\n      const trimmedKey = key.trim();\n      if (trimmedKey === \"*\") {\n        // This is a wildcard pattern\n        prop = key in properties\n          ? properties[key]\n          : \"*\" in properties\n          ? properties[\"*\"]\n          : properties;\n      } else {\n        // Regular property lookup with possible whitespace handling\n        if (key !== trimmedKey) {\n          // Key has leading/trailing whitespace\n          prop = key in properties ? properties[key] : properties[trimmedKey];\n        } else {\n          // Key has no leading/trailing whitespace\n          prop = properties[key];\n        }\n\n        // If property not found directly and this looks like nested access, try nested resolution\n        if (prop === undefined && isNestedAccess(trimmedKey)) {\n          prop = resolvePropertyPath(properties, trimmedKey);\n        }\n      }\n\n      message.push(prop);\n      i = closeIndex; // Move to the }\n      startIndex = i + 1;\n    } else if (char === \"}\" && i + 1 < length && template[i + 1] === \"}\") {\n      // Escaped } character - skip\n      i++; // Skip the next }\n    }\n  }\n\n  // Add remaining text\n  const remainingText = template.slice(startIndex);\n  message.push(remainingText.replace(/{{/g, \"{\").replace(/}}/g, \"}\"));\n\n  return message;\n}\n\n/**\n * Render a message template with values.\n * @param template The message template.\n * @param values The message template values.\n * @returns The message template values interleaved between the substitution\n *          values.\n */\nexport function renderMessage(\n  template: TemplateStringsArray,\n  values: readonly unknown[],\n): unknown[] {\n  const args = [];\n  for (let i = 0; i < template.length; i++) {\n    args.push(template[i]);\n    if (i < values.length) args.push(values[i]);\n  }\n  return args;\n}\n"],"mappings":"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"}