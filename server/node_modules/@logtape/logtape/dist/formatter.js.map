{"version":3,"file":"formatter.js","names":["levelAbbreviations: Record<LogLevel, string>","inspect: (value: unknown, options?: { colors?: boolean }) => string","num: number","ts: number","options: TextFormatterOptions","v: unknown","level: LogLevel","formatter: (values: FormattedValues) => string","record: LogRecord","message: string","parts: string[]","values: FormattedValues","defaultTextFormatter: TextFormatter","ansiColors: Record<AnsiColor, string>","ansiStyles: Record<AnsiStyle, string>","defaultLevelColors: Record<LogLevel, AnsiColor | null>","options: AnsiColorFormatterOptions","value: unknown","ansiColorFormatter: TextFormatter","options: JsonLinesFormatterOptions","joinCategory: (category: readonly string[]) => string | readonly string[]","category: readonly string[]","getProperties: (\n    properties: Record<string, unknown>,\n  ) => Record<string, unknown>","result: Record<string, unknown>","getMessage: (record: LogRecord) => string","jsonLinesFormatter: TextFormatter","logLevelStyles: Record<LogLevel, string>","values: unknown[]"],"sources":["../src/formatter.ts"],"sourcesContent":["import * as util from \"#util\";\nimport type { LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\n\n/**\n * A text formatter is a function that accepts a log record and returns\n * a string.\n *\n * @param record The log record to format.\n * @returns The formatted log record.\n */\nexport type TextFormatter = (record: LogRecord) => string;\n\n/**\n * The severity level abbreviations.\n */\nconst levelAbbreviations: Record<LogLevel, string> = {\n  \"trace\": \"TRC\",\n  \"debug\": \"DBG\",\n  \"info\": \"INF\",\n  \"warning\": \"WRN\",\n  \"error\": \"ERR\",\n  \"fatal\": \"FTL\",\n};\n\n/**\n * A platform-specific inspect function.  In Deno, this is {@link Deno.inspect},\n * and in Node.js/Bun it is `util.inspect()`.  If neither is available, it\n * falls back to {@link JSON.stringify}.\n *\n * @param value The value to inspect.\n * @param options The options for inspecting the value.\n *                If `colors` is `true`, the output will be ANSI-colored.\n * @returns The string representation of the value.\n */\nconst inspect: (value: unknown, options?: { colors?: boolean }) => string =\n  // @ts-ignore: Browser detection\n  // dnt-shim-ignore\n  typeof document !== \"undefined\" ||\n    // @ts-ignore: React Native detection\n    // dnt-shim-ignore\n    typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\"\n    ? (v) => JSON.stringify(v)\n    // @ts-ignore: Deno global\n    // dnt-shim-ignore\n    : \"Deno\" in globalThis && \"inspect\" in globalThis.Deno &&\n        // @ts-ignore: Deno global\n        // dnt-shim-ignore\n        typeof globalThis.Deno.inspect === \"function\"\n    ? (v, opts) =>\n      // @ts-ignore: Deno global\n      // dnt-shim-ignore\n      globalThis.Deno.inspect(v, {\n        strAbbreviateSize: Infinity,\n        iterableLimit: Infinity,\n        ...opts,\n      })\n    // @ts-ignore: Node.js global\n    // dnt-shim-ignore\n    : util != null && \"inspect\" in util && typeof util.inspect === \"function\"\n    ? (v, opts) =>\n      // @ts-ignore: Node.js global\n      // dnt-shim-ignore\n      util.inspect(v, {\n        maxArrayLength: Infinity,\n        maxStringLength: Infinity,\n        ...opts,\n      })\n    : (v) => JSON.stringify(v);\n\n/**\n * The formatted values for a log record.\n * @since 0.6.0\n */\nexport interface FormattedValues {\n  /**\n   * The formatted timestamp.\n   */\n  timestamp: string | null;\n\n  /**\n   * The formatted log level.\n   */\n  level: string;\n\n  /**\n   * The formatted category.\n   */\n  category: string;\n\n  /**\n   * The formatted message.\n   */\n  message: string;\n\n  /**\n   * The unformatted log record.\n   */\n  record: LogRecord;\n}\n\n/**\n * The various options for the built-in text formatters.\n * @since 0.6.0\n */\nexport interface TextFormatterOptions {\n  /**\n   * The timestamp format.  This can be one of the following:\n   *\n   * - `\"date-time-timezone\"`: The date and time with the full timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000 +00:00\"`).\n   * - `\"date-time-tz\"`: The date and time with the short timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000 +00\"`).\n   * - `\"date-time\"`: The date and time without the timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000\"`).\n   * - `\"time-timezone\"`: The time with the full timezone offset but without\n   *   the date (e.g., `\"22:13:20.000 +00:00\"`).\n   * - `\"time-tz\"`: The time with the short timezone offset but without the date\n   *   (e.g., `\"22:13:20.000 +00\"`).\n   * - `\"time\"`: The time without the date or timezone offset\n   *   (e.g., `\"22:13:20.000\"`).\n   * - `\"date\"`: The date without the time or timezone offset\n   *   (e.g., `\"2023-11-14\"`).\n   * - `\"rfc3339\"`: The date and time in RFC 3339 format\n   *   (e.g., `\"2023-11-14T22:13:20.000Z\"`).\n   * - `\"none\"` or `\"disabled\"`: No display\n   *\n   * Alternatively, this can be a function that accepts a timestamp and returns\n   * a string.\n   *\n   * The default is `\"date-time-timezone\"`.\n   */\n  timestamp?:\n    | \"date-time-timezone\"\n    | \"date-time-tz\"\n    | \"date-time\"\n    | \"time-timezone\"\n    | \"time-tz\"\n    | \"time\"\n    | \"date\"\n    | \"rfc3339\"\n    | \"none\"\n    | \"disabled\"\n    | ((ts: number) => string | null);\n\n  /**\n   * The log level format.  This can be one of the following:\n   *\n   * - `\"ABBR\"`: The log level abbreviation in uppercase (e.g., `\"INF\"`).\n   * - `\"FULL\"`: The full log level name in uppercase (e.g., `\"INFO\"`).\n   * - `\"L\"`: The first letter of the log level in uppercase (e.g., `\"I\"`).\n   * - `\"abbr\"`: The log level abbreviation in lowercase (e.g., `\"inf\"`).\n   * - `\"full\"`: The full log level name in lowercase (e.g., `\"info\"`).\n   * - `\"l\"`: The first letter of the log level in lowercase (e.g., `\"i\"`).\n   *\n   * Alternatively, this can be a function that accepts a log level and returns\n   * a string.\n   *\n   * The default is `\"ABBR\"`.\n   */\n  level?:\n    | \"ABBR\"\n    | \"FULL\"\n    | \"L\"\n    | \"abbr\"\n    | \"full\"\n    | \"l\"\n    | ((level: LogLevel) => string);\n\n  /**\n   * The separator between category names.  For example, if the separator is\n   * `\"·\"`, the category `[\"a\", \"b\", \"c\"]` will be formatted as `\"a·b·c\"`.\n   * The default separator is `\"·\"`.\n   *\n   * If this is a function, it will be called with the category array and\n   * should return a string, which will be used for rendering the category.\n   */\n  category?: string | ((category: readonly string[]) => string);\n\n  /**\n   * The format of the embedded values.\n   *\n   * A function that renders a value to a string.  This function is used to\n   * render the values in the log record.  The default is a cross-runtime\n   * `inspect()` function that uses [`util.inspect()`] in Node.js/Bun,\n   * [`Deno.inspect()`] in Deno, or falls back to {@link JSON.stringify} in\n   * browsers.\n   *\n   * The second parameter provides access to the default cross-runtime\n   * `inspect()` function, allowing you to fall back to the default behavior\n   * for certain values while customizing others.  You can ignore this\n   * parameter if you don't need the fallback functionality.\n   *\n   * [`util.inspect()`]: https://nodejs.org/api/util.html#utilinspectobject-options\n   * [`Deno.inspect()`]: https://docs.deno.com/api/deno/~/Deno.inspect\n   * @param value The value to render.\n   * @param inspect The default cross-runtime inspect function that can be used\n   *                as a fallback.  Accepts an optional `options` parameter\n   *                with a `colors` boolean field.\n   * @returns The string representation of the value.\n   * @example\n   * ```typescript\n   * getTextFormatter({\n   *   value(value, inspect) {\n   *     // Custom formatting for numbers\n   *     if (typeof value === 'number') {\n   *       return value.toFixed(2);\n   *     }\n   *     // Fall back to default for everything else\n   *     return inspect(value);\n   *   }\n   * })\n   * ```\n   */\n  value?: (\n    value: unknown,\n    inspect: (value: unknown, options?: { colors?: boolean }) => string,\n  ) => string;\n\n  /**\n   * How those formatted parts are concatenated.\n   *\n   * A function that formats the log record.  This function is called with the\n   * formatted values and should return a string.  Note that the formatted\n   * *should not* include a newline character at the end.\n   *\n   * By default, this is a function that formats the log record as follows:\n   *\n   * ```\n   * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!\n   * ```\n   * @param values The formatted values.\n   * @returns The formatted log record.\n   */\n  format?: (values: FormattedValues) => string;\n}\n\n// Optimized helper functions for timestamp formatting\nfunction padZero(num: number): string {\n  return num < 10 ? `0${num}` : `${num}`;\n}\n\nfunction padThree(num: number): string {\n  return num < 10 ? `00${num}` : num < 100 ? `0${num}` : `${num}`;\n}\n\n// Pre-optimized timestamp formatter functions\nconst timestampFormatters = {\n  \"date-time-timezone\": (ts: number): string => {\n    const d = new Date(ts);\n    const year = d.getUTCFullYear();\n    const month = padZero(d.getUTCMonth() + 1);\n    const day = padZero(d.getUTCDate());\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms} +00:00`;\n  },\n  \"date-time-tz\": (ts: number): string => {\n    const d = new Date(ts);\n    const year = d.getUTCFullYear();\n    const month = padZero(d.getUTCMonth() + 1);\n    const day = padZero(d.getUTCDate());\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms} +00`;\n  },\n  \"date-time\": (ts: number): string => {\n    const d = new Date(ts);\n    const year = d.getUTCFullYear();\n    const month = padZero(d.getUTCMonth() + 1);\n    const day = padZero(d.getUTCDate());\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms}`;\n  },\n  \"time-timezone\": (ts: number): string => {\n    const d = new Date(ts);\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${hour}:${minute}:${second}.${ms} +00:00`;\n  },\n  \"time-tz\": (ts: number): string => {\n    const d = new Date(ts);\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${hour}:${minute}:${second}.${ms} +00`;\n  },\n  \"time\": (ts: number): string => {\n    const d = new Date(ts);\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${hour}:${minute}:${second}.${ms}`;\n  },\n  \"date\": (ts: number): string => {\n    const d = new Date(ts);\n    const year = d.getUTCFullYear();\n    const month = padZero(d.getUTCMonth() + 1);\n    const day = padZero(d.getUTCDate());\n    return `${year}-${month}-${day}`;\n  },\n  \"rfc3339\": (ts: number): string => new Date(ts).toISOString(),\n  \"none\": (): null => null,\n} as const;\n\n// Pre-computed level renderers for common cases\nconst levelRenderersCache = {\n  ABBR: levelAbbreviations,\n  abbr: {\n    trace: \"trc\",\n    debug: \"dbg\",\n    info: \"inf\",\n    warning: \"wrn\",\n    error: \"err\",\n    fatal: \"ftl\",\n  } as const,\n  FULL: {\n    trace: \"TRACE\",\n    debug: \"DEBUG\",\n    info: \"INFO\",\n    warning: \"WARNING\",\n    error: \"ERROR\",\n    fatal: \"FATAL\",\n  } as const,\n  full: {\n    trace: \"trace\",\n    debug: \"debug\",\n    info: \"info\",\n    warning: \"warning\",\n    error: \"error\",\n    fatal: \"fatal\",\n  } as const,\n  L: {\n    trace: \"T\",\n    debug: \"D\",\n    info: \"I\",\n    warning: \"W\",\n    error: \"E\",\n    fatal: \"F\",\n  } as const,\n  l: {\n    trace: \"t\",\n    debug: \"d\",\n    info: \"i\",\n    warning: \"w\",\n    error: \"e\",\n    fatal: \"f\",\n  } as const,\n} as const;\n\n/**\n * Get a text formatter with the specified options.  Although it's flexible\n * enough to create a custom formatter, if you want more control, you can\n * create a custom formatter that satisfies the {@link TextFormatter} type\n * instead.\n *\n * For more information on the options, see {@link TextFormatterOptions}.\n *\n * By default, the formatter formats log records as follows:\n *\n * ```\n * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!\n * ```\n * @param options The options for the text formatter.\n * @returns The text formatter.\n * @since 0.6.0\n */\nexport function getTextFormatter(\n  options: TextFormatterOptions = {},\n): TextFormatter {\n  // Pre-compute timestamp formatter with optimized lookup\n  const timestampRenderer = (() => {\n    const tsOption = options.timestamp;\n    if (tsOption == null) {\n      return timestampFormatters[\"date-time-timezone\"];\n    } else if (tsOption === \"disabled\") {\n      return timestampFormatters[\"none\"];\n    } else if (\n      typeof tsOption === \"string\" && tsOption in timestampFormatters\n    ) {\n      return timestampFormatters[tsOption as keyof typeof timestampFormatters];\n    } else {\n      return tsOption as (ts: number) => string | null;\n    }\n  })();\n\n  const categorySeparator = options.category ?? \"·\";\n  const valueRenderer = options.value\n    ? (v: unknown) => options.value!(v, inspect)\n    : inspect;\n\n  // Pre-compute level renderer for better performance\n  const levelRenderer = (() => {\n    const levelOption = options.level;\n    if (levelOption == null || levelOption === \"ABBR\") {\n      return (level: LogLevel): string => levelRenderersCache.ABBR[level];\n    } else if (levelOption === \"abbr\") {\n      return (level: LogLevel): string => levelRenderersCache.abbr[level];\n    } else if (levelOption === \"FULL\") {\n      return (level: LogLevel): string => levelRenderersCache.FULL[level];\n    } else if (levelOption === \"full\") {\n      return (level: LogLevel): string => levelRenderersCache.full[level];\n    } else if (levelOption === \"L\") {\n      return (level: LogLevel): string => levelRenderersCache.L[level];\n    } else if (levelOption === \"l\") {\n      return (level: LogLevel): string => levelRenderersCache.l[level];\n    } else {\n      return levelOption;\n    }\n  })();\n\n  const formatter: (values: FormattedValues) => string = options.format ??\n    (({ timestamp, level, category, message }: FormattedValues) =>\n      `${timestamp ? `${timestamp} ` : \"\"}[${level}] ${category}: ${message}`);\n\n  return (record: LogRecord): string => {\n    // Optimized message building\n    const msgParts = record.message;\n    const msgLen = msgParts.length;\n\n    let message: string;\n    if (msgLen === 1) {\n      // Fast path for simple messages with no interpolation\n      message = msgParts[0] as string;\n    } else if (msgLen <= 6) {\n      // Fast path for small messages - direct concatenation\n      message = \"\";\n      for (let i = 0; i < msgLen; i++) {\n        message += (i % 2 === 0) ? msgParts[i] : valueRenderer(msgParts[i]);\n      }\n    } else {\n      // Optimized path for larger messages - array join\n      const parts: string[] = new Array(msgLen);\n      for (let i = 0; i < msgLen; i++) {\n        parts[i] = (i % 2 === 0)\n          ? msgParts[i] as string\n          : valueRenderer(msgParts[i]);\n      }\n      message = parts.join(\"\");\n    }\n\n    const timestamp = timestampRenderer(record.timestamp);\n    const level = levelRenderer(record.level);\n    const category = typeof categorySeparator === \"function\"\n      ? categorySeparator(record.category)\n      : record.category.join(categorySeparator);\n\n    const values: FormattedValues = {\n      timestamp,\n      level,\n      category,\n      message,\n      record,\n    };\n    return `${formatter(values)}\\n`;\n  };\n}\n\n/**\n * The default text formatter.  This formatter formats log records as follows:\n *\n * ```\n * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!\n * ```\n *\n * @param record The log record to format.\n * @returns The formatted log record.\n */\nexport const defaultTextFormatter: TextFormatter = getTextFormatter();\n\nconst RESET = \"\\x1b[0m\";\n\n/**\n * The ANSI colors.  These can be used to colorize text in the console.\n * @since 0.6.0\n */\nexport type AnsiColor =\n  | \"black\"\n  | \"red\"\n  | \"green\"\n  | \"yellow\"\n  | \"blue\"\n  | \"magenta\"\n  | \"cyan\"\n  | \"white\";\n\nconst ansiColors: Record<AnsiColor, string> = {\n  black: \"\\x1b[30m\",\n  red: \"\\x1b[31m\",\n  green: \"\\x1b[32m\",\n  yellow: \"\\x1b[33m\",\n  blue: \"\\x1b[34m\",\n  magenta: \"\\x1b[35m\",\n  cyan: \"\\x1b[36m\",\n  white: \"\\x1b[37m\",\n};\n\n/**\n * The ANSI text styles.\n * @since 0.6.0\n */\nexport type AnsiStyle =\n  | \"bold\"\n  | \"dim\"\n  | \"italic\"\n  | \"underline\"\n  | \"strikethrough\";\n\nconst ansiStyles: Record<AnsiStyle, string> = {\n  bold: \"\\x1b[1m\",\n  dim: \"\\x1b[2m\",\n  italic: \"\\x1b[3m\",\n  underline: \"\\x1b[4m\",\n  strikethrough: \"\\x1b[9m\",\n};\n\nconst defaultLevelColors: Record<LogLevel, AnsiColor | null> = {\n  trace: null,\n  debug: \"blue\",\n  info: \"green\",\n  warning: \"yellow\",\n  error: \"red\",\n  fatal: \"magenta\",\n};\n\n/**\n * The various options for the ANSI color formatter.\n * @since 0.6.0\n */\nexport interface AnsiColorFormatterOptions extends TextFormatterOptions {\n  /**\n   * The timestamp format.  This can be one of the following:\n   *\n   * - `\"date-time-timezone\"`: The date and time with the full timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000 +00:00\"`).\n   * - `\"date-time-tz\"`: The date and time with the short timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000 +00\"`).\n   * - `\"date-time\"`: The date and time without the timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000\"`).\n   * - `\"time-timezone\"`: The time with the full timezone offset but without\n   *   the date (e.g., `\"22:13:20.000 +00:00\"`).\n   * - `\"time-tz\"`: The time with the short timezone offset but without the date\n   *   (e.g., `\"22:13:20.000 +00\"`).\n   * - `\"time\"`: The time without the date or timezone offset\n   *   (e.g., `\"22:13:20.000\"`).\n   * - `\"date\"`: The date without the time or timezone offset\n   *   (e.g., `\"2023-11-14\"`).\n   * - `\"rfc3339\"`: The date and time in RFC 3339 format\n   *   (e.g., `\"2023-11-14T22:13:20.000Z\"`).\n   *\n   * Alternatively, this can be a function that accepts a timestamp and returns\n   * a string.\n   *\n   * The default is `\"date-time-tz\"`.\n   */\n  timestamp?:\n    | \"date-time-timezone\"\n    | \"date-time-tz\"\n    | \"date-time\"\n    | \"time-timezone\"\n    | \"time-tz\"\n    | \"time\"\n    | \"date\"\n    | \"rfc3339\"\n    | ((ts: number) => string);\n\n  /**\n   * The ANSI style for the timestamp.  `\"dim\"` is used by default.\n   */\n  timestampStyle?: AnsiStyle | null;\n\n  /**\n   * The ANSI color for the timestamp.  No color is used by default.\n   */\n  timestampColor?: AnsiColor | null;\n\n  /**\n   * The ANSI style for the log level.  `\"bold\"` is used by default.\n   */\n  levelStyle?: AnsiStyle | null;\n\n  /**\n   * The ANSI colors for the log levels.  The default colors are as follows:\n   *\n   * - `\"trace\"`: `null` (no color)\n   * - `\"debug\"`: `\"blue\"`\n   * - `\"info\"`: `\"green\"`\n   * - `\"warning\"`: `\"yellow\"`\n   * - `\"error\"`: `\"red\"`\n   * - `\"fatal\"`: `\"magenta\"`\n   */\n  levelColors?: Record<LogLevel, AnsiColor | null>;\n\n  /**\n   * The ANSI style for the category.  `\"dim\"` is used by default.\n   */\n  categoryStyle?: AnsiStyle | null;\n\n  /**\n   * The ANSI color for the category.  No color is used by default.\n   */\n  categoryColor?: AnsiColor | null;\n}\n\n/**\n * Get an ANSI color formatter with the specified options.\n *\n * ![A preview of an ANSI color formatter.](https://i.imgur.com/I8LlBUf.png)\n * @param option The options for the ANSI color formatter.\n * @returns The ANSI color formatter.\n * @since 0.6.0\n */\nexport function getAnsiColorFormatter(\n  options: AnsiColorFormatterOptions = {},\n): TextFormatter {\n  const format = options.format;\n  const timestampStyle = typeof options.timestampStyle === \"undefined\"\n    ? \"dim\"\n    : options.timestampStyle;\n  const timestampColor = options.timestampColor ?? null;\n  const timestampPrefix = `${\n    timestampStyle == null ? \"\" : ansiStyles[timestampStyle]\n  }${timestampColor == null ? \"\" : ansiColors[timestampColor]}`;\n  const timestampSuffix = timestampStyle == null && timestampColor == null\n    ? \"\"\n    : RESET;\n  const levelStyle = typeof options.levelStyle === \"undefined\"\n    ? \"bold\"\n    : options.levelStyle;\n  const levelColors = options.levelColors ?? defaultLevelColors;\n  const categoryStyle = typeof options.categoryStyle === \"undefined\"\n    ? \"dim\"\n    : options.categoryStyle;\n  const categoryColor = options.categoryColor ?? null;\n  const categoryPrefix = `${\n    categoryStyle == null ? \"\" : ansiStyles[categoryStyle]\n  }${categoryColor == null ? \"\" : ansiColors[categoryColor]}`;\n  const categorySuffix = categoryStyle == null && categoryColor == null\n    ? \"\"\n    : RESET;\n  return getTextFormatter({\n    timestamp: \"date-time-tz\",\n    value(value: unknown, fallbackInspect): string {\n      return fallbackInspect(value, { colors: true });\n    },\n    ...options,\n    format({ timestamp, level, category, message, record }): string {\n      const levelColor = levelColors[record.level];\n      timestamp = `${timestampPrefix}${timestamp}${timestampSuffix}`;\n      level = `${levelStyle == null ? \"\" : ansiStyles[levelStyle]}${\n        levelColor == null ? \"\" : ansiColors[levelColor]\n      }${level}${levelStyle == null && levelColor == null ? \"\" : RESET}`;\n      return format == null\n        ? `${timestamp} ${level} ${categoryPrefix}${category}:${categorySuffix} ${message}`\n        : format({\n          timestamp,\n          level,\n          category: `${categoryPrefix}${category}${categorySuffix}`,\n          message,\n          record,\n        });\n    },\n  });\n}\n\n/**\n * A text formatter that uses ANSI colors to format log records.\n *\n * ![A preview of ansiColorFormatter.](https://i.imgur.com/I8LlBUf.png)\n *\n * @param record The log record to format.\n * @returns The formatted log record.\n * @since 0.5.0\n */\nexport const ansiColorFormatter: TextFormatter = getAnsiColorFormatter();\n\n/**\n * Options for the {@link getJsonLinesFormatter} function.\n * @since 0.11.0\n */\nexport interface JsonLinesFormatterOptions {\n  /**\n   * The separator between category names.  For example, if the separator is\n   * `\".\"`, the category `[\"a\", \"b\", \"c\"]` will be formatted as `\"a.b.c\"`.\n   * If this is a function, it will be called with the category array and\n   * should return a string or an array of strings, which will be used\n   * for rendering the category.\n   *\n   * @default `\".\"`\n   */\n  readonly categorySeparator?:\n    | string\n    | ((category: readonly string[]) => string | readonly string[]);\n\n  /**\n   * The message format.  This can be one of the following:\n   *\n   * - `\"template\"`: The raw message template is used as the message.\n   * - `\"rendered\"`: The message is rendered with the values.\n   *\n   * @default `\"rendered\"`\n   */\n  readonly message?: \"template\" | \"rendered\";\n\n  /**\n   * The properties format.  This can be one of the following:\n   *\n   * - `\"flatten\"`: The properties are flattened into the root object.\n   * - `\"prepend:<prefix>\"`: The properties are prepended with the given prefix\n   *   (e.g., `\"prepend:ctx_\"` will prepend `ctx_` to each property key).\n   * - `\"nest:<key>\"`: The properties are nested under the given key\n   *   (e.g., `\"nest:properties\"` will nest the properties under the\n   *   `properties` key).\n   *\n   * @default `\"nest:properties\"`\n   */\n  readonly properties?: \"flatten\" | `prepend:${string}` | `nest:${string}`;\n}\n\n/**\n * Get a [JSON Lines] formatter with the specified options.  The log records\n * will be rendered as JSON objects, one per line, which is a common format\n * for log files.  This format is also known as Newline-Delimited JSON (NDJSON).\n * It looks like this:\n *\n * ```json\n * {\"@timestamp\":\"2023-11-14T22:13:20.000Z\",\"level\":\"INFO\",\"message\":\"Hello, world!\",\"logger\":\"my.logger\",\"properties\":{\"key\":\"value\"}}\n * ```\n *\n * [JSON Lines]: https://jsonlines.org/\n * @param options The options for the JSON Lines formatter.\n * @returns The JSON Lines formatter.\n * @since 0.11.0\n */\nexport function getJsonLinesFormatter(\n  options: JsonLinesFormatterOptions = {},\n): TextFormatter {\n  // Most common configuration - optimize for the default case\n  if (!options.categorySeparator && !options.message && !options.properties) {\n    // Ultra-minimalist path - eliminate all possible overhead\n    return (record: LogRecord): string => {\n      // Direct benchmark pattern match (most common case first)\n      if (record.message.length === 3) {\n        return JSON.stringify({\n          \"@timestamp\": new Date(record.timestamp).toISOString(),\n          level: record.level === \"warning\"\n            ? \"WARN\"\n            : record.level.toUpperCase(),\n          message: record.message[0] + JSON.stringify(record.message[1]) +\n            record.message[2],\n          logger: record.category.join(\".\"),\n          properties: record.properties,\n        }) + \"\\n\";\n      }\n\n      // Single message (second most common)\n      if (record.message.length === 1) {\n        return JSON.stringify({\n          \"@timestamp\": new Date(record.timestamp).toISOString(),\n          level: record.level === \"warning\"\n            ? \"WARN\"\n            : record.level.toUpperCase(),\n          message: record.message[0],\n          logger: record.category.join(\".\"),\n          properties: record.properties,\n        }) + \"\\n\";\n      }\n\n      // Complex messages (fallback)\n      let msg = record.message[0] as string;\n      for (let i = 1; i < record.message.length; i++) {\n        msg += (i & 1) ? JSON.stringify(record.message[i]) : record.message[i];\n      }\n\n      return JSON.stringify({\n        \"@timestamp\": new Date(record.timestamp).toISOString(),\n        level: record.level === \"warning\" ? \"WARN\" : record.level.toUpperCase(),\n        message: msg,\n        logger: record.category.join(\".\"),\n        properties: record.properties,\n      }) + \"\\n\";\n    };\n  }\n\n  // Pre-compile configuration for non-default cases\n  const isTemplateMessage = options.message === \"template\";\n  const propertiesOption = options.properties ?? \"nest:properties\";\n\n  // Pre-compile category joining strategy\n  let joinCategory: (category: readonly string[]) => string | readonly string[];\n  if (typeof options.categorySeparator === \"function\") {\n    joinCategory = options.categorySeparator;\n  } else {\n    const separator = options.categorySeparator ?? \".\";\n    joinCategory = (category: readonly string[]): string =>\n      category.join(separator);\n  }\n\n  // Pre-compile properties handling strategy\n  let getProperties: (\n    properties: Record<string, unknown>,\n  ) => Record<string, unknown>;\n\n  if (propertiesOption === \"flatten\") {\n    getProperties = (properties) => properties;\n  } else if (propertiesOption.startsWith(\"prepend:\")) {\n    const prefix = propertiesOption.substring(8);\n    if (prefix === \"\") {\n      throw new TypeError(\n        `Invalid properties option: ${\n          JSON.stringify(propertiesOption)\n        }. It must be of the form \"prepend:<prefix>\" where <prefix> is a non-empty string.`,\n      );\n    }\n    getProperties = (properties) => {\n      const result: Record<string, unknown> = {};\n      for (const key in properties) {\n        result[`${prefix}${key}`] = properties[key];\n      }\n      return result;\n    };\n  } else if (propertiesOption.startsWith(\"nest:\")) {\n    const key = propertiesOption.substring(5);\n    getProperties = (properties) => ({ [key]: properties });\n  } else {\n    throw new TypeError(\n      `Invalid properties option: ${\n        JSON.stringify(propertiesOption)\n      }. It must be \"flatten\", \"prepend:<prefix>\", or \"nest:<key>\".`,\n    );\n  }\n\n  // Pre-compile message rendering function\n  let getMessage: (record: LogRecord) => string;\n\n  if (isTemplateMessage) {\n    getMessage = (record: LogRecord): string => {\n      if (typeof record.rawMessage === \"string\") {\n        return record.rawMessage;\n      }\n      let msg = \"\";\n      for (let i = 0; i < record.rawMessage.length; i++) {\n        msg += i % 2 < 1 ? record.rawMessage[i] : \"{}\";\n      }\n      return msg;\n    };\n  } else {\n    getMessage = (record: LogRecord): string => {\n      const msgLen = record.message.length;\n\n      if (msgLen === 1) {\n        return record.message[0] as string;\n      }\n\n      let msg = \"\";\n      for (let i = 0; i < msgLen; i++) {\n        msg += (i % 2 < 1)\n          ? record.message[i]\n          : JSON.stringify(record.message[i]);\n      }\n      return msg;\n    };\n  }\n\n  return (record: LogRecord): string => {\n    return JSON.stringify({\n      \"@timestamp\": new Date(record.timestamp).toISOString(),\n      level: record.level === \"warning\" ? \"WARN\" : record.level.toUpperCase(),\n      message: getMessage(record),\n      logger: joinCategory(record.category),\n      ...getProperties(record.properties),\n    }) + \"\\n\";\n  };\n}\n\n/**\n * The default [JSON Lines] formatter.  This formatter formats log records\n * as JSON objects, one per line, which is a common format for log files.\n * It looks like this:\n *\n * ```json\n * {\"@timestamp\":\"2023-11-14T22:13:20.000Z\",\"level\":\"INFO\",\"message\":\"Hello, world!\",\"logger\":\"my.logger\",\"properties\":{\"key\":\"value\"}}\n * ```\n *\n * You can customize the output by passing options to\n * {@link getJsonLinesFormatter}.  For example, you can change the category\n * separator, the message format, and how the properties are formatted.\n *\n * [JSON Lines]: https://jsonlines.org/\n * @since 0.11.0\n */\nexport const jsonLinesFormatter: TextFormatter = getJsonLinesFormatter();\n\n/**\n * A console formatter is a function that accepts a log record and returns\n * an array of arguments to pass to {@link console.log}.\n *\n * @param record The log record to format.\n * @returns The formatted log record, as an array of arguments for\n *          {@link console.log}.\n */\nexport type ConsoleFormatter = (record: LogRecord) => readonly unknown[];\n\n/**\n * The styles for the log level in the console.\n */\nconst logLevelStyles: Record<LogLevel, string> = {\n  \"trace\": \"background-color: gray; color: white;\",\n  \"debug\": \"background-color: gray; color: white;\",\n  \"info\": \"background-color: white; color: black;\",\n  \"warning\": \"background-color: orange; color: black;\",\n  \"error\": \"background-color: red; color: white;\",\n  \"fatal\": \"background-color: maroon; color: white;\",\n};\n\n/**\n * The default console formatter.\n *\n * @param record The log record to format.\n * @returns The formatted log record, as an array of arguments for\n *          {@link console.log}.\n */\nexport function defaultConsoleFormatter(record: LogRecord): readonly unknown[] {\n  let msg = \"\";\n  const values: unknown[] = [];\n  for (let i = 0; i < record.message.length; i++) {\n    if (i % 2 === 0) msg += record.message[i];\n    else {\n      msg += \"%o\";\n      values.push(record.message[i]);\n    }\n  }\n  const date = new Date(record.timestamp);\n  const time = `${date.getUTCHours().toString().padStart(2, \"0\")}:${\n    date.getUTCMinutes().toString().padStart(2, \"0\")\n  }:${date.getUTCSeconds().toString().padStart(2, \"0\")}.${\n    date.getUTCMilliseconds().toString().padStart(3, \"0\")\n  }`;\n  return [\n    `%c${time} %c${levelAbbreviations[record.level]}%c %c${\n      record.category.join(\"\\xb7\")\n    } %c${msg}`,\n    \"color: gray;\",\n    logLevelStyles[record.level],\n    \"background-color: default;\",\n    \"color: gray;\",\n    \"color: default;\",\n    ...values,\n  ];\n}\n"],"mappings":"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"}