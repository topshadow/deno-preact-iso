{"version":3,"file":"config.js","names":["currentConfig: Config<string, string> | null","strongRefs: Set<LoggerImpl>","disposables: Set<Disposable>","asyncDisposables: Set<AsyncDisposable>","cfg: LoggerConfig<TSinkId, TFilterId>","config: Config<TSinkId, TFilterId>","allowAsync: boolean","promises: PromiseLike<void>[]","message: string"],"sources":["../src/config.ts"],"sourcesContent":["import type { ContextLocalStorage } from \"./context.ts\";\nimport { type FilterLike, toFilter } from \"./filter.ts\";\nimport type { LogLevel } from \"./level.ts\";\nimport { LoggerImpl } from \"./logger.ts\";\nimport { getConsoleSink, type Sink } from \"./sink.ts\";\n\n/**\n * A configuration for the loggers.\n */\nexport interface Config<TSinkId extends string, TFilterId extends string> {\n  /**\n   * The sinks to use.  The keys are the sink identifiers, and the values are\n   * {@link Sink}s.\n   */\n  sinks: Record<TSinkId, Sink>;\n  /**\n   * The filters to use.  The keys are the filter identifiers, and the values\n   * are either {@link Filter}s or {@link LogLevel}s.\n   */\n  filters?: Record<TFilterId, FilterLike>;\n\n  /**\n   * The loggers to configure.\n   */\n  loggers: LoggerConfig<TSinkId, TFilterId>[];\n\n  /**\n   * The context-local storage to use for implicit contexts.\n   * @since 0.7.0\n   */\n  contextLocalStorage?: ContextLocalStorage<Record<string, unknown>>;\n\n  /**\n   * Whether to reset the configuration before applying this one.\n   */\n  reset?: boolean;\n}\n\n/**\n * A logger configuration.\n */\nexport interface LoggerConfig<\n  TSinkId extends string,\n  TFilterId extends string,\n> {\n  /**\n   * The category of the logger.  If a string, it is equivalent to an array\n   * with one element.\n   */\n  category: string | string[];\n\n  /**\n   * The sink identifiers to use.\n   */\n  sinks?: TSinkId[];\n\n  /**\n   * Whether to inherit the parent's sinks.  If `inherit`, the parent's sinks\n   * are used along with the specified sinks.  If `override`, the parent's\n   * sinks are not used, and only the specified sinks are used.\n   *\n   * The default is `inherit`.\n   * @default `\"inherit\"\n   * @since 0.6.0\n   */\n  parentSinks?: \"inherit\" | \"override\";\n\n  /**\n   * The filter identifiers to use.\n   */\n  filters?: TFilterId[];\n\n  /**\n   * The lowest log level to accept.  If `null`, the logger will reject all\n   * records.\n   * @since 0.8.0\n   */\n  lowestLevel?: LogLevel | null;\n}\n\n/**\n * The current configuration, if any.  Otherwise, `null`.\n */\nlet currentConfig: Config<string, string> | null = null;\n\n/**\n * Strong references to the loggers.\n * This is to prevent the loggers from being garbage collected so that their\n * sinks and filters are not removed.\n */\nconst strongRefs: Set<LoggerImpl> = new Set();\n\n/**\n * Disposables to dispose when resetting the configuration.\n */\nconst disposables: Set<Disposable> = new Set();\n\n/**\n * Async disposables to dispose when resetting the configuration.\n */\nconst asyncDisposables: Set<AsyncDisposable> = new Set();\n\n/**\n * Check if a config is for the meta logger.\n */\nfunction isLoggerConfigMeta<TSinkId extends string, TFilterId extends string>(\n  cfg: LoggerConfig<TSinkId, TFilterId>,\n): boolean {\n  return cfg.category.length === 0 ||\n    (cfg.category.length === 1 && cfg.category[0] === \"logtape\") ||\n    (cfg.category.length === 2 &&\n      cfg.category[0] === \"logtape\" &&\n      cfg.category[1] === \"meta\");\n}\n\n/**\n * Configure the loggers with the specified configuration.\n *\n * Note that if the given sinks or filters are disposable, they will be\n * disposed when the configuration is reset, or when the process exits.\n *\n * @example\n * ```typescript\n * await configure({\n *   sinks: {\n *     console: getConsoleSink(),\n *   },\n *   filters: {\n *     slow: (log) =>\n *       \"duration\" in log.properties &&\n *       log.properties.duration as number > 1000,\n *   },\n *   loggers: [\n *     {\n *       category: \"my-app\",\n *       sinks: [\"console\"],\n *       lowestLevel: \"info\",\n *     },\n *     {\n *       category: [\"my-app\", \"sql\"],\n *       filters: [\"slow\"],\n *       lowestLevel: \"debug\",\n *     },\n *     {\n *       category: \"logtape\",\n *       sinks: [\"console\"],\n *       lowestLevel: \"error\",\n *     },\n *   ],\n * });\n * ```\n *\n * @param config The configuration.\n */\nexport async function configure<\n  TSinkId extends string,\n  TFilterId extends string,\n>(config: Config<TSinkId, TFilterId>): Promise<void> {\n  if (currentConfig != null && !config.reset) {\n    throw new ConfigError(\n      \"Already configured; if you want to reset, turn on the reset flag.\",\n    );\n  }\n  await reset();\n  try {\n    configureInternal(config, true);\n  } catch (e) {\n    if (e instanceof ConfigError) await reset();\n    throw e;\n  }\n}\n\n/**\n * Configure sync loggers with the specified configuration.\n *\n * Note that if the given sinks or filters are disposable, they will be\n * disposed when the configuration is reset, or when the process exits.\n *\n * Also note that passing async sinks or filters will throw. If\n * necessary use {@link resetSync} or {@link disposeSync}.\n *\n * @example\n * ```typescript\n * configureSync({\n *   sinks: {\n *     console: getConsoleSink(),\n *   },\n *   loggers: [\n *     {\n *       category: \"my-app\",\n *       sinks: [\"console\"],\n *       lowestLevel: \"info\",\n *     },\n *     {\n *       category: \"logtape\",\n *       sinks: [\"console\"],\n *       lowestLevel: \"error\",\n *     },\n *   ],\n * });\n * ```\n *\n * @param config The configuration.\n * @since 0.9.0\n */\nexport function configureSync<TSinkId extends string, TFilterId extends string>(\n  config: Config<TSinkId, TFilterId>,\n): void {\n  if (currentConfig != null && !config.reset) {\n    throw new ConfigError(\n      \"Already configured; if you want to reset, turn on the reset flag.\",\n    );\n  }\n  if (asyncDisposables.size > 0) {\n    throw new ConfigError(\n      \"Previously configured async disposables are still active. \" +\n        \"Use configure() instead or explicitly dispose them using dispose().\",\n    );\n  }\n  resetSync();\n  try {\n    configureInternal(config, false);\n  } catch (e) {\n    if (e instanceof ConfigError) resetSync();\n    throw e;\n  }\n}\n\nfunction configureInternal<\n  TSinkId extends string,\n  TFilterId extends string,\n>(config: Config<TSinkId, TFilterId>, allowAsync: boolean): void {\n  currentConfig = config;\n\n  let metaConfigured = false;\n  const configuredCategories = new Set<string>();\n\n  for (const cfg of config.loggers) {\n    if (isLoggerConfigMeta(cfg)) {\n      metaConfigured = true;\n    }\n\n    // Check for duplicate logger categories\n    const categoryKey = Array.isArray(cfg.category)\n      ? JSON.stringify(cfg.category)\n      : JSON.stringify([cfg.category]);\n    if (configuredCategories.has(categoryKey)) {\n      throw new ConfigError(\n        `Duplicate logger configuration for category: ${categoryKey}. ` +\n          `Each category can only be configured once.`,\n      );\n    }\n    configuredCategories.add(categoryKey);\n\n    const logger = LoggerImpl.getLogger(cfg.category);\n    for (const sinkId of cfg.sinks ?? []) {\n      const sink = config.sinks[sinkId];\n      if (!sink) {\n        throw new ConfigError(`Sink not found: ${sinkId}.`);\n      }\n      logger.sinks.push(sink);\n    }\n    logger.parentSinks = cfg.parentSinks ?? \"inherit\";\n    if (cfg.lowestLevel !== undefined) {\n      logger.lowestLevel = cfg.lowestLevel;\n    }\n    for (const filterId of cfg.filters ?? []) {\n      const filter = config.filters?.[filterId];\n      if (filter === undefined) {\n        throw new ConfigError(`Filter not found: ${filterId}.`);\n      }\n      logger.filters.push(toFilter(filter));\n    }\n    strongRefs.add(logger);\n  }\n\n  LoggerImpl.getLogger().contextLocalStorage = config.contextLocalStorage;\n\n  for (const sink of Object.values<Sink>(config.sinks)) {\n    if (Symbol.asyncDispose in sink) {\n      if (allowAsync) asyncDisposables.add(sink as AsyncDisposable);\n      else {\n        throw new ConfigError(\n          \"Async disposables cannot be used with configureSync().\",\n        );\n      }\n    }\n    if (Symbol.dispose in sink) disposables.add(sink as Disposable);\n  }\n\n  for (const filter of Object.values<FilterLike>(config.filters ?? {})) {\n    if (filter == null || typeof filter === \"string\") continue;\n    if (Symbol.asyncDispose in filter) {\n      if (allowAsync) asyncDisposables.add(filter as AsyncDisposable);\n      else {\n        throw new ConfigError(\n          \"Async disposables cannot be used with configureSync().\",\n        );\n      }\n    }\n    if (Symbol.dispose in filter) disposables.add(filter as Disposable);\n  }\n\n  if (\n    // deno-lint-ignore no-explicit-any\n    typeof (globalThis as any).EdgeRuntime !== \"string\" &&\n    \"process\" in globalThis &&\n    !(\"Deno\" in globalThis)\n  ) {\n    // deno-lint-ignore no-explicit-any\n    const proc = (globalThis as any).process;\n    // Use bracket notation to avoid static analysis detection in Edge Runtime\n    const onMethod = proc?.[\"on\"];\n    if (typeof onMethod === \"function\") {\n      onMethod.call(proc, \"exit\", allowAsync ? dispose : disposeSync);\n    }\n  } else {\n    // @ts-ignore: It's fine to addEventListener() on the browser/Deno/Edge Runtime\n    addEventListener(\"unload\", allowAsync ? dispose : disposeSync);\n  }\n  const meta = LoggerImpl.getLogger([\"logtape\", \"meta\"]);\n  if (!metaConfigured) {\n    meta.sinks.push(getConsoleSink());\n  }\n\n  meta.info(\n    \"LogTape loggers are configured.  Note that LogTape itself uses the meta \" +\n      \"logger, which has category {metaLoggerCategory}.  The meta logger \" +\n      \"purposes to log internal errors such as sink exceptions.  If you \" +\n      \"are seeing this message, the meta logger is automatically configured.  \" +\n      \"It's recommended to configure the meta logger with a separate sink \" +\n      \"so that you can easily notice if logging itself fails or is \" +\n      \"misconfigured.  To turn off this message, configure the meta logger \" +\n      \"with higher log levels than {dismissLevel}.  See also \" +\n      \"<https://logtape.org/manual/categories#meta-logger>.\",\n    { metaLoggerCategory: [\"logtape\", \"meta\"], dismissLevel: \"info\" },\n  );\n}\n\n/**\n * Get the current configuration, if any.  Otherwise, `null`.\n * @returns The current configuration, if any.  Otherwise, `null`.\n */\nexport function getConfig(): Config<string, string> | null {\n  return currentConfig;\n}\n\n/**\n * Reset the configuration.  Mostly for testing purposes.\n */\nexport async function reset(): Promise<void> {\n  await dispose();\n  resetInternal();\n}\n\n/**\n * Reset the configuration.  Mostly for testing purposes. Will not clear async\n * sinks, only use with sync sinks. Use {@link reset} if you have async sinks.\n * @since 0.9.0\n */\nexport function resetSync(): void {\n  disposeSync();\n  resetInternal();\n}\n\nfunction resetInternal(): void {\n  const rootLogger = LoggerImpl.getLogger([]);\n  rootLogger.resetDescendants();\n  delete rootLogger.contextLocalStorage;\n  strongRefs.clear();\n  currentConfig = null;\n}\n\n/**\n * Dispose of the disposables.\n */\nexport async function dispose(): Promise<void> {\n  disposeSync();\n  const promises: PromiseLike<void>[] = [];\n  for (const disposable of asyncDisposables) {\n    promises.push(disposable[Symbol.asyncDispose]());\n    asyncDisposables.delete(disposable);\n  }\n  await Promise.all(promises);\n}\n\n/**\n * Dispose of the sync disposables. Async disposables will be untouched,\n * use {@link dispose} if you have async sinks.\n * @since 0.9.0\n */\nexport function disposeSync(): void {\n  for (const disposable of disposables) disposable[Symbol.dispose]();\n  disposables.clear();\n}\n\n/**\n * A configuration error.\n */\nexport class ConfigError extends Error {\n  /**\n   * Constructs a new configuration error.\n   * @param message The error message.\n   */\n  constructor(message: string) {\n    super(message);\n    this.name = \"ConfigureError\";\n  }\n}\n"],"mappings":"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"}