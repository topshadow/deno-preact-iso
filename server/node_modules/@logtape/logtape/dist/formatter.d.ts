import { LogLevel } from "./level.js";
import { LogRecord } from "./record.js";

//#region src/formatter.d.ts

/**
 * A text formatter is a function that accepts a log record and returns
 * a string.
 *
 * @param record The log record to format.
 * @returns The formatted log record.
 */
type TextFormatter = (record: LogRecord) => string;
/**
 * The formatted values for a log record.
 * @since 0.6.0
 */
interface FormattedValues {
  /**
   * The formatted timestamp.
   */
  timestamp: string | null;
  /**
   * The formatted log level.
   */
  level: string;
  /**
   * The formatted category.
   */
  category: string;
  /**
   * The formatted message.
   */
  message: string;
  /**
   * The unformatted log record.
   */
  record: LogRecord;
}
/**
 * The various options for the built-in text formatters.
 * @since 0.6.0
 */
interface TextFormatterOptions {
  /**
   * The timestamp format.  This can be one of the following:
   *
   * - `"date-time-timezone"`: The date and time with the full timezone offset
   *   (e.g., `"2023-11-14 22:13:20.000 +00:00"`).
   * - `"date-time-tz"`: The date and time with the short timezone offset
   *   (e.g., `"2023-11-14 22:13:20.000 +00"`).
   * - `"date-time"`: The date and time without the timezone offset
   *   (e.g., `"2023-11-14 22:13:20.000"`).
   * - `"time-timezone"`: The time with the full timezone offset but without
   *   the date (e.g., `"22:13:20.000 +00:00"`).
   * - `"time-tz"`: The time with the short timezone offset but without the date
   *   (e.g., `"22:13:20.000 +00"`).
   * - `"time"`: The time without the date or timezone offset
   *   (e.g., `"22:13:20.000"`).
   * - `"date"`: The date without the time or timezone offset
   *   (e.g., `"2023-11-14"`).
   * - `"rfc3339"`: The date and time in RFC 3339 format
   *   (e.g., `"2023-11-14T22:13:20.000Z"`).
   * - `"none"` or `"disabled"`: No display
   *
   * Alternatively, this can be a function that accepts a timestamp and returns
   * a string.
   *
   * The default is `"date-time-timezone"`.
   */
  timestamp?: "date-time-timezone" | "date-time-tz" | "date-time" | "time-timezone" | "time-tz" | "time" | "date" | "rfc3339" | "none" | "disabled" | ((ts: number) => string | null);
  /**
   * The log level format.  This can be one of the following:
   *
   * - `"ABBR"`: The log level abbreviation in uppercase (e.g., `"INF"`).
   * - `"FULL"`: The full log level name in uppercase (e.g., `"INFO"`).
   * - `"L"`: The first letter of the log level in uppercase (e.g., `"I"`).
   * - `"abbr"`: The log level abbreviation in lowercase (e.g., `"inf"`).
   * - `"full"`: The full log level name in lowercase (e.g., `"info"`).
   * - `"l"`: The first letter of the log level in lowercase (e.g., `"i"`).
   *
   * Alternatively, this can be a function that accepts a log level and returns
   * a string.
   *
   * The default is `"ABBR"`.
   */
  level?: "ABBR" | "FULL" | "L" | "abbr" | "full" | "l" | ((level: LogLevel) => string);
  /**
   * The separator between category names.  For example, if the separator is
   * `"·"`, the category `["a", "b", "c"]` will be formatted as `"a·b·c"`.
   * The default separator is `"·"`.
   *
   * If this is a function, it will be called with the category array and
   * should return a string, which will be used for rendering the category.
   */
  category?: string | ((category: readonly string[]) => string);
  /**
   * The format of the embedded values.
   *
   * A function that renders a value to a string.  This function is used to
   * render the values in the log record.  The default is a cross-runtime
   * `inspect()` function that uses [`util.inspect()`] in Node.js/Bun,
   * [`Deno.inspect()`] in Deno, or falls back to {@link JSON.stringify} in
   * browsers.
   *
   * The second parameter provides access to the default cross-runtime
   * `inspect()` function, allowing you to fall back to the default behavior
   * for certain values while customizing others.  You can ignore this
   * parameter if you don't need the fallback functionality.
   *
   * [`util.inspect()`]: https://nodejs.org/api/util.html#utilinspectobject-options
   * [`Deno.inspect()`]: https://docs.deno.com/api/deno/~/Deno.inspect
   * @param value The value to render.
   * @param inspect The default cross-runtime inspect function that can be used
   *                as a fallback.  Accepts an optional `options` parameter
   *                with a `colors` boolean field.
   * @returns The string representation of the value.
   * @example
   * ```typescript
   * getTextFormatter({
   *   value(value, inspect) {
   *     // Custom formatting for numbers
   *     if (typeof value === 'number') {
   *       return value.toFixed(2);
   *     }
   *     // Fall back to default for everything else
   *     return inspect(value);
   *   }
   * })
   * ```
   */
  value?: (value: unknown, inspect: (value: unknown, options?: {
    colors?: boolean;
  }) => string) => string;
  /**
   * How those formatted parts are concatenated.
   *
   * A function that formats the log record.  This function is called with the
   * formatted values and should return a string.  Note that the formatted
   * *should not* include a newline character at the end.
   *
   * By default, this is a function that formats the log record as follows:
   *
   * ```
   * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!
   * ```
   * @param values The formatted values.
   * @returns The formatted log record.
   */
  format?: (values: FormattedValues) => string;
}
/**
 * Get a text formatter with the specified options.  Although it's flexible
 * enough to create a custom formatter, if you want more control, you can
 * create a custom formatter that satisfies the {@link TextFormatter} type
 * instead.
 *
 * For more information on the options, see {@link TextFormatterOptions}.
 *
 * By default, the formatter formats log records as follows:
 *
 * ```
 * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!
 * ```
 * @param options The options for the text formatter.
 * @returns The text formatter.
 * @since 0.6.0
 */
declare function getTextFormatter(options?: TextFormatterOptions): TextFormatter;
/**
 * The default text formatter.  This formatter formats log records as follows:
 *
 * ```
 * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!
 * ```
 *
 * @param record The log record to format.
 * @returns The formatted log record.
 */
declare const defaultTextFormatter: TextFormatter;
/**
 * The ANSI colors.  These can be used to colorize text in the console.
 * @since 0.6.0
 */
type AnsiColor = "black" | "red" | "green" | "yellow" | "blue" | "magenta" | "cyan" | "white";
/**
 * The ANSI text styles.
 * @since 0.6.0
 */
type AnsiStyle = "bold" | "dim" | "italic" | "underline" | "strikethrough";
/**
 * The various options for the ANSI color formatter.
 * @since 0.6.0
 */
interface AnsiColorFormatterOptions extends TextFormatterOptions {
  /**
   * The timestamp format.  This can be one of the following:
   *
   * - `"date-time-timezone"`: The date and time with the full timezone offset
   *   (e.g., `"2023-11-14 22:13:20.000 +00:00"`).
   * - `"date-time-tz"`: The date and time with the short timezone offset
   *   (e.g., `"2023-11-14 22:13:20.000 +00"`).
   * - `"date-time"`: The date and time without the timezone offset
   *   (e.g., `"2023-11-14 22:13:20.000"`).
   * - `"time-timezone"`: The time with the full timezone offset but without
   *   the date (e.g., `"22:13:20.000 +00:00"`).
   * - `"time-tz"`: The time with the short timezone offset but without the date
   *   (e.g., `"22:13:20.000 +00"`).
   * - `"time"`: The time without the date or timezone offset
   *   (e.g., `"22:13:20.000"`).
   * - `"date"`: The date without the time or timezone offset
   *   (e.g., `"2023-11-14"`).
   * - `"rfc3339"`: The date and time in RFC 3339 format
   *   (e.g., `"2023-11-14T22:13:20.000Z"`).
   *
   * Alternatively, this can be a function that accepts a timestamp and returns
   * a string.
   *
   * The default is `"date-time-tz"`.
   */
  timestamp?: "date-time-timezone" | "date-time-tz" | "date-time" | "time-timezone" | "time-tz" | "time" | "date" | "rfc3339" | ((ts: number) => string);
  /**
   * The ANSI style for the timestamp.  `"dim"` is used by default.
   */
  timestampStyle?: AnsiStyle | null;
  /**
   * The ANSI color for the timestamp.  No color is used by default.
   */
  timestampColor?: AnsiColor | null;
  /**
   * The ANSI style for the log level.  `"bold"` is used by default.
   */
  levelStyle?: AnsiStyle | null;
  /**
   * The ANSI colors for the log levels.  The default colors are as follows:
   *
   * - `"trace"`: `null` (no color)
   * - `"debug"`: `"blue"`
   * - `"info"`: `"green"`
   * - `"warning"`: `"yellow"`
   * - `"error"`: `"red"`
   * - `"fatal"`: `"magenta"`
   */
  levelColors?: Record<LogLevel, AnsiColor | null>;
  /**
   * The ANSI style for the category.  `"dim"` is used by default.
   */
  categoryStyle?: AnsiStyle | null;
  /**
   * The ANSI color for the category.  No color is used by default.
   */
  categoryColor?: AnsiColor | null;
}
/**
 * Get an ANSI color formatter with the specified options.
 *
 * ![A preview of an ANSI color formatter.](https://i.imgur.com/I8LlBUf.png)
 * @param option The options for the ANSI color formatter.
 * @returns The ANSI color formatter.
 * @since 0.6.0
 */
declare function getAnsiColorFormatter(options?: AnsiColorFormatterOptions): TextFormatter;
/**
 * A text formatter that uses ANSI colors to format log records.
 *
 * ![A preview of ansiColorFormatter.](https://i.imgur.com/I8LlBUf.png)
 *
 * @param record The log record to format.
 * @returns The formatted log record.
 * @since 0.5.0
 */
declare const ansiColorFormatter: TextFormatter;
/**
 * Options for the {@link getJsonLinesFormatter} function.
 * @since 0.11.0
 */
interface JsonLinesFormatterOptions {
  /**
   * The separator between category names.  For example, if the separator is
   * `"."`, the category `["a", "b", "c"]` will be formatted as `"a.b.c"`.
   * If this is a function, it will be called with the category array and
   * should return a string or an array of strings, which will be used
   * for rendering the category.
   *
   * @default `"."`
   */
  readonly categorySeparator?: string | ((category: readonly string[]) => string | readonly string[]);
  /**
   * The message format.  This can be one of the following:
   *
   * - `"template"`: The raw message template is used as the message.
   * - `"rendered"`: The message is rendered with the values.
   *
   * @default `"rendered"`
   */
  readonly message?: "template" | "rendered";
  /**
   * The properties format.  This can be one of the following:
   *
   * - `"flatten"`: The properties are flattened into the root object.
   * - `"prepend:<prefix>"`: The properties are prepended with the given prefix
   *   (e.g., `"prepend:ctx_"` will prepend `ctx_` to each property key).
   * - `"nest:<key>"`: The properties are nested under the given key
   *   (e.g., `"nest:properties"` will nest the properties under the
   *   `properties` key).
   *
   * @default `"nest:properties"`
   */
  readonly properties?: "flatten" | `prepend:${string}` | `nest:${string}`;
}
/**
 * Get a [JSON Lines] formatter with the specified options.  The log records
 * will be rendered as JSON objects, one per line, which is a common format
 * for log files.  This format is also known as Newline-Delimited JSON (NDJSON).
 * It looks like this:
 *
 * ```json
 * {"@timestamp":"2023-11-14T22:13:20.000Z","level":"INFO","message":"Hello, world!","logger":"my.logger","properties":{"key":"value"}}
 * ```
 *
 * [JSON Lines]: https://jsonlines.org/
 * @param options The options for the JSON Lines formatter.
 * @returns The JSON Lines formatter.
 * @since 0.11.0
 */
declare function getJsonLinesFormatter(options?: JsonLinesFormatterOptions): TextFormatter;
/**
 * The default [JSON Lines] formatter.  This formatter formats log records
 * as JSON objects, one per line, which is a common format for log files.
 * It looks like this:
 *
 * ```json
 * {"@timestamp":"2023-11-14T22:13:20.000Z","level":"INFO","message":"Hello, world!","logger":"my.logger","properties":{"key":"value"}}
 * ```
 *
 * You can customize the output by passing options to
 * {@link getJsonLinesFormatter}.  For example, you can change the category
 * separator, the message format, and how the properties are formatted.
 *
 * [JSON Lines]: https://jsonlines.org/
 * @since 0.11.0
 */
declare const jsonLinesFormatter: TextFormatter;
/**
 * A console formatter is a function that accepts a log record and returns
 * an array of arguments to pass to {@link console.log}.
 *
 * @param record The log record to format.
 * @returns The formatted log record, as an array of arguments for
 *          {@link console.log}.
 */
type ConsoleFormatter = (record: LogRecord) => readonly unknown[];
/**
 * The default console formatter.
 *
 * @param record The log record to format.
 * @returns The formatted log record, as an array of arguments for
 *          {@link console.log}.
 */
declare function defaultConsoleFormatter(record: LogRecord): readonly unknown[];
//# sourceMappingURL=formatter.d.ts.map
//#endregion
export { AnsiColor, AnsiColorFormatterOptions, AnsiStyle, ConsoleFormatter, FormattedValues, JsonLinesFormatterOptions, TextFormatter, TextFormatterOptions, ansiColorFormatter, defaultConsoleFormatter, defaultTextFormatter, getAnsiColorFormatter, getJsonLinesFormatter, getTextFormatter, jsonLinesFormatter };
//# sourceMappingURL=formatter.d.ts.map