{"version":3,"file":"sink.js","names":["sink: Sink","filter: FilterLike","record: LogRecord","stream: WritableStream","options: StreamSinkOptions","sink: Sink & AsyncDisposable","buffer: LogRecord[]","flushTimer: ReturnType<typeof setInterval> | null","activeFlush: Promise<void> | null","nonBlockingSink: Sink & AsyncDisposable","options: ConsoleSinkOptions","levelMap: Record<LogLevel, ConsoleMethod>","nonBlockingSink: Sink & Disposable","asyncSink: AsyncSink","options: FingersCrossedOptions","parent: readonly string[]","child: readonly string[]","shouldFlushBuffer:\n    | ((\n      triggerCategory: readonly string[],\n      bufferedCategory: readonly string[],\n    ) => boolean)\n    | null","category: readonly string[]","key: string","properties: Record<string, unknown>","contextValues: Record<string, unknown>","buffers: Map<string, BufferMetadata>","expiredKeys: string[]","numToEvict?: number","cleanupTimer: ReturnType<typeof setInterval> | null","allRecordsToFlush: LogRecord[]"],"sources":["../src/sink.ts"],"sourcesContent":["import { type FilterLike, toFilter } from \"./filter.ts\";\nimport {\n  type ConsoleFormatter,\n  defaultConsoleFormatter,\n  defaultTextFormatter,\n  type TextFormatter,\n} from \"./formatter.ts\";\nimport { compareLogLevel, type LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\n\n/**\n * A sink is a function that accepts a log record and prints it somewhere.\n * Thrown exceptions will be suppressed and then logged to the meta logger,\n * a {@link Logger} with the category `[\"logtape\", \"meta\"]`.  (In that case,\n * the meta log record will not be passed to the sink to avoid infinite\n * recursion.)\n *\n * @param record The log record to sink.\n */\nexport type Sink = (record: LogRecord) => void;\n\n/**\n * An async sink is a function that accepts a log record and asynchronously\n * processes it. This type is used with {@link fromAsyncSink} to create\n * a regular sink that properly handles asynchronous operations.\n *\n * @param record The log record to process asynchronously.\n * @returns A promise that resolves when the record has been processed.\n * @since 1.0.0\n */\nexport type AsyncSink = (record: LogRecord) => Promise<void>;\n\n/**\n * Turns a sink into a filtered sink.  The returned sink only logs records that\n * pass the filter.\n *\n * @example Filter a console sink to only log records with the info level\n * ```typescript\n * const sink = withFilter(getConsoleSink(), \"info\");\n * ```\n *\n * @param sink A sink to be filtered.\n * @param filter A filter to apply to the sink.  It can be either a filter\n *               function or a {@link LogLevel} string.\n * @returns A sink that only logs records that pass the filter.\n */\nexport function withFilter(sink: Sink, filter: FilterLike): Sink {\n  const filterFunc = toFilter(filter);\n  return (record: LogRecord) => {\n    if (filterFunc(record)) sink(record);\n  };\n}\n\n/**\n * Options for the {@link getStreamSink} function.\n */\nexport interface StreamSinkOptions {\n  /**\n   * The text formatter to use.  Defaults to {@link defaultTextFormatter}.\n   */\n  formatter?: TextFormatter;\n\n  /**\n   * The text encoder to use.  Defaults to an instance of {@link TextEncoder}.\n   */\n  encoder?: { encode(text: string): Uint8Array };\n\n  /**\n   * Enable non-blocking mode with optional buffer configuration.\n   * When enabled, log records are buffered and flushed in the background.\n   *\n   * @example Simple non-blocking mode\n   * ```typescript\n   * getStreamSink(stream, { nonBlocking: true });\n   * ```\n   *\n   * @example Custom buffer configuration\n   * ```typescript\n   * getStreamSink(stream, {\n   *   nonBlocking: {\n   *     bufferSize: 1000,\n   *     flushInterval: 50\n   *   }\n   * });\n   * ```\n   *\n   * @default `false`\n   * @since 1.0.0\n   */\n  nonBlocking?: boolean | {\n    /**\n     * Maximum number of records to buffer before flushing.\n     * @default `100`\n     */\n    bufferSize?: number;\n\n    /**\n     * Interval in milliseconds between automatic flushes.\n     * @default `100`\n     */\n    flushInterval?: number;\n  };\n}\n\n/**\n * A factory that returns a sink that writes to a {@link WritableStream}.\n *\n * Note that the `stream` is of Web Streams API, which is different from\n * Node.js streams.  You can convert a Node.js stream to a Web Streams API\n * stream using [`stream.Writable.toWeb()`] method.\n *\n * [`stream.Writable.toWeb()`]: https://nodejs.org/api/stream.html#streamwritabletowebstreamwritable\n *\n * @example Sink to the standard error in Deno\n * ```typescript\n * const stderrSink = getStreamSink(Deno.stderr.writable);\n * ```\n *\n * @example Sink to the standard error in Node.js\n * ```typescript\n * import stream from \"node:stream\";\n * const stderrSink = getStreamSink(stream.Writable.toWeb(process.stderr));\n * ```\n *\n * @param stream The stream to write to.\n * @param options The options for the sink.\n * @returns A sink that writes to the stream.\n */\nexport function getStreamSink(\n  stream: WritableStream,\n  options: StreamSinkOptions = {},\n): Sink & AsyncDisposable {\n  const formatter = options.formatter ?? defaultTextFormatter;\n  const encoder = options.encoder ?? new TextEncoder();\n  const writer = stream.getWriter();\n\n  if (!options.nonBlocking) {\n    let lastPromise = Promise.resolve();\n    const sink: Sink & AsyncDisposable = (record: LogRecord) => {\n      const bytes = encoder.encode(formatter(record));\n      lastPromise = lastPromise\n        .then(() => writer.ready)\n        .then(() => writer.write(bytes));\n    };\n    sink[Symbol.asyncDispose] = async () => {\n      await lastPromise;\n      await writer.close();\n    };\n    return sink;\n  }\n\n  // Non-blocking mode implementation\n  const nonBlockingConfig = options.nonBlocking === true\n    ? {}\n    : options.nonBlocking;\n  const bufferSize = nonBlockingConfig.bufferSize ?? 100;\n  const flushInterval = nonBlockingConfig.flushInterval ?? 100;\n\n  const buffer: LogRecord[] = [];\n  let flushTimer: ReturnType<typeof setInterval> | null = null;\n  let disposed = false;\n  let activeFlush: Promise<void> | null = null;\n  const maxBufferSize = bufferSize * 2; // Overflow protection\n\n  async function flush(): Promise<void> {\n    if (buffer.length === 0) return;\n\n    const records = buffer.splice(0);\n    for (const record of records) {\n      try {\n        const bytes = encoder.encode(formatter(record));\n        await writer.ready;\n        await writer.write(bytes);\n      } catch {\n        // Silently ignore errors in non-blocking mode to avoid disrupting the application\n      }\n    }\n  }\n\n  function scheduleFlush(): void {\n    if (activeFlush) return;\n\n    activeFlush = flush().finally(() => {\n      activeFlush = null;\n    });\n  }\n\n  function startFlushTimer(): void {\n    if (flushTimer !== null || disposed) return;\n\n    flushTimer = setInterval(() => {\n      scheduleFlush();\n    }, flushInterval);\n  }\n\n  const nonBlockingSink: Sink & AsyncDisposable = (record: LogRecord) => {\n    if (disposed) return;\n\n    // Buffer overflow protection: drop oldest records if buffer is too large\n    if (buffer.length >= maxBufferSize) {\n      buffer.shift(); // Remove oldest record\n    }\n\n    buffer.push(record);\n\n    if (buffer.length >= bufferSize) {\n      scheduleFlush();\n    } else if (flushTimer === null) {\n      startFlushTimer();\n    }\n  };\n\n  nonBlockingSink[Symbol.asyncDispose] = async () => {\n    disposed = true;\n    if (flushTimer !== null) {\n      clearInterval(flushTimer);\n      flushTimer = null;\n    }\n    await flush();\n    try {\n      await writer.close();\n    } catch {\n      // Writer might already be closed or errored\n    }\n  };\n\n  return nonBlockingSink;\n}\n\ntype ConsoleMethod = \"debug\" | \"info\" | \"log\" | \"warn\" | \"error\";\n\n/**\n * Options for the {@link getConsoleSink} function.\n */\nexport interface ConsoleSinkOptions {\n  /**\n   * The console formatter or text formatter to use.\n   * Defaults to {@link defaultConsoleFormatter}.\n   */\n  formatter?: ConsoleFormatter | TextFormatter;\n\n  /**\n   * The mapping from log levels to console methods.  Defaults to:\n   *\n   * ```typescript\n   * {\n   *   trace: \"trace\",\n   *   debug: \"debug\",\n   *   info: \"info\",\n   *   warning: \"warn\",\n   *   error: \"error\",\n   *   fatal: \"error\",\n   * }\n   * ```\n   * @since 0.9.0\n   */\n  levelMap?: Record<LogLevel, ConsoleMethod>;\n\n  /**\n   * The console to log to.  Defaults to {@link console}.\n   */\n  console?: Console;\n\n  /**\n   * Enable non-blocking mode with optional buffer configuration.\n   * When enabled, log records are buffered and flushed in the background.\n   *\n   * @example Simple non-blocking mode\n   * ```typescript\n   * getConsoleSink({ nonBlocking: true });\n   * ```\n   *\n   * @example Custom buffer configuration\n   * ```typescript\n   * getConsoleSink({\n   *   nonBlocking: {\n   *     bufferSize: 1000,\n   *     flushInterval: 50\n   *   }\n   * });\n   * ```\n   *\n   * @default `false`\n   * @since 1.0.0\n   */\n  nonBlocking?: boolean | {\n    /**\n     * Maximum number of records to buffer before flushing.\n     * @default `100`\n     */\n    bufferSize?: number;\n\n    /**\n     * Interval in milliseconds between automatic flushes.\n     * @default `100`\n     */\n    flushInterval?: number;\n  };\n}\n\n/**\n * A console sink factory that returns a sink that logs to the console.\n *\n * @param options The options for the sink.\n * @returns A sink that logs to the console. If `nonBlocking` is enabled,\n *          returns a sink that also implements {@link Disposable}.\n */\nexport function getConsoleSink(\n  options: ConsoleSinkOptions = {},\n): Sink | (Sink & Disposable) {\n  const formatter = options.formatter ?? defaultConsoleFormatter;\n  const levelMap: Record<LogLevel, ConsoleMethod> = {\n    trace: \"debug\",\n    debug: \"debug\",\n    info: \"info\",\n    warning: \"warn\",\n    error: \"error\",\n    fatal: \"error\",\n    ...(options.levelMap ?? {}),\n  };\n  const console = options.console ?? globalThis.console;\n\n  const baseSink = (record: LogRecord) => {\n    const args = formatter(record);\n    const method = levelMap[record.level];\n    if (method === undefined) {\n      throw new TypeError(`Invalid log level: ${record.level}.`);\n    }\n    if (typeof args === \"string\") {\n      const msg = args.replace(/\\r?\\n$/, \"\");\n      console[method](msg);\n    } else {\n      console[method](...args);\n    }\n  };\n\n  if (!options.nonBlocking) {\n    return baseSink;\n  }\n\n  // Non-blocking mode implementation\n  const nonBlockingConfig = options.nonBlocking === true\n    ? {}\n    : options.nonBlocking;\n  const bufferSize = nonBlockingConfig.bufferSize ?? 100;\n  const flushInterval = nonBlockingConfig.flushInterval ?? 100;\n\n  const buffer: LogRecord[] = [];\n  let flushTimer: ReturnType<typeof setInterval> | null = null;\n  let disposed = false;\n  let flushScheduled = false;\n  const maxBufferSize = bufferSize * 2; // Overflow protection\n\n  function flush(): void {\n    if (buffer.length === 0) return;\n\n    const records = buffer.splice(0);\n    for (const record of records) {\n      try {\n        baseSink(record);\n      } catch {\n        // Silently ignore errors in non-blocking mode to avoid disrupting the application\n      }\n    }\n  }\n\n  function scheduleFlush(): void {\n    if (flushScheduled) return;\n\n    flushScheduled = true;\n    setTimeout(() => {\n      flushScheduled = false;\n      flush();\n    }, 0);\n  }\n\n  function startFlushTimer(): void {\n    if (flushTimer !== null || disposed) return;\n\n    flushTimer = setInterval(() => {\n      flush();\n    }, flushInterval);\n  }\n\n  const nonBlockingSink: Sink & Disposable = (record: LogRecord) => {\n    if (disposed) return;\n\n    // Buffer overflow protection: drop oldest records if buffer is too large\n    if (buffer.length >= maxBufferSize) {\n      buffer.shift(); // Remove oldest record\n    }\n\n    buffer.push(record);\n\n    if (buffer.length >= bufferSize) {\n      scheduleFlush();\n    } else if (flushTimer === null) {\n      startFlushTimer();\n    }\n  };\n\n  nonBlockingSink[Symbol.dispose] = () => {\n    disposed = true;\n    if (flushTimer !== null) {\n      clearInterval(flushTimer);\n      flushTimer = null;\n    }\n    flush();\n  };\n\n  return nonBlockingSink;\n}\n\n/**\n * Converts an async sink into a regular sink with proper async handling.\n * The returned sink chains async operations to ensure proper ordering and\n * implements AsyncDisposable to wait for all pending operations on disposal.\n *\n * @example Create a sink that asynchronously posts to a webhook\n * ```typescript\n * const asyncSink: AsyncSink = async (record) => {\n *   await fetch(\"https://example.com/logs\", {\n *     method: \"POST\",\n *     body: JSON.stringify(record),\n *   });\n * };\n * const sink = fromAsyncSink(asyncSink);\n * ```\n *\n * @param asyncSink The async sink function to convert.\n * @returns A sink that properly handles async operations and disposal.\n * @since 1.0.0\n */\nexport function fromAsyncSink(asyncSink: AsyncSink): Sink & AsyncDisposable {\n  let lastPromise = Promise.resolve();\n  const sink: Sink & AsyncDisposable = (record: LogRecord) => {\n    lastPromise = lastPromise\n      .then(() => asyncSink(record))\n      .catch(() => {\n        // Errors are handled by the sink infrastructure\n      });\n  };\n  sink[Symbol.asyncDispose] = async () => {\n    await lastPromise;\n  };\n  return sink;\n}\n\n/**\n * Options for the {@link fingersCrossed} function.\n * @since 1.1.0\n */\nexport interface FingersCrossedOptions {\n  /**\n   * Minimum log level that triggers buffer flush.\n   * When a log record at or above this level is received, all buffered\n   * records are flushed to the wrapped sink.\n   * @default `\"error\"`\n   */\n  readonly triggerLevel?: LogLevel;\n\n  /**\n   * Maximum buffer size before oldest records are dropped.\n   * When the buffer exceeds this size, the oldest records are removed\n   * to prevent unbounded memory growth.\n   * @default `1000`\n   */\n  readonly maxBufferSize?: number;\n\n  /**\n   * Category isolation mode or custom matcher function.\n   *\n   * When `undefined` (default), all log records share a single buffer.\n   *\n   * When set to a mode string:\n   *\n   * - `\"descendant\"`: Flush child category buffers when parent triggers\n   * - `\"ancestor\"`: Flush parent category buffers when child triggers\n   * - `\"both\"`: Flush both parent and child category buffers\n   *\n   * When set to a function, it receives the trigger category and buffered\n   * category and should return true if the buffered category should be flushed.\n   *\n   * @default `undefined` (no isolation, single global buffer)\n   */\n  readonly isolateByCategory?:\n    | \"descendant\"\n    | \"ancestor\"\n    | \"both\"\n    | ((\n      triggerCategory: readonly string[],\n      bufferedCategory: readonly string[],\n    ) => boolean);\n\n  /**\n   * Enable context-based buffer isolation.\n   * When enabled, buffers are isolated based on specified context keys.\n   * This is useful for scenarios like HTTP request tracing where logs\n   * should be isolated per request.\n   *\n   * @example\n   * ```typescript\n   * fingersCrossed(sink, {\n   *   isolateByContext: { keys: ['requestId'] }\n   * })\n   * ```\n   *\n   * @example Combined with category isolation\n   * ```typescript\n   * fingersCrossed(sink, {\n   *   isolateByCategory: 'descendant',\n   *   isolateByContext: { keys: ['requestId', 'sessionId'] }\n   * })\n   * ```\n   *\n   * @example With TTL-based buffer cleanup\n   * ```typescript\n   * fingersCrossed(sink, {\n   *   isolateByContext: {\n   *     keys: ['requestId'],\n   *     bufferTtlMs: 30000,        // 30 seconds\n   *     cleanupIntervalMs: 10000   // cleanup every 10 seconds\n   *   }\n   * })\n   * ```\n   *\n   * @default `undefined` (no context isolation)\n   * @since 1.2.0\n   */\n  readonly isolateByContext?: {\n    /**\n     * Context keys to use for isolation.\n     * Buffers will be separate for different combinations of these context values.\n     */\n    readonly keys: readonly string[];\n\n    /**\n     * Maximum number of context buffers to maintain simultaneously.\n     * When this limit is exceeded, the least recently used (LRU) buffers\n     * will be evicted to make room for new ones.\n     *\n     * This provides memory protection in high-concurrency scenarios where\n     * many different context values might be active simultaneously.\n     *\n     * When set to 0 or undefined, no limit is enforced.\n     *\n     * @default `undefined` (no limit)\n     * @since 1.2.0\n     */\n    readonly maxContexts?: number;\n\n    /**\n     * Time-to-live for context buffers in milliseconds.\n     * Buffers that haven't been accessed for this duration will be automatically\n     * cleaned up to prevent memory leaks in long-running applications.\n     *\n     * When set to 0 or undefined, buffers will never expire based on time.\n     *\n     * @default `undefined` (no TTL)\n     * @since 1.2.0\n     */\n    readonly bufferTtlMs?: number;\n\n    /**\n     * Interval in milliseconds for running cleanup operations.\n     * The cleanup process removes expired buffers based on {@link bufferTtlMs}.\n     *\n     * This option is ignored if {@link bufferTtlMs} is not set.\n     *\n     * @default `30000` (30 seconds)\n     * @since 1.2.0\n     */\n    readonly cleanupIntervalMs?: number;\n  };\n}\n\n/**\n * Metadata for context-based buffer tracking.\n * Used internally by {@link fingersCrossed} to manage buffer lifecycle with LRU support.\n * @since 1.2.0\n */\ninterface BufferMetadata {\n  /**\n   * The actual log records buffer.\n   */\n  readonly buffer: LogRecord[];\n\n  /**\n   * Timestamp of the last access to this buffer (in milliseconds).\n   * Used for LRU-based eviction when {@link FingersCrossedOptions.isolateByContext.maxContexts} is set.\n   */\n  lastAccess: number;\n}\n\n/**\n * Creates a sink that buffers log records until a trigger level is reached.\n * This pattern, known as \"fingers crossed\" logging, keeps detailed debug logs\n * in memory and only outputs them when an error or other significant event occurs.\n *\n * @example Basic usage with default settings\n * ```typescript\n * const sink = fingersCrossed(getConsoleSink());\n * // Debug and info logs are buffered\n * // When an error occurs, all buffered logs + the error are output\n * ```\n *\n * @example Custom trigger level and buffer size\n * ```typescript\n * const sink = fingersCrossed(getConsoleSink(), {\n *   triggerLevel: \"warning\",  // Trigger on warning or higher\n *   maxBufferSize: 500        // Keep last 500 records\n * });\n * ```\n *\n * @example Category isolation\n * ```typescript\n * const sink = fingersCrossed(getConsoleSink(), {\n *   isolateByCategory: \"descendant\"  // Separate buffers per category\n * });\n * // Error in [\"app\"] triggers flush of [\"app\"] and [\"app\", \"module\"] buffers\n * // But not [\"other\"] buffer\n * ```\n *\n * @param sink The sink to wrap. Buffered records are sent to this sink when\n *             triggered.\n * @param options Configuration options for the fingers crossed behavior.\n * @returns A sink that buffers records until the trigger level is reached.\n * @since 1.1.0\n */\nexport function fingersCrossed(\n  sink: Sink,\n  options: FingersCrossedOptions = {},\n): Sink | (Sink & Disposable) {\n  const triggerLevel = options.triggerLevel ?? \"error\";\n  const maxBufferSize = Math.max(0, options.maxBufferSize ?? 1000);\n  const isolateByCategory = options.isolateByCategory;\n  const isolateByContext = options.isolateByContext;\n\n  // TTL and LRU configuration\n  const bufferTtlMs = isolateByContext?.bufferTtlMs;\n  const cleanupIntervalMs = isolateByContext?.cleanupIntervalMs ?? 30000;\n  const maxContexts = isolateByContext?.maxContexts;\n  const hasTtl = bufferTtlMs != null && bufferTtlMs > 0;\n  const hasLru = maxContexts != null && maxContexts > 0;\n\n  // Validate trigger level early\n  try {\n    compareLogLevel(\"trace\", triggerLevel); // Test with any valid level\n  } catch (error) {\n    throw new TypeError(\n      `Invalid triggerLevel: ${JSON.stringify(triggerLevel)}. ${\n        error instanceof Error ? error.message : String(error)\n      }`,\n    );\n  }\n\n  // Helper functions for category matching\n  function isDescendant(\n    parent: readonly string[],\n    child: readonly string[],\n  ): boolean {\n    if (parent.length === 0 || child.length === 0) return false; // Empty categories are isolated\n    if (parent.length > child.length) return false;\n    return parent.every((p, i) => p === child[i]);\n  }\n\n  function isAncestor(\n    child: readonly string[],\n    parent: readonly string[],\n  ): boolean {\n    if (child.length === 0 || parent.length === 0) return false; // Empty categories are isolated\n    if (child.length < parent.length) return false;\n    return parent.every((p, i) => p === child[i]);\n  }\n\n  // Determine matcher function based on isolation mode\n  let shouldFlushBuffer:\n    | ((\n      triggerCategory: readonly string[],\n      bufferedCategory: readonly string[],\n    ) => boolean)\n    | null = null;\n\n  if (isolateByCategory) {\n    if (typeof isolateByCategory === \"function\") {\n      shouldFlushBuffer = isolateByCategory;\n    } else {\n      switch (isolateByCategory) {\n        case \"descendant\":\n          shouldFlushBuffer = (trigger, buffered) =>\n            isDescendant(trigger, buffered);\n          break;\n        case \"ancestor\":\n          shouldFlushBuffer = (trigger, buffered) =>\n            isAncestor(trigger, buffered);\n          break;\n        case \"both\":\n          shouldFlushBuffer = (trigger, buffered) =>\n            isDescendant(trigger, buffered) || isAncestor(trigger, buffered);\n          break;\n      }\n    }\n  }\n\n  // Helper functions for category serialization\n  function getCategoryKey(category: readonly string[]): string {\n    return JSON.stringify(category);\n  }\n\n  function parseCategoryKey(key: string): string[] {\n    return JSON.parse(key);\n  }\n\n  // Helper function to extract context values from properties\n  function getContextKey(properties: Record<string, unknown>): string {\n    if (!isolateByContext || isolateByContext.keys.length === 0) {\n      return \"\";\n    }\n    const contextValues: Record<string, unknown> = {};\n    for (const key of isolateByContext.keys) {\n      if (key in properties) {\n        contextValues[key] = properties[key];\n      }\n    }\n    return JSON.stringify(contextValues);\n  }\n\n  // Helper function to generate buffer key\n  function getBufferKey(\n    category: readonly string[],\n    properties: Record<string, unknown>,\n  ): string {\n    const categoryKey = getCategoryKey(category);\n    if (!isolateByContext) {\n      return categoryKey;\n    }\n    const contextKey = getContextKey(properties);\n    return `${categoryKey}:${contextKey}`;\n  }\n\n  // Helper function to parse buffer key\n  function parseBufferKey(key: string): {\n    category: string[];\n    context: string;\n  } {\n    if (!isolateByContext) {\n      return { category: parseCategoryKey(key), context: \"\" };\n    }\n    // Find the separator between category and context\n    // The category part is JSON-encoded, so we need to find where it ends\n    // We look for \"]:\" which indicates end of category array and start of context\n    const separatorIndex = key.indexOf(\"]:\");\n    if (separatorIndex === -1) {\n      // No context part, entire key is category\n      return { category: parseCategoryKey(key), context: \"\" };\n    }\n    const categoryPart = key.substring(0, separatorIndex + 1); // Include the ]\n    const contextPart = key.substring(separatorIndex + 2); // Skip ]:\n    return { category: parseCategoryKey(categoryPart), context: contextPart };\n  }\n\n  // TTL-based cleanup function\n  function cleanupExpiredBuffers(buffers: Map<string, BufferMetadata>): void {\n    if (!hasTtl) return;\n\n    const now = Date.now();\n    const expiredKeys: string[] = [];\n\n    for (const [key, metadata] of buffers) {\n      if (metadata.buffer.length === 0) continue;\n\n      // Use the timestamp of the last (most recent) record in the buffer\n      const lastRecordTimestamp =\n        metadata.buffer[metadata.buffer.length - 1].timestamp;\n      if (now - lastRecordTimestamp > bufferTtlMs!) {\n        expiredKeys.push(key);\n      }\n    }\n\n    // Remove expired buffers\n    for (const key of expiredKeys) {\n      buffers.delete(key);\n    }\n  }\n\n  // LRU-based eviction function\n  function evictLruBuffers(\n    buffers: Map<string, BufferMetadata>,\n    numToEvict?: number,\n  ): void {\n    if (!hasLru) return;\n\n    // Use provided numToEvict or calculate based on current size vs limit\n    const toEvict = numToEvict ?? Math.max(0, buffers.size - maxContexts!);\n    if (toEvict <= 0) return;\n\n    // Sort by lastAccess timestamp (oldest first)\n    const sortedEntries = Array.from(buffers.entries())\n      .sort(([, a], [, b]) => a.lastAccess - b.lastAccess);\n\n    // Remove the oldest buffers\n    for (let i = 0; i < toEvict; i++) {\n      const [key] = sortedEntries[i];\n      buffers.delete(key);\n    }\n  }\n\n  // Buffer management\n  if (!isolateByCategory && !isolateByContext) {\n    // Single global buffer\n    const buffer: LogRecord[] = [];\n    let triggered = false;\n\n    return (record: LogRecord) => {\n      if (triggered) {\n        // Already triggered, pass through directly\n        sink(record);\n        return;\n      }\n\n      // Check if this record triggers flush\n      if (compareLogLevel(record.level, triggerLevel) >= 0) {\n        triggered = true;\n\n        // Flush buffer\n        for (const bufferedRecord of buffer) {\n          sink(bufferedRecord);\n        }\n        buffer.length = 0;\n\n        // Send trigger record\n        sink(record);\n      } else {\n        // Buffer the record\n        buffer.push(record);\n\n        // Enforce max buffer size\n        while (buffer.length > maxBufferSize) {\n          buffer.shift();\n        }\n      }\n    };\n  } else {\n    // Category and/or context-isolated buffers\n    const buffers = new Map<string, BufferMetadata>();\n    const triggered = new Set<string>();\n\n    // Set up TTL cleanup timer if enabled\n    let cleanupTimer: ReturnType<typeof setInterval> | null = null;\n    if (hasTtl) {\n      cleanupTimer = setInterval(() => {\n        cleanupExpiredBuffers(buffers);\n      }, cleanupIntervalMs);\n    }\n\n    const fingersCrossedSink = (record: LogRecord) => {\n      const bufferKey = getBufferKey(record.category, record.properties);\n\n      // Check if this buffer is already triggered\n      if (triggered.has(bufferKey)) {\n        sink(record);\n        return;\n      }\n\n      // Check if this record triggers flush\n      if (compareLogLevel(record.level, triggerLevel) >= 0) {\n        // Find all buffers that should be flushed\n        const keysToFlush = new Set<string>();\n\n        for (const [bufferedKey] of buffers) {\n          if (bufferedKey === bufferKey) {\n            keysToFlush.add(bufferedKey);\n          } else {\n            const { category: bufferedCategory, context: bufferedContext } =\n              parseBufferKey(bufferedKey);\n            const { context: triggerContext } = parseBufferKey(bufferKey);\n\n            // Check context match\n            let contextMatches = true;\n            if (isolateByContext) {\n              contextMatches = bufferedContext === triggerContext;\n            }\n\n            // Check category match\n            let categoryMatches = false;\n            if (!isolateByCategory) {\n              // No category isolation, so all categories match if context matches\n              categoryMatches = contextMatches;\n            } else if (shouldFlushBuffer) {\n              try {\n                categoryMatches = shouldFlushBuffer(\n                  record.category,\n                  bufferedCategory,\n                );\n              } catch {\n                // Ignore errors from custom matcher\n              }\n            } else {\n              // Same category only\n              categoryMatches = getCategoryKey(record.category) ===\n                getCategoryKey(bufferedCategory);\n            }\n\n            // Both must match for the buffer to be flushed\n            if (contextMatches && categoryMatches) {\n              keysToFlush.add(bufferedKey);\n            }\n          }\n        }\n\n        // Flush matching buffers\n        const allRecordsToFlush: LogRecord[] = [];\n        for (const key of keysToFlush) {\n          const metadata = buffers.get(key);\n          if (metadata) {\n            allRecordsToFlush.push(...metadata.buffer);\n            buffers.delete(key);\n            triggered.add(key);\n          }\n        }\n\n        // Sort by timestamp to maintain chronological order\n        allRecordsToFlush.sort((a, b) => a.timestamp - b.timestamp);\n\n        // Flush all records\n        for (const bufferedRecord of allRecordsToFlush) {\n          sink(bufferedRecord);\n        }\n\n        // Mark trigger buffer as triggered and send trigger record\n        triggered.add(bufferKey);\n        sink(record);\n      } else {\n        // Buffer the record\n        const now = Date.now();\n        let metadata = buffers.get(bufferKey);\n        if (!metadata) {\n          // Apply LRU eviction if adding new buffer would exceed capacity\n          if (hasLru && buffers.size >= maxContexts!) {\n            // Calculate how many buffers to evict to make room for the new one\n            const numToEvict = buffers.size - maxContexts! + 1;\n            evictLruBuffers(buffers, numToEvict);\n          }\n\n          metadata = {\n            buffer: [],\n            lastAccess: now,\n          };\n          buffers.set(bufferKey, metadata);\n        } else {\n          // Update last access time for LRU\n          metadata.lastAccess = now;\n        }\n\n        metadata.buffer.push(record);\n\n        // Enforce max buffer size per buffer\n        while (metadata.buffer.length > maxBufferSize) {\n          metadata.buffer.shift();\n        }\n      }\n    };\n\n    // Add disposal functionality to clean up timer\n    if (cleanupTimer !== null) {\n      (fingersCrossedSink as Sink & Disposable)[Symbol.dispose] = () => {\n        if (cleanupTimer !== null) {\n          clearInterval(cleanupTimer);\n          cleanupTimer = null;\n        }\n      };\n    }\n\n    return fingersCrossedSink;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AA8CA,SAAgB,WAAWA,MAAYC,QAA0B;CAC/D,MAAM,aAAa,SAAS,OAAO;AACnC,QAAO,CAACC,WAAsB;AAC5B,MAAI,WAAW,OAAO,CAAE,MAAK,OAAO;CACrC;AACF;;;;;;;;;;;;;;;;;;;;;;;;;AA6ED,SAAgB,cACdC,QACAC,UAA6B,CAAE,GACP;CACxB,MAAM,YAAY,QAAQ,aAAa;CACvC,MAAM,UAAU,QAAQ,WAAW,IAAI;CACvC,MAAM,SAAS,OAAO,WAAW;AAEjC,MAAK,QAAQ,aAAa;EACxB,IAAI,cAAc,QAAQ,SAAS;EACnC,MAAMC,OAA+B,CAACH,WAAsB;GAC1D,MAAM,QAAQ,QAAQ,OAAO,UAAU,OAAO,CAAC;AAC/C,iBAAc,YACX,KAAK,MAAM,OAAO,MAAM,CACxB,KAAK,MAAM,OAAO,MAAM,MAAM,CAAC;EACnC;AACD,OAAK,OAAO,gBAAgB,YAAY;AACtC,SAAM;AACN,SAAM,OAAO,OAAO;EACrB;AACD,SAAO;CACR;CAGD,MAAM,oBAAoB,QAAQ,gBAAgB,OAC9C,CAAE,IACF,QAAQ;CACZ,MAAM,aAAa,kBAAkB,cAAc;CACnD,MAAM,gBAAgB,kBAAkB,iBAAiB;CAEzD,MAAMI,SAAsB,CAAE;CAC9B,IAAIC,aAAoD;CACxD,IAAI,WAAW;CACf,IAAIC,cAAoC;CACxC,MAAM,gBAAgB,aAAa;CAEnC,eAAe,QAAuB;AACpC,MAAI,OAAO,WAAW,EAAG;EAEzB,MAAM,UAAU,OAAO,OAAO,EAAE;AAChC,OAAK,MAAM,UAAU,QACnB,KAAI;GACF,MAAM,QAAQ,QAAQ,OAAO,UAAU,OAAO,CAAC;AAC/C,SAAM,OAAO;AACb,SAAM,OAAO,MAAM,MAAM;EAC1B,QAAO,CAEP;CAEJ;CAED,SAAS,gBAAsB;AAC7B,MAAI,YAAa;AAEjB,gBAAc,OAAO,CAAC,QAAQ,MAAM;AAClC,iBAAc;EACf,EAAC;CACH;CAED,SAAS,kBAAwB;AAC/B,MAAI,eAAe,QAAQ,SAAU;AAErC,eAAa,YAAY,MAAM;AAC7B,kBAAe;EAChB,GAAE,cAAc;CAClB;CAED,MAAMC,kBAA0C,CAACP,WAAsB;AACrE,MAAI,SAAU;AAGd,MAAI,OAAO,UAAU,cACnB,QAAO,OAAO;AAGhB,SAAO,KAAK,OAAO;AAEnB,MAAI,OAAO,UAAU,WACnB,gBAAe;WACN,eAAe,KACxB,kBAAiB;CAEpB;AAED,iBAAgB,OAAO,gBAAgB,YAAY;AACjD,aAAW;AACX,MAAI,eAAe,MAAM;AACvB,iBAAc,WAAW;AACzB,gBAAa;EACd;AACD,QAAM,OAAO;AACb,MAAI;AACF,SAAM,OAAO,OAAO;EACrB,QAAO,CAEP;CACF;AAED,QAAO;AACR;;;;;;;;AAgFD,SAAgB,eACdQ,UAA8B,CAAE,GACJ;CAC5B,MAAM,YAAY,QAAQ,aAAa;CACvC,MAAMC,WAA4C;EAChD,OAAO;EACP,OAAO;EACP,MAAM;EACN,SAAS;EACT,OAAO;EACP,OAAO;EACP,GAAI,QAAQ,YAAY,CAAE;CAC3B;CACD,MAAM,UAAU,QAAQ,WAAW,WAAW;CAE9C,MAAM,WAAW,CAACT,WAAsB;EACtC,MAAM,OAAO,UAAU,OAAO;EAC9B,MAAM,SAAS,SAAS,OAAO;AAC/B,MAAI,kBACF,OAAM,IAAI,WAAW,qBAAqB,OAAO,MAAM;AAEzD,aAAW,SAAS,UAAU;GAC5B,MAAM,MAAM,KAAK,QAAQ,UAAU,GAAG;AACtC,WAAQ,QAAQ,IAAI;EACrB,MACC,SAAQ,QAAQ,GAAG,KAAK;CAE3B;AAED,MAAK,QAAQ,YACX,QAAO;CAIT,MAAM,oBAAoB,QAAQ,gBAAgB,OAC9C,CAAE,IACF,QAAQ;CACZ,MAAM,aAAa,kBAAkB,cAAc;CACnD,MAAM,gBAAgB,kBAAkB,iBAAiB;CAEzD,MAAMI,SAAsB,CAAE;CAC9B,IAAIC,aAAoD;CACxD,IAAI,WAAW;CACf,IAAI,iBAAiB;CACrB,MAAM,gBAAgB,aAAa;CAEnC,SAAS,QAAc;AACrB,MAAI,OAAO,WAAW,EAAG;EAEzB,MAAM,UAAU,OAAO,OAAO,EAAE;AAChC,OAAK,MAAM,UAAU,QACnB,KAAI;AACF,YAAS,OAAO;EACjB,QAAO,CAEP;CAEJ;CAED,SAAS,gBAAsB;AAC7B,MAAI,eAAgB;AAEpB,mBAAiB;AACjB,aAAW,MAAM;AACf,oBAAiB;AACjB,UAAO;EACR,GAAE,EAAE;CACN;CAED,SAAS,kBAAwB;AAC/B,MAAI,eAAe,QAAQ,SAAU;AAErC,eAAa,YAAY,MAAM;AAC7B,UAAO;EACR,GAAE,cAAc;CAClB;CAED,MAAMK,kBAAqC,CAACV,WAAsB;AAChE,MAAI,SAAU;AAGd,MAAI,OAAO,UAAU,cACnB,QAAO,OAAO;AAGhB,SAAO,KAAK,OAAO;AAEnB,MAAI,OAAO,UAAU,WACnB,gBAAe;WACN,eAAe,KACxB,kBAAiB;CAEpB;AAED,iBAAgB,OAAO,WAAW,MAAM;AACtC,aAAW;AACX,MAAI,eAAe,MAAM;AACvB,iBAAc,WAAW;AACzB,gBAAa;EACd;AACD,SAAO;CACR;AAED,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;AAsBD,SAAgB,cAAcW,WAA8C;CAC1E,IAAI,cAAc,QAAQ,SAAS;CACnC,MAAMR,OAA+B,CAACH,WAAsB;AAC1D,gBAAc,YACX,KAAK,MAAM,UAAU,OAAO,CAAC,CAC7B,MAAM,MAAM,CAEZ,EAAC;CACL;AACD,MAAK,OAAO,gBAAgB,YAAY;AACtC,QAAM;CACP;AACD,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuLD,SAAgB,eACdF,MACAc,UAAiC,CAAE,GACP;CAC5B,MAAM,eAAe,QAAQ,gBAAgB;CAC7C,MAAM,gBAAgB,KAAK,IAAI,GAAG,QAAQ,iBAAiB,IAAK;CAChE,MAAM,oBAAoB,QAAQ;CAClC,MAAM,mBAAmB,QAAQ;CAGjC,MAAM,cAAc,kBAAkB;CACtC,MAAM,oBAAoB,kBAAkB,qBAAqB;CACjE,MAAM,cAAc,kBAAkB;CACtC,MAAM,SAAS,eAAe,QAAQ,cAAc;CACpD,MAAM,SAAS,eAAe,QAAQ,cAAc;AAGpD,KAAI;AACF,kBAAgB,SAAS,aAAa;CACvC,SAAQ,OAAO;AACd,QAAM,IAAI,WACP,wBAAwB,KAAK,UAAU,aAAa,CAAC,IACpD,iBAAiB,QAAQ,MAAM,UAAU,OAAO,MAAM,CACvD;CAEJ;CAGD,SAAS,aACPC,QACAC,OACS;AACT,MAAI,OAAO,WAAW,KAAK,MAAM,WAAW,EAAG,QAAO;AACtD,MAAI,OAAO,SAAS,MAAM,OAAQ,QAAO;AACzC,SAAO,OAAO,MAAM,CAAC,GAAG,MAAM,MAAM,MAAM,GAAG;CAC9C;CAED,SAAS,WACPA,OACAD,QACS;AACT,MAAI,MAAM,WAAW,KAAK,OAAO,WAAW,EAAG,QAAO;AACtD,MAAI,MAAM,SAAS,OAAO,OAAQ,QAAO;AACzC,SAAO,OAAO,MAAM,CAAC,GAAG,MAAM,MAAM,MAAM,GAAG;CAC9C;CAGD,IAAIE,oBAKO;AAEX,KAAI,kBACF,YAAW,sBAAsB,WAC/B,qBAAoB;KAEpB,SAAQ,mBAAR;EACE,KAAK;AACH,uBAAoB,CAAC,SAAS,aAC5B,aAAa,SAAS,SAAS;AACjC;EACF,KAAK;AACH,uBAAoB,CAAC,SAAS,aAC5B,WAAW,SAAS,SAAS;AAC/B;EACF,KAAK;AACH,uBAAoB,CAAC,SAAS,aAC5B,aAAa,SAAS,SAAS,IAAI,WAAW,SAAS,SAAS;AAClE;CACH;CAKL,SAAS,eAAeC,UAAqC;AAC3D,SAAO,KAAK,UAAU,SAAS;CAChC;CAED,SAAS,iBAAiBC,KAAuB;AAC/C,SAAO,KAAK,MAAM,IAAI;CACvB;CAGD,SAAS,cAAcC,YAA6C;AAClE,OAAK,oBAAoB,iBAAiB,KAAK,WAAW,EACxD,QAAO;EAET,MAAMC,gBAAyC,CAAE;AACjD,OAAK,MAAM,OAAO,iBAAiB,KACjC,KAAI,OAAO,WACT,eAAc,OAAO,WAAW;AAGpC,SAAO,KAAK,UAAU,cAAc;CACrC;CAGD,SAAS,aACPH,UACAE,YACQ;EACR,MAAM,cAAc,eAAe,SAAS;AAC5C,OAAK,iBACH,QAAO;EAET,MAAM,aAAa,cAAc,WAAW;AAC5C,UAAQ,EAAE,YAAY,GAAG,WAAW;CACrC;CAGD,SAAS,eAAeD,KAGtB;AACA,OAAK,iBACH,QAAO;GAAE,UAAU,iBAAiB,IAAI;GAAE,SAAS;EAAI;EAKzD,MAAM,iBAAiB,IAAI,QAAQ,KAAK;AACxC,MAAI,mBAAmB,GAErB,QAAO;GAAE,UAAU,iBAAiB,IAAI;GAAE,SAAS;EAAI;EAEzD,MAAM,eAAe,IAAI,UAAU,GAAG,iBAAiB,EAAE;EACzD,MAAM,cAAc,IAAI,UAAU,iBAAiB,EAAE;AACrD,SAAO;GAAE,UAAU,iBAAiB,aAAa;GAAE,SAAS;EAAa;CAC1E;CAGD,SAAS,sBAAsBG,SAA4C;AACzE,OAAK,OAAQ;EAEb,MAAM,MAAM,KAAK,KAAK;EACtB,MAAMC,cAAwB,CAAE;AAEhC,OAAK,MAAM,CAAC,KAAK,SAAS,IAAI,SAAS;AACrC,OAAI,SAAS,OAAO,WAAW,EAAG;GAGlC,MAAM,sBACJ,SAAS,OAAO,SAAS,OAAO,SAAS,GAAG;AAC9C,OAAI,MAAM,sBAAsB,YAC9B,aAAY,KAAK,IAAI;EAExB;AAGD,OAAK,MAAM,OAAO,YAChB,SAAQ,OAAO,IAAI;CAEtB;CAGD,SAAS,gBACPD,SACAE,YACM;AACN,OAAK,OAAQ;EAGb,MAAM,UAAU,cAAc,KAAK,IAAI,GAAG,QAAQ,OAAO,YAAa;AACtE,MAAI,WAAW,EAAG;EAGlB,MAAM,gBAAgB,MAAM,KAAK,QAAQ,SAAS,CAAC,CAChD,KAAK,CAAC,GAAG,EAAE,EAAE,GAAG,EAAE,KAAK,EAAE,aAAa,EAAE,WAAW;AAGtD,OAAK,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK;GAChC,MAAM,CAAC,IAAI,GAAG,cAAc;AAC5B,WAAQ,OAAO,IAAI;EACpB;CACF;AAGD,MAAK,sBAAsB,kBAAkB;EAE3C,MAAMlB,SAAsB,CAAE;EAC9B,IAAI,YAAY;AAEhB,SAAO,CAACJ,WAAsB;AAC5B,OAAI,WAAW;AAEb,SAAK,OAAO;AACZ;GACD;AAGD,OAAI,gBAAgB,OAAO,OAAO,aAAa,IAAI,GAAG;AACpD,gBAAY;AAGZ,SAAK,MAAM,kBAAkB,OAC3B,MAAK,eAAe;AAEtB,WAAO,SAAS;AAGhB,SAAK,OAAO;GACb,OAAM;AAEL,WAAO,KAAK,OAAO;AAGnB,WAAO,OAAO,SAAS,cACrB,QAAO,OAAO;GAEjB;EACF;CACF,OAAM;EAEL,MAAM,0BAAU,IAAI;EACpB,MAAM,4BAAY,IAAI;EAGtB,IAAIuB,eAAsD;AAC1D,MAAI,OACF,gBAAe,YAAY,MAAM;AAC/B,yBAAsB,QAAQ;EAC/B,GAAE,kBAAkB;EAGvB,MAAM,qBAAqB,CAACvB,WAAsB;GAChD,MAAM,YAAY,aAAa,OAAO,UAAU,OAAO,WAAW;AAGlE,OAAI,UAAU,IAAI,UAAU,EAAE;AAC5B,SAAK,OAAO;AACZ;GACD;AAGD,OAAI,gBAAgB,OAAO,OAAO,aAAa,IAAI,GAAG;IAEpD,MAAM,8BAAc,IAAI;AAExB,SAAK,MAAM,CAAC,YAAY,IAAI,QAC1B,KAAI,gBAAgB,UAClB,aAAY,IAAI,YAAY;SACvB;KACL,MAAM,EAAE,UAAU,kBAAkB,SAAS,iBAAiB,GAC5D,eAAe,YAAY;KAC7B,MAAM,EAAE,SAAS,gBAAgB,GAAG,eAAe,UAAU;KAG7D,IAAI,iBAAiB;AACrB,SAAI,iBACF,kBAAiB,oBAAoB;KAIvC,IAAI,kBAAkB;AACtB,UAAK,kBAEH,mBAAkB;cACT,kBACT,KAAI;AACF,wBAAkB,kBAChB,OAAO,UACP,iBACD;KACF,QAAO,CAEP;SAGD,mBAAkB,eAAe,OAAO,SAAS,KAC/C,eAAe,iBAAiB;AAIpC,SAAI,kBAAkB,gBACpB,aAAY,IAAI,YAAY;IAE/B;IAIH,MAAMwB,oBAAiC,CAAE;AACzC,SAAK,MAAM,OAAO,aAAa;KAC7B,MAAM,WAAW,QAAQ,IAAI,IAAI;AACjC,SAAI,UAAU;AACZ,wBAAkB,KAAK,GAAG,SAAS,OAAO;AAC1C,cAAQ,OAAO,IAAI;AACnB,gBAAU,IAAI,IAAI;KACnB;IACF;AAGD,sBAAkB,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,UAAU;AAG3D,SAAK,MAAM,kBAAkB,kBAC3B,MAAK,eAAe;AAItB,cAAU,IAAI,UAAU;AACxB,SAAK,OAAO;GACb,OAAM;IAEL,MAAM,MAAM,KAAK,KAAK;IACtB,IAAI,WAAW,QAAQ,IAAI,UAAU;AACrC,SAAK,UAAU;AAEb,SAAI,UAAU,QAAQ,QAAQ,aAAc;MAE1C,MAAM,aAAa,QAAQ,OAAO,cAAe;AACjD,sBAAgB,SAAS,WAAW;KACrC;AAED,gBAAW;MACT,QAAQ,CAAE;MACV,YAAY;KACb;AACD,aAAQ,IAAI,WAAW,SAAS;IACjC,MAEC,UAAS,aAAa;AAGxB,aAAS,OAAO,KAAK,OAAO;AAG5B,WAAO,SAAS,OAAO,SAAS,cAC9B,UAAS,OAAO,OAAO;GAE1B;EACF;AAGD,MAAI,iBAAiB,KACnB,CAAC,mBAAyC,OAAO,WAAW,MAAM;AAChE,OAAI,iBAAiB,MAAM;AACzB,kBAAc,aAAa;AAC3B,mBAAe;GAChB;EACF;AAGH,SAAO;CACR;AACF"}