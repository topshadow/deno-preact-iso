const require_context = require('./context.cjs');
const require_level = require('./level.cjs');

//#region src/logger.ts
/**
* Get a logger with the given category.
*
* ```typescript
* const logger = getLogger(["my-app"]);
* ```
*
* @param category The category of the logger.  It can be a string or an array
*                 of strings.  If it is a string, it is equivalent to an array
*                 with a single element.
* @returns The logger.
*/
function getLogger(category = []) {
	return LoggerImpl.getLogger(category);
}
/**
* The symbol for the global root logger.
*/
const globalRootLoggerSymbol = Symbol.for("logtape.rootLogger");
/**
* A logger implementation.  Do not use this directly; use {@link getLogger}
* instead.  This class is exported for testing purposes.
*/
var LoggerImpl = class LoggerImpl {
	parent;
	children;
	category;
	sinks;
	parentSinks = "inherit";
	filters;
	lowestLevel = "trace";
	contextLocalStorage;
	static getLogger(category = []) {
		let rootLogger = globalRootLoggerSymbol in globalThis ? globalThis[globalRootLoggerSymbol] ?? null : null;
		if (rootLogger == null) {
			rootLogger = new LoggerImpl(null, []);
			globalThis[globalRootLoggerSymbol] = rootLogger;
		}
		if (typeof category === "string") return rootLogger.getChild(category);
		if (category.length === 0) return rootLogger;
		return rootLogger.getChild(category);
	}
	constructor(parent, category) {
		this.parent = parent;
		this.children = {};
		this.category = category;
		this.sinks = [];
		this.filters = [];
	}
	getChild(subcategory) {
		const name = typeof subcategory === "string" ? subcategory : subcategory[0];
		const childRef = this.children[name];
		let child = childRef instanceof LoggerImpl ? childRef : childRef?.deref();
		if (child == null) {
			child = new LoggerImpl(this, [...this.category, name]);
			this.children[name] = "WeakRef" in globalThis ? new WeakRef(child) : child;
		}
		if (typeof subcategory === "string" || subcategory.length === 1) return child;
		return child.getChild(subcategory.slice(1));
	}
	/**
	* Reset the logger.  This removes all sinks and filters from the logger.
	*/
	reset() {
		while (this.sinks.length > 0) this.sinks.shift();
		this.parentSinks = "inherit";
		while (this.filters.length > 0) this.filters.shift();
		this.lowestLevel = "trace";
	}
	/**
	* Reset the logger and all its descendants.  This removes all sinks and
	* filters from the logger and all its descendants.
	*/
	resetDescendants() {
		for (const child of Object.values(this.children)) {
			const logger = child instanceof LoggerImpl ? child : child.deref();
			if (logger != null) logger.resetDescendants();
		}
		this.reset();
	}
	with(properties) {
		return new LoggerCtx(this, { ...properties });
	}
	filter(record) {
		for (const filter of this.filters) if (!filter(record)) return false;
		if (this.filters.length < 1) return this.parent?.filter(record) ?? true;
		return true;
	}
	*getSinks(level) {
		if (this.lowestLevel === null || require_level.compareLogLevel(level, this.lowestLevel) < 0) return;
		if (this.parent != null && this.parentSinks === "inherit") for (const sink of this.parent.getSinks(level)) yield sink;
		for (const sink of this.sinks) yield sink;
	}
	emit(record, bypassSinks) {
		const categoryPrefix = require_context.getCategoryPrefix();
		const baseCategory = "category" in record ? record.category : this.category;
		const fullCategory = categoryPrefix.length > 0 ? [...categoryPrefix, ...baseCategory] : baseCategory;
		const descriptors = Object.getOwnPropertyDescriptors(record);
		descriptors.category = {
			value: fullCategory,
			enumerable: true,
			configurable: true
		};
		const fullRecord = Object.defineProperties({}, descriptors);
		if (this.lowestLevel === null || require_level.compareLogLevel(fullRecord.level, this.lowestLevel) < 0 || !this.filter(fullRecord)) return;
		for (const sink of this.getSinks(fullRecord.level)) {
			if (bypassSinks?.has(sink)) continue;
			try {
				sink(fullRecord);
			} catch (error) {
				const bypassSinks2 = new Set(bypassSinks);
				bypassSinks2.add(sink);
				metaLogger.log("fatal", "Failed to emit a log record to sink {sink}: {error}", {
					sink,
					error,
					record: fullRecord
				}, bypassSinks2);
			}
		}
	}
	log(level, rawMessage, properties, bypassSinks) {
		const implicitContext = require_context.getImplicitContext();
		let cachedProps = void 0;
		const record = typeof properties === "function" ? {
			category: this.category,
			level,
			timestamp: Date.now(),
			get message() {
				return parseMessageTemplate(rawMessage, this.properties);
			},
			rawMessage,
			get properties() {
				if (cachedProps == null) cachedProps = {
					...implicitContext,
					...properties()
				};
				return cachedProps;
			}
		} : {
			category: this.category,
			level,
			timestamp: Date.now(),
			message: parseMessageTemplate(rawMessage, {
				...implicitContext,
				...properties
			}),
			rawMessage,
			properties: {
				...implicitContext,
				...properties
			}
		};
		this.emit(record, bypassSinks);
	}
	logLazily(level, callback, properties = {}) {
		const implicitContext = require_context.getImplicitContext();
		let rawMessage = void 0;
		let msg = void 0;
		function realizeMessage() {
			if (msg == null || rawMessage == null) {
				msg = callback((tpl, ...values) => {
					rawMessage = tpl;
					return renderMessage(tpl, values);
				});
				if (rawMessage == null) throw new TypeError("No log record was made.");
			}
			return [msg, rawMessage];
		}
		this.emit({
			category: this.category,
			level,
			get message() {
				return realizeMessage()[0];
			},
			get rawMessage() {
				return realizeMessage()[1];
			},
			timestamp: Date.now(),
			properties: {
				...implicitContext,
				...properties
			}
		});
	}
	logTemplate(level, messageTemplate, values, properties = {}) {
		const implicitContext = require_context.getImplicitContext();
		this.emit({
			category: this.category,
			level,
			message: renderMessage(messageTemplate, values),
			rawMessage: messageTemplate,
			timestamp: Date.now(),
			properties: {
				...implicitContext,
				...properties
			}
		});
	}
	trace(message, ...values) {
		if (typeof message === "string") this.log("trace", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("trace", message);
		else if (!Array.isArray(message)) this.log("trace", "{*}", message);
		else this.logTemplate("trace", message, values);
	}
	debug(message, ...values) {
		if (typeof message === "string") this.log("debug", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("debug", message);
		else if (!Array.isArray(message)) this.log("debug", "{*}", message);
		else this.logTemplate("debug", message, values);
	}
	info(message, ...values) {
		if (typeof message === "string") this.log("info", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("info", message);
		else if (!Array.isArray(message)) this.log("info", "{*}", message);
		else this.logTemplate("info", message, values);
	}
	warn(message, ...values) {
		if (typeof message === "string") this.log("warning", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("warning", message);
		else if (!Array.isArray(message)) this.log("warning", "{*}", message);
		else this.logTemplate("warning", message, values);
	}
	warning(message, ...values) {
		this.warn(message, ...values);
	}
	error(message, ...values) {
		if (typeof message === "string") this.log("error", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("error", message);
		else if (!Array.isArray(message)) this.log("error", "{*}", message);
		else this.logTemplate("error", message, values);
	}
	fatal(message, ...values) {
		if (typeof message === "string") this.log("fatal", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("fatal", message);
		else if (!Array.isArray(message)) this.log("fatal", "{*}", message);
		else this.logTemplate("fatal", message, values);
	}
};
/**
* A logger implementation with contextual properties.  Do not use this
* directly; use {@link Logger.with} instead.  This class is exported
* for testing purposes.
*/
var LoggerCtx = class LoggerCtx {
	logger;
	properties;
	constructor(logger, properties) {
		this.logger = logger;
		this.properties = properties;
	}
	get category() {
		return this.logger.category;
	}
	get parent() {
		return this.logger.parent;
	}
	getChild(subcategory) {
		return this.logger.getChild(subcategory).with(this.properties);
	}
	with(properties) {
		return new LoggerCtx(this.logger, {
			...this.properties,
			...properties
		});
	}
	log(level, message, properties, bypassSinks) {
		this.logger.log(level, message, typeof properties === "function" ? () => ({
			...this.properties,
			...properties()
		}) : {
			...this.properties,
			...properties
		}, bypassSinks);
	}
	logLazily(level, callback) {
		this.logger.logLazily(level, callback, this.properties);
	}
	logTemplate(level, messageTemplate, values) {
		this.logger.logTemplate(level, messageTemplate, values, this.properties);
	}
	emit(record) {
		const recordWithContext = {
			...record,
			properties: {
				...this.properties,
				...record.properties
			}
		};
		this.logger.emit(recordWithContext);
	}
	trace(message, ...values) {
		if (typeof message === "string") this.log("trace", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("trace", message);
		else if (!Array.isArray(message)) this.log("trace", "{*}", message);
		else this.logTemplate("trace", message, values);
	}
	debug(message, ...values) {
		if (typeof message === "string") this.log("debug", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("debug", message);
		else if (!Array.isArray(message)) this.log("debug", "{*}", message);
		else this.logTemplate("debug", message, values);
	}
	info(message, ...values) {
		if (typeof message === "string") this.log("info", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("info", message);
		else if (!Array.isArray(message)) this.log("info", "{*}", message);
		else this.logTemplate("info", message, values);
	}
	warn(message, ...values) {
		if (typeof message === "string") this.log("warning", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("warning", message);
		else if (!Array.isArray(message)) this.log("warning", "{*}", message);
		else this.logTemplate("warning", message, values);
	}
	warning(message, ...values) {
		this.warn(message, ...values);
	}
	error(message, ...values) {
		if (typeof message === "string") this.log("error", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("error", message);
		else if (!Array.isArray(message)) this.log("error", "{*}", message);
		else this.logTemplate("error", message, values);
	}
	fatal(message, ...values) {
		if (typeof message === "string") this.log("fatal", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("fatal", message);
		else if (!Array.isArray(message)) this.log("fatal", "{*}", message);
		else this.logTemplate("fatal", message, values);
	}
};
/**
* The meta logger.  It is a logger with the category `["logtape", "meta"]`.
*/
const metaLogger = LoggerImpl.getLogger(["logtape", "meta"]);
/**
* Check if a property access key contains nested access patterns.
* @param key The property key to check.
* @returns True if the key contains nested access patterns.
*/
function isNestedAccess(key) {
	return key.includes(".") || key.includes("[") || key.includes("?.");
}
/**
* Safely access an own property from an object, blocking prototype pollution.
*
* @param obj The object to access the property from.
* @param key The property key to access.
* @returns The property value or undefined if not accessible.
*/
function getOwnProperty(obj, key) {
	if (key === "__proto__" || key === "prototype" || key === "constructor") return void 0;
	if ((typeof obj === "object" || typeof obj === "function") && obj !== null) return Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
	return void 0;
}
/**
* Parse the next segment from a property path string.
*
* @param path The full property path string.
* @param fromIndex The index to start parsing from.
* @returns The parsed segment and next index, or null if parsing fails.
*/
function parseNextSegment(path, fromIndex) {
	const len = path.length;
	let i = fromIndex;
	if (i >= len) return null;
	let segment;
	if (path[i] === "[") {
		i++;
		if (i >= len) return null;
		if (path[i] === "\"" || path[i] === "'") {
			const quote = path[i];
			i++;
			let segmentStr = "";
			while (i < len && path[i] !== quote) if (path[i] === "\\") {
				i++;
				if (i < len) {
					const escapeChar = path[i];
					switch (escapeChar) {
						case "n":
							segmentStr += "\n";
							break;
						case "t":
							segmentStr += "	";
							break;
						case "r":
							segmentStr += "\r";
							break;
						case "b":
							segmentStr += "\b";
							break;
						case "f":
							segmentStr += "\f";
							break;
						case "v":
							segmentStr += "\v";
							break;
						case "0":
							segmentStr += "\0";
							break;
						case "\\":
							segmentStr += "\\";
							break;
						case "\"":
							segmentStr += "\"";
							break;
						case "'":
							segmentStr += "'";
							break;
						case "u":
							if (i + 4 < len) {
								const hex = path.slice(i + 1, i + 5);
								const codePoint = Number.parseInt(hex, 16);
								if (!Number.isNaN(codePoint)) {
									segmentStr += String.fromCharCode(codePoint);
									i += 4;
								} else segmentStr += escapeChar;
							} else segmentStr += escapeChar;
							break;
						default: segmentStr += escapeChar;
					}
					i++;
				}
			} else {
				segmentStr += path[i];
				i++;
			}
			if (i >= len) return null;
			segment = segmentStr;
			i++;
		} else {
			const startIndex = i;
			while (i < len && path[i] !== "]" && path[i] !== "'" && path[i] !== "\"") i++;
			if (i >= len) return null;
			const indexStr = path.slice(startIndex, i);
			if (indexStr.length === 0) return null;
			const indexNum = Number(indexStr);
			segment = Number.isNaN(indexNum) ? indexStr : indexNum;
		}
		while (i < len && path[i] !== "]") i++;
		if (i < len) i++;
	} else {
		const startIndex = i;
		while (i < len && path[i] !== "." && path[i] !== "[" && path[i] !== "?" && path[i] !== "]") i++;
		segment = path.slice(startIndex, i);
		if (segment.length === 0) return null;
	}
	if (i < len && path[i] === ".") i++;
	return {
		segment,
		nextIndex: i
	};
}
/**
* Access a property or index on an object or array.
*
* @param obj The object or array to access.
* @param segment The property key or array index.
* @returns The accessed value or undefined if not accessible.
*/
function accessProperty(obj, segment) {
	if (typeof segment === "string") return getOwnProperty(obj, segment);
	if (Array.isArray(obj) && segment >= 0 && segment < obj.length) return obj[segment];
	return void 0;
}
/**
* Resolve a nested property path from an object.
*
* There are two types of property access patterns:
* 1. Array/index access: [0] or ["prop"]
* 2. Property access: prop or prop?.next
*
* @param obj The object to traverse.
* @param path The property path (e.g., "user.name", "users[0].email", "user['full-name']").
* @returns The resolved value or undefined if path doesn't exist.
*/
function resolvePropertyPath(obj, path) {
	if (obj == null) return void 0;
	if (path.length === 0 || path.endsWith(".")) return void 0;
	let current = obj;
	let i = 0;
	const len = path.length;
	while (i < len) {
		const isOptional = path.slice(i, i + 2) === "?.";
		if (isOptional) {
			i += 2;
			if (current == null) return void 0;
		} else if (current == null) return void 0;
		const result = parseNextSegment(path, i);
		if (result === null) return void 0;
		const { segment, nextIndex } = result;
		i = nextIndex;
		current = accessProperty(current, segment);
		if (current === void 0) return void 0;
	}
	return current;
}
/**
* Parse a message template into a message template array and a values array.
*
* Placeholders to be replaced with `values` are indicated by keys in curly braces
* (e.g., `{value}`). The system supports both simple property access and nested
* property access patterns:
*
* **Simple property access:**
* ```ts
* parseMessageTemplate("Hello, {user}!", { user: "foo" })
* // Returns: ["Hello, ", "foo", "!"]
* ```
*
* **Nested property access (dot notation):**
* ```ts
* parseMessageTemplate("Hello, {user.name}!", {
*   user: { name: "foo", email: "foo@example.com" }
* })
* // Returns: ["Hello, ", "foo", "!"]
* ```
*
* **Array indexing:**
* ```ts
* parseMessageTemplate("First: {users[0]}", {
*   users: ["foo", "bar", "baz"]
* })
* // Returns: ["First: ", "foo", ""]
* ```
*
* **Bracket notation for special property names:**
* ```ts
* parseMessageTemplate("Name: {user[\"full-name\"]}", {
*   user: { "full-name": "foo bar" }
* })
* // Returns: ["Name: ", "foo bar", ""]
* ```
*
* **Optional chaining for safe navigation:**
* ```ts
* parseMessageTemplate("Email: {user?.profile?.email}", {
*   user: { name: "foo" }
* })
* // Returns: ["Email: ", undefined, ""]
* ```
*
* **Wildcard patterns:**
* - `{*}` - Replaced with the entire properties object
* - `{ key-with-whitespace }` - Whitespace is trimmed when looking up keys
*
* **Escaping:**
* - `{{` and `}}` are escaped literal braces
*
* **Error handling:**
* - Non-existent paths return `undefined`
* - Malformed expressions resolve to `undefined` without throwing errors
* - Out of bounds array access returns `undefined`
*
* @param template The message template string containing placeholders.
* @param properties The values to replace placeholders with.
* @returns The message template array with values interleaved between text segments.
*/
function parseMessageTemplate(template, properties) {
	const length = template.length;
	if (length === 0) return [""];
	if (!template.includes("{")) return [template];
	const message = [];
	let startIndex = 0;
	for (let i = 0; i < length; i++) {
		const char = template[i];
		if (char === "{") {
			const nextChar = i + 1 < length ? template[i + 1] : "";
			if (nextChar === "{") {
				i++;
				continue;
			}
			const closeIndex = template.indexOf("}", i + 1);
			if (closeIndex === -1) continue;
			const beforeText = template.slice(startIndex, i);
			message.push(beforeText.replace(/{{/g, "{").replace(/}}/g, "}"));
			const key = template.slice(i + 1, closeIndex);
			let prop;
			const trimmedKey = key.trim();
			if (trimmedKey === "*") prop = key in properties ? properties[key] : "*" in properties ? properties["*"] : properties;
			else {
				if (key !== trimmedKey) prop = key in properties ? properties[key] : properties[trimmedKey];
				else prop = properties[key];
				if (prop === void 0 && isNestedAccess(trimmedKey)) prop = resolvePropertyPath(properties, trimmedKey);
			}
			message.push(prop);
			i = closeIndex;
			startIndex = i + 1;
		} else if (char === "}" && i + 1 < length && template[i + 1] === "}") i++;
	}
	const remainingText = template.slice(startIndex);
	message.push(remainingText.replace(/{{/g, "{").replace(/}}/g, "}"));
	return message;
}
/**
* Render a message template with values.
* @param template The message template.
* @param values The message template values.
* @returns The message template values interleaved between the substitution
*          values.
*/
function renderMessage(template, values) {
	const args = [];
	for (let i = 0; i < template.length; i++) {
		args.push(template[i]);
		if (i < values.length) args.push(values[i]);
	}
	return args;
}

//#endregion
exports.LoggerImpl = LoggerImpl;
exports.getLogger = getLogger;